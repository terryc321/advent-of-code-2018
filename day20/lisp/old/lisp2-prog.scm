
(import (chicken format)) ;; format 
(import (chicken pretty-print)) 
(import srfi-1)
(import srfi-69)
;;(import bind)
(import bindings) ;; destructuring

(define *max-count* 4352)
(define *run-count* 0)
(define *endpoints* #f)


(define (make-2d-array cols rows  init)
  (let ((v (make-vector rows)))
    (do ((i 0 (+ i 1)))
        ((= i rows) v)
      (vector-set! v i (make-vector cols init)))))

(define (array-ref2 a i j)
  (vector-ref (vector-ref a (- j 1)) (- i 1)))

(define (array-set2! a i j val)
  (vector-set! (vector-ref a (- j 1)) (- i 1) val))

(define *step-array* (make-2d-array 2400 2400 #f))

;; each step we take gets entered into this hash table
;; initially at start position - we have taken no steps
;; the coordinate uses aoc 2 step for movement - then we can record the door
;; orientation .
;; checked after compilation that there is indeed no door that is orientated
;; in both directions.
(define *step-count* 0)
;; rather *step-hash* use a literal big array - how big ?
;; we can simply run though the 
;; (define *step-hash* (make-hash-table))

;; if we find a lower value n at x y - mark this square - otherwise continue nop
;; hopefully we dont choke with out of bounds !
(define (verify-step-array)
  (format #t "*step-array* read and write test ... ")
  (do ((y 1 (+ y 1)))
      ((>= y 2400) #f)
    (do ((x 1 (+ x 1)))
	((>= x 2400) #f)
      (let ((out (array-ref2 *step-array* x y)))
	(array-set2! *step-array* x y #f))))
  ;; we passed if we reach this far
  (format #t "passed ~%"))


;; activate the check !
(verify-step-array)


;; real coordinate (0,0) ...... becomes (1200,1200) in ARRAY encoding
;;                        <<<..... decoding we need subtract 1200,1200
(define (translate-in-x x)  (+ x 1200))
(define (translate-in-y y)  (+ y 1200))
(define (translate-out-x x)  (- x 1200))
(define (translate-out-y y)  (- y 1200))


(define (mark-square! x y n)
  (let* ((tx (translate-in-x x))
	 (ty (translate-in-y y))
	 (out (array-ref2 *step-array* tx ty)))
    (when
	(or (not out)
	    (and (integer? out) (< n out)))
      ;; (format #t "marking square ~a ~a with ~a : writing array at ~a ~a ~%" x y n tx ty)
      ;; (when (> n 30)
      ;; 	(format #t "enter something to continue ...~%")
      ;; 	(read))
      (array-set2! *step-array* tx ty n))))



(define id
  (let ((count 0))
    (lambda ()
      (set! count (+ count 1))
      count)))
  
(define (loading)
  (format #t "loading node ~a / ~a ~%" (id) *max-count*))

(define (report)
  (format #t "running node ~a / ~a ~%" (begin (set! *run-count* (+ 1 *run-count*)) *run-count*) *max-count*))



;; current no open doors 
(define *side-doors* (make-hash-table))
(define *trap-doors* (make-hash-table))


(define (open-side-door! x y)
  (hash-table-set! *side-doors* (make-point x y) #t))

(define (open-trap-door! x y)
  (hash-table-set! *trap-doors* (make-point x y) #t))


(define-record-type point
  (make-point x y)
  point?
  (x point-x point-x-set!)
  (y point-y point-y-set!))

(define-record-printer (point rt out)
  (fprintf out "#,(point ~s ~s)"  (point-x rt) (point-y rt)))


(define-record-type union
  (make-union ht)
  union?
  (ht union-ht))

(define (union-add un pts)
  (let ((ht (union-ht un)))
    (let loop ((pts pts))
      (cond
       ((null? pts) un)
       (#t (let* ((pt (car pts))
		  (found (hash-table-ref/default ht pt #f)))
	     (cond
	      (found #f)
	      (#t (hash-table-set! ht pt #t))))
	   (loop (cdr pts)))))))

(define (union-points un)
  (let ((ht (union-ht un)))
    (hash-table-map ht (lambda (k v) k))))

(define-record-printer (union rt out)
  (fprintf out "#,(union ~s)"  (union-points rt)))

;;
(define (run)
  (set! *endpoints* (t1 (list (make-point 0 0)))))

(define t0 #f)
(define t1 #f)
(define t2 #f)
(define t3 #f)
(define t4 #f)
(define t5 #f)
(define t6 #f)
(define t7 #f)
(define t8 #f)
(define t9 #f)
(define t10 #f)
(define t11 #f)
(define t12 #f)
(define t13 #f)
(define t14 #f)
(define t15 #f)
(define t16 #f)
(define t17 #f)
(define t18 #f)
(define t19 #f)
(define t20 #f)
(define t21 #f)
(define t22 #f)
(define t23 #f)
(define t24 #f)
(define t25 #f)
(define t26 #f)
(define t27 #f)
(define t28 #f)
(define t29 #f)
(define t30 #f)
(define t31 #f)
(define t32 #f)
(define t33 #f)
(define t34 #f)
(define t35 #f)
(define t36 #f)
(define t37 #f)
(define t38 #f)
(define t39 #f)
(define t40 #f)
(define t41 #f)
(define t42 #f)
(define t43 #f)
(define t44 #f)
(define t45 #f)
(define t46 #f)
(define t47 #f)
(define t48 #f)
(define t49 #f)
(define t50 #f)
(define t51 #f)
(define t52 #f)
(define t53 #f)
(define t54 #f)
(define t55 #f)
(define t56 #f)
(define t57 #f)
(define t58 #f)
(define t59 #f)
(define t60 #f)
(define t61 #f)
(define t62 #f)
(define t63 #f)
(define t64 #f)
(define t65 #f)
(define t66 #f)
(define t67 #f)
(define t68 #f)
(define t69 #f)
(define t70 #f)
(define t71 #f)
(define t72 #f)
(define t73 #f)
(define t74 #f)
(define t75 #f)
(define t76 #f)
(define t77 #f)
(define t78 #f)
(define t79 #f)
(define t80 #f)
(define t81 #f)
(define t82 #f)
(define t83 #f)
(define t84 #f)
(define t85 #f)
(define t86 #f)
(define t87 #f)
(define t88 #f)
(define t89 #f)
(define t90 #f)
(define t91 #f)
(define t92 #f)
(define t93 #f)
(define t94 #f)
(define t95 #f)
(define t96 #f)
(define t97 #f)
(define t98 #f)
(define t99 #f)
(define t100 #f)
(define t101 #f)
(define t102 #f)
(define t103 #f)
(define t104 #f)
(define t105 #f)
(define t106 #f)
(define t107 #f)
(define t108 #f)
(define t109 #f)
(define t110 #f)
(define t111 #f)
(define t112 #f)
(define t113 #f)
(define t114 #f)
(define t115 #f)
(define t116 #f)
(define t117 #f)
(define t118 #f)
(define t119 #f)
(define t120 #f)
(define t121 #f)
(define t122 #f)
(define t123 #f)
(define t124 #f)
(define t125 #f)
(define t126 #f)
(define t127 #f)
(define t128 #f)
(define t129 #f)
(define t130 #f)
(define t131 #f)
(define t132 #f)
(define t133 #f)
(define t134 #f)
(define t135 #f)
(define t136 #f)
(define t137 #f)
(define t138 #f)
(define t139 #f)
(define t140 #f)
(define t141 #f)
(define t142 #f)
(define t143 #f)
(define t144 #f)
(define t145 #f)
(define t146 #f)
(define t147 #f)
(define t148 #f)
(define t149 #f)
(define t150 #f)
(define t151 #f)
(define t152 #f)
(define t153 #f)
(define t154 #f)
(define t155 #f)
(define t156 #f)
(define t157 #f)
(define t158 #f)
(define t159 #f)
(define t160 #f)
(define t161 #f)
(define t162 #f)
(define t163 #f)
(define t164 #f)
(define t165 #f)
(define t166 #f)
(define t167 #f)
(define t168 #f)
(define t169 #f)
(define t170 #f)
(define t171 #f)
(define t172 #f)
(define t173 #f)
(define t174 #f)
(define t175 #f)
(define t176 #f)
(define t177 #f)
(define t178 #f)
(define t179 #f)
(define t180 #f)
(define t181 #f)
(define t182 #f)
(define t183 #f)
(define t184 #f)
(define t185 #f)
(define t186 #f)
(define t187 #f)
(define t188 #f)
(define t189 #f)
(define t190 #f)
(define t191 #f)
(define t192 #f)
(define t193 #f)
(define t194 #f)
(define t195 #f)
(define t196 #f)
(define t197 #f)
(define t198 #f)
(define t199 #f)
(define t200 #f)
(define t201 #f)
(define t202 #f)
(define t203 #f)
(define t204 #f)
(define t205 #f)
(define t206 #f)
(define t207 #f)
(define t208 #f)
(define t209 #f)
(define t210 #f)
(define t211 #f)
(define t212 #f)
(define t213 #f)
(define t214 #f)
(define t215 #f)
(define t216 #f)
(define t217 #f)
(define t218 #f)
(define t219 #f)
(define t220 #f)
(define t221 #f)
(define t222 #f)
(define t223 #f)
(define t224 #f)
(define t225 #f)
(define t226 #f)
(define t227 #f)
(define t228 #f)
(define t229 #f)
(define t230 #f)
(define t231 #f)
(define t232 #f)
(define t233 #f)
(define t234 #f)
(define t235 #f)
(define t236 #f)
(define t237 #f)
(define t238 #f)
(define t239 #f)
(define t240 #f)
(define t241 #f)
(define t242 #f)
(define t243 #f)
(define t244 #f)
(define t245 #f)
(define t246 #f)
(define t247 #f)
(define t248 #f)
(define t249 #f)
(define t250 #f)
(define t251 #f)
(define t252 #f)
(define t253 #f)
(define t254 #f)
(define t255 #f)
(define t256 #f)
(define t257 #f)
(define t258 #f)
(define t259 #f)
(define t260 #f)
(define t261 #f)
(define t262 #f)
(define t263 #f)
(define t264 #f)
(define t265 #f)
(define t266 #f)
(define t267 #f)
(define t268 #f)
(define t269 #f)
(define t270 #f)
(define t271 #f)
(define t272 #f)
(define t273 #f)
(define t274 #f)
(define t275 #f)
(define t276 #f)
(define t277 #f)
(define t278 #f)
(define t279 #f)
(define t280 #f)
(define t281 #f)
(define t282 #f)
(define t283 #f)
(define t284 #f)
(define t285 #f)
(define t286 #f)
(define t287 #f)
(define t288 #f)
(define t289 #f)
(define t290 #f)
(define t291 #f)
(define t292 #f)
(define t293 #f)
(define t294 #f)
(define t295 #f)
(define t296 #f)
(define t297 #f)
(define t298 #f)
(define t299 #f)
(define t300 #f)
(define t301 #f)
(define t302 #f)
(define t303 #f)
(define t304 #f)
(define t305 #f)
(define t306 #f)
(define t307 #f)
(define t308 #f)
(define t309 #f)
(define t310 #f)
(define t311 #f)
(define t312 #f)
(define t313 #f)
(define t314 #f)
(define t315 #f)
(define t316 #f)
(define t317 #f)
(define t318 #f)
(define t319 #f)
(define t320 #f)
(define t321 #f)
(define t322 #f)
(define t323 #f)
(define t324 #f)
(define t325 #f)
(define t326 #f)
(define t327 #f)
(define t328 #f)
(define t329 #f)
(define t330 #f)
(define t331 #f)
(define t332 #f)
(define t333 #f)
(define t334 #f)
(define t335 #f)
(define t336 #f)
(define t337 #f)
(define t338 #f)
(define t339 #f)
(define t340 #f)
(define t341 #f)
(define t342 #f)
(define t343 #f)
(define t344 #f)
(define t345 #f)
(define t346 #f)
(define t347 #f)
(define t348 #f)
(define t349 #f)
(define t350 #f)
(define t351 #f)
(define t352 #f)
(define t353 #f)
(define t354 #f)
(define t355 #f)
(define t356 #f)
(define t357 #f)
(define t358 #f)
(define t359 #f)
(define t360 #f)
(define t361 #f)
(define t362 #f)
(define t363 #f)
(define t364 #f)
(define t365 #f)
(define t366 #f)
(define t367 #f)
(define t368 #f)
(define t369 #f)
(define t370 #f)
(define t371 #f)
(define t372 #f)
(define t373 #f)
(define t374 #f)
(define t375 #f)
(define t376 #f)
(define t377 #f)
(define t378 #f)
(define t379 #f)
(define t380 #f)
(define t381 #f)
(define t382 #f)
(define t383 #f)
(define t384 #f)
(define t385 #f)
(define t386 #f)
(define t387 #f)
(define t388 #f)
(define t389 #f)
(define t390 #f)
(define t391 #f)
(define t392 #f)
(define t393 #f)
(define t394 #f)
(define t395 #f)
(define t396 #f)
(define t397 #f)
(define t398 #f)
(define t399 #f)
(define t400 #f)
(define t401 #f)
(define t402 #f)
(define t403 #f)
(define t404 #f)
(define t405 #f)
(define t406 #f)
(define t407 #f)
(define t408 #f)
(define t409 #f)
(define t410 #f)
(define t411 #f)
(define t412 #f)
(define t413 #f)
(define t414 #f)
(define t415 #f)
(define t416 #f)
(define t417 #f)
(define t418 #f)
(define t419 #f)
(define t420 #f)
(define t421 #f)
(define t422 #f)
(define t423 #f)
(define t424 #f)
(define t425 #f)
(define t426 #f)
(define t427 #f)
(define t428 #f)
(define t429 #f)
(define t430 #f)
(define t431 #f)
(define t432 #f)
(define t433 #f)
(define t434 #f)
(define t435 #f)
(define t436 #f)
(define t437 #f)
(define t438 #f)
(define t439 #f)
(define t440 #f)
(define t441 #f)
(define t442 #f)
(define t443 #f)
(define t444 #f)
(define t445 #f)
(define t446 #f)
(define t447 #f)
(define t448 #f)
(define t449 #f)
(define t450 #f)
(define t451 #f)
(define t452 #f)
(define t453 #f)
(define t454 #f)
(define t455 #f)
(define t456 #f)
(define t457 #f)
(define t458 #f)
(define t459 #f)
(define t460 #f)
(define t461 #f)
(define t462 #f)
(define t463 #f)
(define t464 #f)
(define t465 #f)
(define t466 #f)
(define t467 #f)
(define t468 #f)
(define t469 #f)
(define t470 #f)
(define t471 #f)
(define t472 #f)
(define t473 #f)
(define t474 #f)
(define t475 #f)
(define t476 #f)
(define t477 #f)
(define t478 #f)
(define t479 #f)
(define t480 #f)
(define t481 #f)
(define t482 #f)
(define t483 #f)
(define t484 #f)
(define t485 #f)
(define t486 #f)
(define t487 #f)
(define t488 #f)
(define t489 #f)
(define t490 #f)
(define t491 #f)
(define t492 #f)
(define t493 #f)
(define t494 #f)
(define t495 #f)
(define t496 #f)
(define t497 #f)
(define t498 #f)
(define t499 #f)
(define t500 #f)
(define t501 #f)
(define t502 #f)
(define t503 #f)
(define t504 #f)
(define t505 #f)
(define t506 #f)
(define t507 #f)
(define t508 #f)
(define t509 #f)
(define t510 #f)
(define t511 #f)
(define t512 #f)
(define t513 #f)
(define t514 #f)
(define t515 #f)
(define t516 #f)
(define t517 #f)
(define t518 #f)
(define t519 #f)
(define t520 #f)
(define t521 #f)
(define t522 #f)
(define t523 #f)
(define t524 #f)
(define t525 #f)
(define t526 #f)
(define t527 #f)
(define t528 #f)
(define t529 #f)
(define t530 #f)
(define t531 #f)
(define t532 #f)
(define t533 #f)
(define t534 #f)
(define t535 #f)
(define t536 #f)
(define t537 #f)
(define t538 #f)
(define t539 #f)
(define t540 #f)
(define t541 #f)
(define t542 #f)
(define t543 #f)
(define t544 #f)
(define t545 #f)
(define t546 #f)
(define t547 #f)
(define t548 #f)
(define t549 #f)
(define t550 #f)
(define t551 #f)
(define t552 #f)
(define t553 #f)
(define t554 #f)
(define t555 #f)
(define t556 #f)
(define t557 #f)
(define t558 #f)
(define t559 #f)
(define t560 #f)
(define t561 #f)
(define t562 #f)
(define t563 #f)
(define t564 #f)
(define t565 #f)
(define t566 #f)
(define t567 #f)
(define t568 #f)
(define t569 #f)
(define t570 #f)
(define t571 #f)
(define t572 #f)
(define t573 #f)
(define t574 #f)
(define t575 #f)
(define t576 #f)
(define t577 #f)
(define t578 #f)
(define t579 #f)
(define t580 #f)
(define t581 #f)
(define t582 #f)
(define t583 #f)
(define t584 #f)
(define t585 #f)
(define t586 #f)
(define t587 #f)
(define t588 #f)
(define t589 #f)
(define t590 #f)
(define t591 #f)
(define t592 #f)
(define t593 #f)
(define t594 #f)
(define t595 #f)
(define t596 #f)
(define t597 #f)
(define t598 #f)
(define t599 #f)
(define t600 #f)
(define t601 #f)
(define t602 #f)
(define t603 #f)
(define t604 #f)
(define t605 #f)
(define t606 #f)
(define t607 #f)
(define t608 #f)
(define t609 #f)
(define t610 #f)
(define t611 #f)
(define t612 #f)
(define t613 #f)
(define t614 #f)
(define t615 #f)
(define t616 #f)
(define t617 #f)
(define t618 #f)
(define t619 #f)
(define t620 #f)
(define t621 #f)
(define t622 #f)
(define t623 #f)
(define t624 #f)
(define t625 #f)
(define t626 #f)
(define t627 #f)
(define t628 #f)
(define t629 #f)
(define t630 #f)
(define t631 #f)
(define t632 #f)
(define t633 #f)
(define t634 #f)
(define t635 #f)
(define t636 #f)
(define t637 #f)
(define t638 #f)
(define t639 #f)
(define t640 #f)
(define t641 #f)
(define t642 #f)
(define t643 #f)
(define t644 #f)
(define t645 #f)
(define t646 #f)
(define t647 #f)
(define t648 #f)
(define t649 #f)
(define t650 #f)
(define t651 #f)
(define t652 #f)
(define t653 #f)
(define t654 #f)
(define t655 #f)
(define t656 #f)
(define t657 #f)
(define t658 #f)
(define t659 #f)
(define t660 #f)
(define t661 #f)
(define t662 #f)
(define t663 #f)
(define t664 #f)
(define t665 #f)
(define t666 #f)
(define t667 #f)
(define t668 #f)
(define t669 #f)
(define t670 #f)
(define t671 #f)
(define t672 #f)
(define t673 #f)
(define t674 #f)
(define t675 #f)
(define t676 #f)
(define t677 #f)
(define t678 #f)
(define t679 #f)
(define t680 #f)
(define t681 #f)
(define t682 #f)
(define t683 #f)
(define t684 #f)
(define t685 #f)
(define t686 #f)
(define t687 #f)
(define t688 #f)
(define t689 #f)
(define t690 #f)
(define t691 #f)
(define t692 #f)
(define t693 #f)
(define t694 #f)
(define t695 #f)
(define t696 #f)
(define t697 #f)
(define t698 #f)
(define t699 #f)
(define t700 #f)
(define t701 #f)
(define t702 #f)
(define t703 #f)
(define t704 #f)
(define t705 #f)
(define t706 #f)
(define t707 #f)
(define t708 #f)
(define t709 #f)
(define t710 #f)
(define t711 #f)
(define t712 #f)
(define t713 #f)
(define t714 #f)
(define t715 #f)
(define t716 #f)
(define t717 #f)
(define t718 #f)
(define t719 #f)
(define t720 #f)
(define t721 #f)
(define t722 #f)
(define t723 #f)
(define t724 #f)
(define t725 #f)
(define t726 #f)
(define t727 #f)
(define t728 #f)
(define t729 #f)
(define t730 #f)
(define t731 #f)
(define t732 #f)
(define t733 #f)
(define t734 #f)
(define t735 #f)
(define t736 #f)
(define t737 #f)
(define t738 #f)
(define t739 #f)
(define t740 #f)
(define t741 #f)
(define t742 #f)
(define t743 #f)
(define t744 #f)
(define t745 #f)
(define t746 #f)
(define t747 #f)
(define t748 #f)
(define t749 #f)
(define t750 #f)
(define t751 #f)
(define t752 #f)
(define t753 #f)
(define t754 #f)
(define t755 #f)
(define t756 #f)
(define t757 #f)
(define t758 #f)
(define t759 #f)
(define t760 #f)
(define t761 #f)
(define t762 #f)
(define t763 #f)
(define t764 #f)
(define t765 #f)
(define t766 #f)
(define t767 #f)
(define t768 #f)
(define t769 #f)
(define t770 #f)
(define t771 #f)
(define t772 #f)
(define t773 #f)
(define t774 #f)
(define t775 #f)
(define t776 #f)
(define t777 #f)
(define t778 #f)
(define t779 #f)
(define t780 #f)
(define t781 #f)
(define t782 #f)
(define t783 #f)
(define t784 #f)
(define t785 #f)
(define t786 #f)
(define t787 #f)
(define t788 #f)
(define t789 #f)
(define t790 #f)
(define t791 #f)
(define t792 #f)
(define t793 #f)
(define t794 #f)
(define t795 #f)
(define t796 #f)
(define t797 #f)
(define t798 #f)
(define t799 #f)
(define t800 #f)
(define t801 #f)
(define t802 #f)
(define t803 #f)
(define t804 #f)
(define t805 #f)
(define t806 #f)
(define t807 #f)
(define t808 #f)
(define t809 #f)
(define t810 #f)
(define t811 #f)
(define t812 #f)
(define t813 #f)
(define t814 #f)
(define t815 #f)
(define t816 #f)
(define t817 #f)
(define t818 #f)
(define t819 #f)
(define t820 #f)
(define t821 #f)
(define t822 #f)
(define t823 #f)
(define t824 #f)
(define t825 #f)
(define t826 #f)
(define t827 #f)
(define t828 #f)
(define t829 #f)
(define t830 #f)
(define t831 #f)
(define t832 #f)
(define t833 #f)
(define t834 #f)
(define t835 #f)
(define t836 #f)
(define t837 #f)
(define t838 #f)
(define t839 #f)
(define t840 #f)
(define t841 #f)
(define t842 #f)
(define t843 #f)
(define t844 #f)
(define t845 #f)
(define t846 #f)
(define t847 #f)
(define t848 #f)
(define t849 #f)
(define t850 #f)
(define t851 #f)
(define t852 #f)
(define t853 #f)
(define t854 #f)
(define t855 #f)
(define t856 #f)
(define t857 #f)
(define t858 #f)
(define t859 #f)
(define t860 #f)
(define t861 #f)
(define t862 #f)
(define t863 #f)
(define t864 #f)
(define t865 #f)
(define t866 #f)
(define t867 #f)
(define t868 #f)
(define t869 #f)
(define t870 #f)
(define t871 #f)
(define t872 #f)
(define t873 #f)
(define t874 #f)
(define t875 #f)
(define t876 #f)
(define t877 #f)
(define t878 #f)
(define t879 #f)
(define t880 #f)
(define t881 #f)
(define t882 #f)
(define t883 #f)
(define t884 #f)
(define t885 #f)
(define t886 #f)
(define t887 #f)
(define t888 #f)
(define t889 #f)
(define t890 #f)
(define t891 #f)
(define t892 #f)
(define t893 #f)
(define t894 #f)
(define t895 #f)
(define t896 #f)
(define t897 #f)
(define t898 #f)
(define t899 #f)
(define t900 #f)
(define t901 #f)
(define t902 #f)
(define t903 #f)
(define t904 #f)
(define t905 #f)
(define t906 #f)
(define t907 #f)
(define t908 #f)
(define t909 #f)
(define t910 #f)
(define t911 #f)
(define t912 #f)
(define t913 #f)
(define t914 #f)
(define t915 #f)
(define t916 #f)
(define t917 #f)
(define t918 #f)
(define t919 #f)
(define t920 #f)
(define t921 #f)
(define t922 #f)
(define t923 #f)
(define t924 #f)
(define t925 #f)
(define t926 #f)
(define t927 #f)
(define t928 #f)
(define t929 #f)
(define t930 #f)
(define t931 #f)
(define t932 #f)
(define t933 #f)
(define t934 #f)
(define t935 #f)
(define t936 #f)
(define t937 #f)
(define t938 #f)
(define t939 #f)
(define t940 #f)
(define t941 #f)
(define t942 #f)
(define t943 #f)
(define t944 #f)
(define t945 #f)
(define t946 #f)
(define t947 #f)
(define t948 #f)
(define t949 #f)
(define t950 #f)
(define t951 #f)
(define t952 #f)
(define t953 #f)
(define t954 #f)
(define t955 #f)
(define t956 #f)
(define t957 #f)
(define t958 #f)
(define t959 #f)
(define t960 #f)
(define t961 #f)
(define t962 #f)
(define t963 #f)
(define t964 #f)
(define t965 #f)
(define t966 #f)
(define t967 #f)
(define t968 #f)
(define t969 #f)
(define t970 #f)
(define t971 #f)
(define t972 #f)
(define t973 #f)
(define t974 #f)
(define t975 #f)
(define t976 #f)
(define t977 #f)
(define t978 #f)
(define t979 #f)
(define t980 #f)
(define t981 #f)
(define t982 #f)
(define t983 #f)
(define t984 #f)
(define t985 #f)
(define t986 #f)
(define t987 #f)
(define t988 #f)
(define t989 #f)
(define t990 #f)
(define t991 #f)
(define t992 #f)
(define t993 #f)
(define t994 #f)
(define t995 #f)
(define t996 #f)
(define t997 #f)
(define t998 #f)
(define t999 #f)
(define t1000 #f)
(define t1001 #f)
(define t1002 #f)
(define t1003 #f)
(define t1004 #f)
(define t1005 #f)
(define t1006 #f)
(define t1007 #f)
(define t1008 #f)
(define t1009 #f)
(define t1010 #f)
(define t1011 #f)
(define t1012 #f)
(define t1013 #f)
(define t1014 #f)
(define t1015 #f)
(define t1016 #f)
(define t1017 #f)
(define t1018 #f)
(define t1019 #f)
(define t1020 #f)
(define t1021 #f)
(define t1022 #f)
(define t1023 #f)
(define t1024 #f)
(define t1025 #f)
(define t1026 #f)
(define t1027 #f)
(define t1028 #f)
(define t1029 #f)
(define t1030 #f)
(define t1031 #f)
(define t1032 #f)
(define t1033 #f)
(define t1034 #f)
(define t1035 #f)
(define t1036 #f)
(define t1037 #f)
(define t1038 #f)
(define t1039 #f)
(define t1040 #f)
(define t1041 #f)
(define t1042 #f)
(define t1043 #f)
(define t1044 #f)
(define t1045 #f)
(define t1046 #f)
(define t1047 #f)
(define t1048 #f)
(define t1049 #f)
(define t1050 #f)
(define t1051 #f)
(define t1052 #f)
(define t1053 #f)
(define t1054 #f)
(define t1055 #f)
(define t1056 #f)
(define t1057 #f)
(define t1058 #f)
(define t1059 #f)
(define t1060 #f)
(define t1061 #f)
(define t1062 #f)
(define t1063 #f)
(define t1064 #f)
(define t1065 #f)
(define t1066 #f)
(define t1067 #f)
(define t1068 #f)
(define t1069 #f)
(define t1070 #f)
(define t1071 #f)
(define t1072 #f)
(define t1073 #f)
(define t1074 #f)
(define t1075 #f)
(define t1076 #f)
(define t1077 #f)
(define t1078 #f)
(define t1079 #f)
(define t1080 #f)
(define t1081 #f)
(define t1082 #f)
(define t1083 #f)
(define t1084 #f)
(define t1085 #f)
(define t1086 #f)
(define t1087 #f)
(define t1088 #f)
(define t1089 #f)
(define t1090 #f)
(define t1091 #f)
(define t1092 #f)
(define t1093 #f)
(define t1094 #f)
(define t1095 #f)
(define t1096 #f)
(define t1097 #f)
(define t1098 #f)
(define t1099 #f)
(define t1100 #f)
(define t1101 #f)
(define t1102 #f)
(define t1103 #f)
(define t1104 #f)
(define t1105 #f)
(define t1106 #f)
(define t1107 #f)
(define t1108 #f)
(define t1109 #f)
(define t1110 #f)
(define t1111 #f)
(define t1112 #f)
(define t1113 #f)
(define t1114 #f)
(define t1115 #f)
(define t1116 #f)
(define t1117 #f)
(define t1118 #f)
(define t1119 #f)
(define t1120 #f)
(define t1121 #f)
(define t1122 #f)
(define t1123 #f)
(define t1124 #f)
(define t1125 #f)
(define t1126 #f)
(define t1127 #f)
(define t1128 #f)
(define t1129 #f)
(define t1130 #f)
(define t1131 #f)
(define t1132 #f)
(define t1133 #f)
(define t1134 #f)
(define t1135 #f)
(define t1136 #f)
(define t1137 #f)
(define t1138 #f)
(define t1139 #f)
(define t1140 #f)
(define t1141 #f)
(define t1142 #f)
(define t1143 #f)
(define t1144 #f)
(define t1145 #f)
(define t1146 #f)
(define t1147 #f)
(define t1148 #f)
(define t1149 #f)
(define t1150 #f)
(define t1151 #f)
(define t1152 #f)
(define t1153 #f)
(define t1154 #f)
(define t1155 #f)
(define t1156 #f)
(define t1157 #f)
(define t1158 #f)
(define t1159 #f)
(define t1160 #f)
(define t1161 #f)
(define t1162 #f)
(define t1163 #f)
(define t1164 #f)
(define t1165 #f)
(define t1166 #f)
(define t1167 #f)
(define t1168 #f)
(define t1169 #f)
(define t1170 #f)
(define t1171 #f)
(define t1172 #f)
(define t1173 #f)
(define t1174 #f)
(define t1175 #f)
(define t1176 #f)
(define t1177 #f)
(define t1178 #f)
(define t1179 #f)
(define t1180 #f)
(define t1181 #f)
(define t1182 #f)
(define t1183 #f)
(define t1184 #f)
(define t1185 #f)
(define t1186 #f)
(define t1187 #f)
(define t1188 #f)
(define t1189 #f)
(define t1190 #f)
(define t1191 #f)
(define t1192 #f)
(define t1193 #f)
(define t1194 #f)
(define t1195 #f)
(define t1196 #f)
(define t1197 #f)
(define t1198 #f)
(define t1199 #f)
(define t1200 #f)
(define t1201 #f)
(define t1202 #f)
(define t1203 #f)
(define t1204 #f)
(define t1205 #f)
(define t1206 #f)
(define t1207 #f)
(define t1208 #f)
(define t1209 #f)
(define t1210 #f)
(define t1211 #f)
(define t1212 #f)
(define t1213 #f)
(define t1214 #f)
(define t1215 #f)
(define t1216 #f)
(define t1217 #f)
(define t1218 #f)
(define t1219 #f)
(define t1220 #f)
(define t1221 #f)
(define t1222 #f)
(define t1223 #f)
(define t1224 #f)
(define t1225 #f)
(define t1226 #f)
(define t1227 #f)
(define t1228 #f)
(define t1229 #f)
(define t1230 #f)
(define t1231 #f)
(define t1232 #f)
(define t1233 #f)
(define t1234 #f)
(define t1235 #f)
(define t1236 #f)
(define t1237 #f)
(define t1238 #f)
(define t1239 #f)
(define t1240 #f)
(define t1241 #f)
(define t1242 #f)
(define t1243 #f)
(define t1244 #f)
(define t1245 #f)
(define t1246 #f)
(define t1247 #f)
(define t1248 #f)
(define t1249 #f)
(define t1250 #f)
(define t1251 #f)
(define t1252 #f)
(define t1253 #f)
(define t1254 #f)
(define t1255 #f)
(define t1256 #f)
(define t1257 #f)
(define t1258 #f)
(define t1259 #f)
(define t1260 #f)
(define t1261 #f)
(define t1262 #f)
(define t1263 #f)
(define t1264 #f)
(define t1265 #f)
(define t1266 #f)
(define t1267 #f)
(define t1268 #f)
(define t1269 #f)
(define t1270 #f)
(define t1271 #f)
(define t1272 #f)
(define t1273 #f)
(define t1274 #f)
(define t1275 #f)
(define t1276 #f)
(define t1277 #f)
(define t1278 #f)
(define t1279 #f)
(define t1280 #f)
(define t1281 #f)
(define t1282 #f)
(define t1283 #f)
(define t1284 #f)
(define t1285 #f)
(define t1286 #f)
(define t1287 #f)
(define t1288 #f)
(define t1289 #f)
(define t1290 #f)
(define t1291 #f)
(define t1292 #f)
(define t1293 #f)
(define t1294 #f)
(define t1295 #f)
(define t1296 #f)
(define t1297 #f)
(define t1298 #f)
(define t1299 #f)
(define t1300 #f)
(define t1301 #f)
(define t1302 #f)
(define t1303 #f)
(define t1304 #f)
(define t1305 #f)
(define t1306 #f)
(define t1307 #f)
(define t1308 #f)
(define t1309 #f)
(define t1310 #f)
(define t1311 #f)
(define t1312 #f)
(define t1313 #f)
(define t1314 #f)
(define t1315 #f)
(define t1316 #f)
(define t1317 #f)
(define t1318 #f)
(define t1319 #f)
(define t1320 #f)
(define t1321 #f)
(define t1322 #f)
(define t1323 #f)
(define t1324 #f)
(define t1325 #f)
(define t1326 #f)
(define t1327 #f)
(define t1328 #f)
(define t1329 #f)
(define t1330 #f)
(define t1331 #f)
(define t1332 #f)
(define t1333 #f)
(define t1334 #f)
(define t1335 #f)
(define t1336 #f)
(define t1337 #f)
(define t1338 #f)
(define t1339 #f)
(define t1340 #f)
(define t1341 #f)
(define t1342 #f)
(define t1343 #f)
(define t1344 #f)
(define t1345 #f)
(define t1346 #f)
(define t1347 #f)
(define t1348 #f)
(define t1349 #f)
(define t1350 #f)
(define t1351 #f)
(define t1352 #f)
(define t1353 #f)
(define t1354 #f)
(define t1355 #f)
(define t1356 #f)
(define t1357 #f)
(define t1358 #f)
(define t1359 #f)
(define t1360 #f)
(define t1361 #f)
(define t1362 #f)
(define t1363 #f)
(define t1364 #f)
(define t1365 #f)
(define t1366 #f)
(define t1367 #f)
(define t1368 #f)
(define t1369 #f)
(define t1370 #f)
(define t1371 #f)
(define t1372 #f)
(define t1373 #f)
(define t1374 #f)
(define t1375 #f)
(define t1376 #f)
(define t1377 #f)
(define t1378 #f)
(define t1379 #f)
(define t1380 #f)
(define t1381 #f)
(define t1382 #f)
(define t1383 #f)
(define t1384 #f)
(define t1385 #f)
(define t1386 #f)
(define t1387 #f)
(define t1388 #f)
(define t1389 #f)
(define t1390 #f)
(define t1391 #f)
(define t1392 #f)
(define t1393 #f)
(define t1394 #f)
(define t1395 #f)
(define t1396 #f)
(define t1397 #f)
(define t1398 #f)
(define t1399 #f)
(define t1400 #f)
(define t1401 #f)
(define t1402 #f)
(define t1403 #f)
(define t1404 #f)
(define t1405 #f)
(define t1406 #f)
(define t1407 #f)
(define t1408 #f)
(define t1409 #f)
(define t1410 #f)
(define t1411 #f)
(define t1412 #f)
(define t1413 #f)
(define t1414 #f)
(define t1415 #f)
(define t1416 #f)
(define t1417 #f)
(define t1418 #f)
(define t1419 #f)
(define t1420 #f)
(define t1421 #f)
(define t1422 #f)
(define t1423 #f)
(define t1424 #f)
(define t1425 #f)
(define t1426 #f)
(define t1427 #f)
(define t1428 #f)
(define t1429 #f)
(define t1430 #f)
(define t1431 #f)
(define t1432 #f)
(define t1433 #f)
(define t1434 #f)
(define t1435 #f)
(define t1436 #f)
(define t1437 #f)
(define t1438 #f)
(define t1439 #f)
(define t1440 #f)
(define t1441 #f)
(define t1442 #f)
(define t1443 #f)
(define t1444 #f)
(define t1445 #f)
(define t1446 #f)
(define t1447 #f)
(define t1448 #f)
(define t1449 #f)
(define t1450 #f)
(define t1451 #f)
(define t1452 #f)
(define t1453 #f)
(define t1454 #f)
(define t1455 #f)
(define t1456 #f)
(define t1457 #f)
(define t1458 #f)
(define t1459 #f)
(define t1460 #f)
(define t1461 #f)
(define t1462 #f)
(define t1463 #f)
(define t1464 #f)
(define t1465 #f)
(define t1466 #f)
(define t1467 #f)
(define t1468 #f)
(define t1469 #f)
(define t1470 #f)
(define t1471 #f)
(define t1472 #f)
(define t1473 #f)
(define t1474 #f)
(define t1475 #f)
(define t1476 #f)
(define t1477 #f)
(define t1478 #f)
(define t1479 #f)
(define t1480 #f)
(define t1481 #f)
(define t1482 #f)
(define t1483 #f)
(define t1484 #f)
(define t1485 #f)
(define t1486 #f)
(define t1487 #f)
(define t1488 #f)
(define t1489 #f)
(define t1490 #f)
(define t1491 #f)
(define t1492 #f)
(define t1493 #f)
(define t1494 #f)
(define t1495 #f)
(define t1496 #f)
(define t1497 #f)
(define t1498 #f)
(define t1499 #f)
(define t1500 #f)
(define t1501 #f)
(define t1502 #f)
(define t1503 #f)
(define t1504 #f)
(define t1505 #f)
(define t1506 #f)
(define t1507 #f)
(define t1508 #f)
(define t1509 #f)
(define t1510 #f)
(define t1511 #f)
(define t1512 #f)
(define t1513 #f)
(define t1514 #f)
(define t1515 #f)
(define t1516 #f)
(define t1517 #f)
(define t1518 #f)
(define t1519 #f)
(define t1520 #f)
(define t1521 #f)
(define t1522 #f)
(define t1523 #f)
(define t1524 #f)
(define t1525 #f)
(define t1526 #f)
(define t1527 #f)
(define t1528 #f)
(define t1529 #f)
(define t1530 #f)
(define t1531 #f)
(define t1532 #f)
(define t1533 #f)
(define t1534 #f)
(define t1535 #f)
(define t1536 #f)
(define t1537 #f)
(define t1538 #f)
(define t1539 #f)
(define t1540 #f)
(define t1541 #f)
(define t1542 #f)
(define t1543 #f)
(define t1544 #f)
(define t1545 #f)
(define t1546 #f)
(define t1547 #f)
(define t1548 #f)
(define t1549 #f)
(define t1550 #f)
(define t1551 #f)
(define t1552 #f)
(define t1553 #f)
(define t1554 #f)
(define t1555 #f)
(define t1556 #f)
(define t1557 #f)
(define t1558 #f)
(define t1559 #f)
(define t1560 #f)
(define t1561 #f)
(define t1562 #f)
(define t1563 #f)
(define t1564 #f)
(define t1565 #f)
(define t1566 #f)
(define t1567 #f)
(define t1568 #f)
(define t1569 #f)
(define t1570 #f)
(define t1571 #f)
(define t1572 #f)
(define t1573 #f)
(define t1574 #f)
(define t1575 #f)
(define t1576 #f)
(define t1577 #f)
(define t1578 #f)
(define t1579 #f)
(define t1580 #f)
(define t1581 #f)
(define t1582 #f)
(define t1583 #f)
(define t1584 #f)
(define t1585 #f)
(define t1586 #f)
(define t1587 #f)
(define t1588 #f)
(define t1589 #f)
(define t1590 #f)
(define t1591 #f)
(define t1592 #f)
(define t1593 #f)
(define t1594 #f)
(define t1595 #f)
(define t1596 #f)
(define t1597 #f)
(define t1598 #f)
(define t1599 #f)
(define t1600 #f)
(define t1601 #f)
(define t1602 #f)
(define t1603 #f)
(define t1604 #f)
(define t1605 #f)
(define t1606 #f)
(define t1607 #f)
(define t1608 #f)
(define t1609 #f)
(define t1610 #f)
(define t1611 #f)
(define t1612 #f)
(define t1613 #f)
(define t1614 #f)
(define t1615 #f)
(define t1616 #f)
(define t1617 #f)
(define t1618 #f)
(define t1619 #f)
(define t1620 #f)
(define t1621 #f)
(define t1622 #f)
(define t1623 #f)
(define t1624 #f)
(define t1625 #f)
(define t1626 #f)
(define t1627 #f)
(define t1628 #f)
(define t1629 #f)
(define t1630 #f)
(define t1631 #f)
(define t1632 #f)
(define t1633 #f)
(define t1634 #f)
(define t1635 #f)
(define t1636 #f)
(define t1637 #f)
(define t1638 #f)
(define t1639 #f)
(define t1640 #f)
(define t1641 #f)
(define t1642 #f)
(define t1643 #f)
(define t1644 #f)
(define t1645 #f)
(define t1646 #f)
(define t1647 #f)
(define t1648 #f)
(define t1649 #f)
(define t1650 #f)
(define t1651 #f)
(define t1652 #f)
(define t1653 #f)
(define t1654 #f)
(define t1655 #f)
(define t1656 #f)
(define t1657 #f)
(define t1658 #f)
(define t1659 #f)
(define t1660 #f)
(define t1661 #f)
(define t1662 #f)
(define t1663 #f)
(define t1664 #f)
(define t1665 #f)
(define t1666 #f)
(define t1667 #f)
(define t1668 #f)
(define t1669 #f)
(define t1670 #f)
(define t1671 #f)
(define t1672 #f)
(define t1673 #f)
(define t1674 #f)
(define t1675 #f)
(define t1676 #f)
(define t1677 #f)
(define t1678 #f)
(define t1679 #f)
(define t1680 #f)
(define t1681 #f)
(define t1682 #f)
(define t1683 #f)
(define t1684 #f)
(define t1685 #f)
(define t1686 #f)
(define t1687 #f)
(define t1688 #f)
(define t1689 #f)
(define t1690 #f)
(define t1691 #f)
(define t1692 #f)
(define t1693 #f)
(define t1694 #f)
(define t1695 #f)
(define t1696 #f)
(define t1697 #f)
(define t1698 #f)
(define t1699 #f)
(define t1700 #f)
(define t1701 #f)
(define t1702 #f)
(define t1703 #f)
(define t1704 #f)
(define t1705 #f)
(define t1706 #f)
(define t1707 #f)
(define t1708 #f)
(define t1709 #f)
(define t1710 #f)
(define t1711 #f)
(define t1712 #f)
(define t1713 #f)
(define t1714 #f)
(define t1715 #f)
(define t1716 #f)
(define t1717 #f)
(define t1718 #f)
(define t1719 #f)
(define t1720 #f)
(define t1721 #f)
(define t1722 #f)
(define t1723 #f)
(define t1724 #f)
(define t1725 #f)
(define t1726 #f)
(define t1727 #f)
(define t1728 #f)
(define t1729 #f)
(define t1730 #f)
(define t1731 #f)
(define t1732 #f)
(define t1733 #f)
(define t1734 #f)
(define t1735 #f)
(define t1736 #f)
(define t1737 #f)
(define t1738 #f)
(define t1739 #f)
(define t1740 #f)
(define t1741 #f)
(define t1742 #f)
(define t1743 #f)
(define t1744 #f)
(define t1745 #f)
(define t1746 #f)
(define t1747 #f)
(define t1748 #f)
(define t1749 #f)
(define t1750 #f)
(define t1751 #f)
(define t1752 #f)
(define t1753 #f)
(define t1754 #f)
(define t1755 #f)
(define t1756 #f)
(define t1757 #f)
(define t1758 #f)
(define t1759 #f)
(define t1760 #f)
(define t1761 #f)
(define t1762 #f)
(define t1763 #f)
(define t1764 #f)
(define t1765 #f)
(define t1766 #f)
(define t1767 #f)
(define t1768 #f)
(define t1769 #f)
(define t1770 #f)
(define t1771 #f)
(define t1772 #f)
(define t1773 #f)
(define t1774 #f)
(define t1775 #f)
(define t1776 #f)
(define t1777 #f)
(define t1778 #f)
(define t1779 #f)
(define t1780 #f)
(define t1781 #f)
(define t1782 #f)
(define t1783 #f)
(define t1784 #f)
(define t1785 #f)
(define t1786 #f)
(define t1787 #f)
(define t1788 #f)
(define t1789 #f)
(define t1790 #f)
(define t1791 #f)
(define t1792 #f)
(define t1793 #f)
(define t1794 #f)
(define t1795 #f)
(define t1796 #f)
(define t1797 #f)
(define t1798 #f)
(define t1799 #f)
(define t1800 #f)
(define t1801 #f)
(define t1802 #f)
(define t1803 #f)
(define t1804 #f)
(define t1805 #f)
(define t1806 #f)
(define t1807 #f)
(define t1808 #f)
(define t1809 #f)
(define t1810 #f)
(define t1811 #f)
(define t1812 #f)
(define t1813 #f)
(define t1814 #f)
(define t1815 #f)
(define t1816 #f)
(define t1817 #f)
(define t1818 #f)
(define t1819 #f)
(define t1820 #f)
(define t1821 #f)
(define t1822 #f)
(define t1823 #f)
(define t1824 #f)
(define t1825 #f)
(define t1826 #f)
(define t1827 #f)
(define t1828 #f)
(define t1829 #f)
(define t1830 #f)
(define t1831 #f)
(define t1832 #f)
(define t1833 #f)
(define t1834 #f)
(define t1835 #f)
(define t1836 #f)
(define t1837 #f)
(define t1838 #f)
(define t1839 #f)
(define t1840 #f)
(define t1841 #f)
(define t1842 #f)
(define t1843 #f)
(define t1844 #f)
(define t1845 #f)
(define t1846 #f)
(define t1847 #f)
(define t1848 #f)
(define t1849 #f)
(define t1850 #f)
(define t1851 #f)
(define t1852 #f)
(define t1853 #f)
(define t1854 #f)
(define t1855 #f)
(define t1856 #f)
(define t1857 #f)
(define t1858 #f)
(define t1859 #f)
(define t1860 #f)
(define t1861 #f)
(define t1862 #f)
(define t1863 #f)
(define t1864 #f)
(define t1865 #f)
(define t1866 #f)
(define t1867 #f)
(define t1868 #f)
(define t1869 #f)
(define t1870 #f)
(define t1871 #f)
(define t1872 #f)
(define t1873 #f)
(define t1874 #f)
(define t1875 #f)
(define t1876 #f)
(define t1877 #f)
(define t1878 #f)
(define t1879 #f)
(define t1880 #f)
(define t1881 #f)
(define t1882 #f)
(define t1883 #f)
(define t1884 #f)
(define t1885 #f)
(define t1886 #f)
(define t1887 #f)
(define t1888 #f)
(define t1889 #f)
(define t1890 #f)
(define t1891 #f)
(define t1892 #f)
(define t1893 #f)
(define t1894 #f)
(define t1895 #f)
(define t1896 #f)
(define t1897 #f)
(define t1898 #f)
(define t1899 #f)
(define t1900 #f)
(define t1901 #f)
(define t1902 #f)
(define t1903 #f)
(define t1904 #f)
(define t1905 #f)
(define t1906 #f)
(define t1907 #f)
(define t1908 #f)
(define t1909 #f)
(define t1910 #f)
(define t1911 #f)
(define t1912 #f)
(define t1913 #f)
(define t1914 #f)
(define t1915 #f)
(define t1916 #f)
(define t1917 #f)
(define t1918 #f)
(define t1919 #f)
(define t1920 #f)
(define t1921 #f)
(define t1922 #f)
(define t1923 #f)
(define t1924 #f)
(define t1925 #f)
(define t1926 #f)
(define t1927 #f)
(define t1928 #f)
(define t1929 #f)
(define t1930 #f)
(define t1931 #f)
(define t1932 #f)
(define t1933 #f)
(define t1934 #f)
(define t1935 #f)
(define t1936 #f)
(define t1937 #f)
(define t1938 #f)
(define t1939 #f)
(define t1940 #f)
(define t1941 #f)
(define t1942 #f)
(define t1943 #f)
(define t1944 #f)
(define t1945 #f)
(define t1946 #f)
(define t1947 #f)
(define t1948 #f)
(define t1949 #f)
(define t1950 #f)
(define t1951 #f)
(define t1952 #f)
(define t1953 #f)
(define t1954 #f)
(define t1955 #f)
(define t1956 #f)
(define t1957 #f)
(define t1958 #f)
(define t1959 #f)
(define t1960 #f)
(define t1961 #f)
(define t1962 #f)
(define t1963 #f)
(define t1964 #f)
(define t1965 #f)
(define t1966 #f)
(define t1967 #f)
(define t1968 #f)
(define t1969 #f)
(define t1970 #f)
(define t1971 #f)
(define t1972 #f)
(define t1973 #f)
(define t1974 #f)
(define t1975 #f)
(define t1976 #f)
(define t1977 #f)
(define t1978 #f)
(define t1979 #f)
(define t1980 #f)
(define t1981 #f)
(define t1982 #f)
(define t1983 #f)
(define t1984 #f)
(define t1985 #f)
(define t1986 #f)
(define t1987 #f)
(define t1988 #f)
(define t1989 #f)
(define t1990 #f)
(define t1991 #f)
(define t1992 #f)
(define t1993 #f)
(define t1994 #f)
(define t1995 #f)
(define t1996 #f)
(define t1997 #f)
(define t1998 #f)
(define t1999 #f)
(define t2000 #f)
(define t2001 #f)
(define t2002 #f)
(define t2003 #f)
(define t2004 #f)
(define t2005 #f)
(define t2006 #f)
(define t2007 #f)
(define t2008 #f)
(define t2009 #f)
(define t2010 #f)
(define t2011 #f)
(define t2012 #f)
(define t2013 #f)
(define t2014 #f)
(define t2015 #f)
(define t2016 #f)
(define t2017 #f)
(define t2018 #f)
(define t2019 #f)
(define t2020 #f)
(define t2021 #f)
(define t2022 #f)
(define t2023 #f)
(define t2024 #f)
(define t2025 #f)
(define t2026 #f)
(define t2027 #f)
(define t2028 #f)
(define t2029 #f)
(define t2030 #f)
(define t2031 #f)
(define t2032 #f)
(define t2033 #f)
(define t2034 #f)
(define t2035 #f)
(define t2036 #f)
(define t2037 #f)
(define t2038 #f)
(define t2039 #f)
(define t2040 #f)
(define t2041 #f)
(define t2042 #f)
(define t2043 #f)
(define t2044 #f)
(define t2045 #f)
(define t2046 #f)
(define t2047 #f)
(define t2048 #f)
(define t2049 #f)
(define t2050 #f)
(define t2051 #f)
(define t2052 #f)
(define t2053 #f)
(define t2054 #f)
(define t2055 #f)
(define t2056 #f)
(define t2057 #f)
(define t2058 #f)
(define t2059 #f)
(define t2060 #f)
(define t2061 #f)
(define t2062 #f)
(define t2063 #f)
(define t2064 #f)
(define t2065 #f)
(define t2066 #f)
(define t2067 #f)
(define t2068 #f)
(define t2069 #f)
(define t2070 #f)
(define t2071 #f)
(define t2072 #f)
(define t2073 #f)
(define t2074 #f)
(define t2075 #f)
(define t2076 #f)
(define t2077 #f)
(define t2078 #f)
(define t2079 #f)
(define t2080 #f)
(define t2081 #f)
(define t2082 #f)
(define t2083 #f)
(define t2084 #f)
(define t2085 #f)
(define t2086 #f)
(define t2087 #f)
(define t2088 #f)
(define t2089 #f)
(define t2090 #f)
(define t2091 #f)
(define t2092 #f)
(define t2093 #f)
(define t2094 #f)
(define t2095 #f)
(define t2096 #f)
(define t2097 #f)
(define t2098 #f)
(define t2099 #f)
(define t2100 #f)
(define t2101 #f)
(define t2102 #f)
(define t2103 #f)
(define t2104 #f)
(define t2105 #f)
(define t2106 #f)
(define t2107 #f)
(define t2108 #f)
(define t2109 #f)
(define t2110 #f)
(define t2111 #f)
(define t2112 #f)
(define t2113 #f)
(define t2114 #f)
(define t2115 #f)
(define t2116 #f)
(define t2117 #f)
(define t2118 #f)
(define t2119 #f)
(define t2120 #f)
(define t2121 #f)
(define t2122 #f)
(define t2123 #f)
(define t2124 #f)
(define t2125 #f)
(define t2126 #f)
(define t2127 #f)
(define t2128 #f)
(define t2129 #f)
(define t2130 #f)
(define t2131 #f)
(define t2132 #f)
(define t2133 #f)
(define t2134 #f)
(define t2135 #f)
(define t2136 #f)
(define t2137 #f)
(define t2138 #f)
(define t2139 #f)
(define t2140 #f)
(define t2141 #f)
(define t2142 #f)
(define t2143 #f)
(define t2144 #f)
(define t2145 #f)
(define t2146 #f)
(define t2147 #f)
(define t2148 #f)
(define t2149 #f)
(define t2150 #f)
(define t2151 #f)
(define t2152 #f)
(define t2153 #f)
(define t2154 #f)
(define t2155 #f)
(define t2156 #f)
(define t2157 #f)
(define t2158 #f)
(define t2159 #f)
(define t2160 #f)
(define t2161 #f)
(define t2162 #f)
(define t2163 #f)
(define t2164 #f)
(define t2165 #f)
(define t2166 #f)
(define t2167 #f)
(define t2168 #f)
(define t2169 #f)
(define t2170 #f)
(define t2171 #f)
(define t2172 #f)
(define t2173 #f)
(define t2174 #f)
(define t2175 #f)
(define t2176 #f)
(define t2177 #f)
(define t2178 #f)
(define t2179 #f)
(define t2180 #f)
(define t2181 #f)
(define t2182 #f)
(define t2183 #f)
(define t2184 #f)
(define t2185 #f)
(define t2186 #f)
(define t2187 #f)
(define t2188 #f)
(define t2189 #f)
(define t2190 #f)
(define t2191 #f)
(define t2192 #f)
(define t2193 #f)
(define t2194 #f)
(define t2195 #f)
(define t2196 #f)
(define t2197 #f)
(define t2198 #f)
(define t2199 #f)
(define t2200 #f)
(define t2201 #f)
(define t2202 #f)
(define t2203 #f)
(define t2204 #f)
(define t2205 #f)
(define t2206 #f)
(define t2207 #f)
(define t2208 #f)
(define t2209 #f)
(define t2210 #f)
(define t2211 #f)
(define t2212 #f)
(define t2213 #f)
(define t2214 #f)
(define t2215 #f)
(define t2216 #f)
(define t2217 #f)
(define t2218 #f)
(define t2219 #f)
(define t2220 #f)
(define t2221 #f)
(define t2222 #f)
(define t2223 #f)
(define t2224 #f)
(define t2225 #f)
(define t2226 #f)
(define t2227 #f)
(define t2228 #f)
(define t2229 #f)
(define t2230 #f)
(define t2231 #f)
(define t2232 #f)
(define t2233 #f)
(define t2234 #f)
(define t2235 #f)
(define t2236 #f)
(define t2237 #f)
(define t2238 #f)
(define t2239 #f)
(define t2240 #f)
(define t2241 #f)
(define t2242 #f)
(define t2243 #f)
(define t2244 #f)
(define t2245 #f)
(define t2246 #f)
(define t2247 #f)
(define t2248 #f)
(define t2249 #f)
(define t2250 #f)
(define t2251 #f)
(define t2252 #f)
(define t2253 #f)
(define t2254 #f)
(define t2255 #f)
(define t2256 #f)
(define t2257 #f)
(define t2258 #f)
(define t2259 #f)
(define t2260 #f)
(define t2261 #f)
(define t2262 #f)
(define t2263 #f)
(define t2264 #f)
(define t2265 #f)
(define t2266 #f)
(define t2267 #f)
(define t2268 #f)
(define t2269 #f)
(define t2270 #f)
(define t2271 #f)
(define t2272 #f)
(define t2273 #f)
(define t2274 #f)
(define t2275 #f)
(define t2276 #f)
(define t2277 #f)
(define t2278 #f)
(define t2279 #f)
(define t2280 #f)
(define t2281 #f)
(define t2282 #f)
(define t2283 #f)
(define t2284 #f)
(define t2285 #f)
(define t2286 #f)
(define t2287 #f)
(define t2288 #f)
(define t2289 #f)
(define t2290 #f)
(define t2291 #f)
(define t2292 #f)
(define t2293 #f)
(define t2294 #f)
(define t2295 #f)
(define t2296 #f)
(define t2297 #f)
(define t2298 #f)
(define t2299 #f)
(define t2300 #f)
(define t2301 #f)
(define t2302 #f)
(define t2303 #f)
(define t2304 #f)
(define t2305 #f)
(define t2306 #f)
(define t2307 #f)
(define t2308 #f)
(define t2309 #f)
(define t2310 #f)
(define t2311 #f)
(define t2312 #f)
(define t2313 #f)
(define t2314 #f)
(define t2315 #f)
(define t2316 #f)
(define t2317 #f)
(define t2318 #f)
(define t2319 #f)
(define t2320 #f)
(define t2321 #f)
(define t2322 #f)
(define t2323 #f)
(define t2324 #f)
(define t2325 #f)
(define t2326 #f)
(define t2327 #f)
(define t2328 #f)
(define t2329 #f)
(define t2330 #f)
(define t2331 #f)
(define t2332 #f)
(define t2333 #f)
(define t2334 #f)
(define t2335 #f)
(define t2336 #f)
(define t2337 #f)
(define t2338 #f)
(define t2339 #f)
(define t2340 #f)
(define t2341 #f)
(define t2342 #f)
(define t2343 #f)
(define t2344 #f)
(define t2345 #f)
(define t2346 #f)
(define t2347 #f)
(define t2348 #f)
(define t2349 #f)
(define t2350 #f)
(define t2351 #f)
(define t2352 #f)
(define t2353 #f)
(define t2354 #f)
(define t2355 #f)
(define t2356 #f)
(define t2357 #f)
(define t2358 #f)
(define t2359 #f)
(define t2360 #f)
(define t2361 #f)
(define t2362 #f)
(define t2363 #f)
(define t2364 #f)
(define t2365 #f)
(define t2366 #f)
(define t2367 #f)
(define t2368 #f)
(define t2369 #f)
(define t2370 #f)
(define t2371 #f)
(define t2372 #f)
(define t2373 #f)
(define t2374 #f)
(define t2375 #f)
(define t2376 #f)
(define t2377 #f)
(define t2378 #f)
(define t2379 #f)
(define t2380 #f)
(define t2381 #f)
(define t2382 #f)
(define t2383 #f)
(define t2384 #f)
(define t2385 #f)
(define t2386 #f)
(define t2387 #f)
(define t2388 #f)
(define t2389 #f)
(define t2390 #f)
(define t2391 #f)
(define t2392 #f)
(define t2393 #f)
(define t2394 #f)
(define t2395 #f)
(define t2396 #f)
(define t2397 #f)
(define t2398 #f)
(define t2399 #f)
(define t2400 #f)
(define t2401 #f)
(define t2402 #f)
(define t2403 #f)
(define t2404 #f)
(define t2405 #f)
(define t2406 #f)
(define t2407 #f)
(define t2408 #f)
(define t2409 #f)
(define t2410 #f)
(define t2411 #f)
(define t2412 #f)
(define t2413 #f)
(define t2414 #f)
(define t2415 #f)
(define t2416 #f)
(define t2417 #f)
(define t2418 #f)
(define t2419 #f)
(define t2420 #f)
(define t2421 #f)
(define t2422 #f)
(define t2423 #f)
(define t2424 #f)
(define t2425 #f)
(define t2426 #f)
(define t2427 #f)
(define t2428 #f)
(define t2429 #f)
(define t2430 #f)
(define t2431 #f)
(define t2432 #f)
(define t2433 #f)
(define t2434 #f)
(define t2435 #f)
(define t2436 #f)
(define t2437 #f)
(define t2438 #f)
(define t2439 #f)
(define t2440 #f)
(define t2441 #f)
(define t2442 #f)
(define t2443 #f)
(define t2444 #f)
(define t2445 #f)
(define t2446 #f)
(define t2447 #f)
(define t2448 #f)
(define t2449 #f)
(define t2450 #f)
(define t2451 #f)
(define t2452 #f)
(define t2453 #f)
(define t2454 #f)
(define t2455 #f)
(define t2456 #f)
(define t2457 #f)
(define t2458 #f)
(define t2459 #f)
(define t2460 #f)
(define t2461 #f)
(define t2462 #f)
(define t2463 #f)
(define t2464 #f)
(define t2465 #f)
(define t2466 #f)
(define t2467 #f)
(define t2468 #f)
(define t2469 #f)
(define t2470 #f)
(define t2471 #f)
(define t2472 #f)
(define t2473 #f)
(define t2474 #f)
(define t2475 #f)
(define t2476 #f)
(define t2477 #f)
(define t2478 #f)
(define t2479 #f)
(define t2480 #f)
(define t2481 #f)
(define t2482 #f)
(define t2483 #f)
(define t2484 #f)
(define t2485 #f)
(define t2486 #f)
(define t2487 #f)
(define t2488 #f)
(define t2489 #f)
(define t2490 #f)
(define t2491 #f)
(define t2492 #f)
(define t2493 #f)
(define t2494 #f)
(define t2495 #f)
(define t2496 #f)
(define t2497 #f)
(define t2498 #f)
(define t2499 #f)
(define t2500 #f)
(define t2501 #f)
(define t2502 #f)
(define t2503 #f)
(define t2504 #f)
(define t2505 #f)
(define t2506 #f)
(define t2507 #f)
(define t2508 #f)
(define t2509 #f)
(define t2510 #f)
(define t2511 #f)
(define t2512 #f)
(define t2513 #f)
(define t2514 #f)
(define t2515 #f)
(define t2516 #f)
(define t2517 #f)
(define t2518 #f)
(define t2519 #f)
(define t2520 #f)
(define t2521 #f)
(define t2522 #f)
(define t2523 #f)
(define t2524 #f)
(define t2525 #f)
(define t2526 #f)
(define t2527 #f)
(define t2528 #f)
(define t2529 #f)
(define t2530 #f)
(define t2531 #f)
(define t2532 #f)
(define t2533 #f)
(define t2534 #f)
(define t2535 #f)
(define t2536 #f)
(define t2537 #f)
(define t2538 #f)
(define t2539 #f)
(define t2540 #f)
(define t2541 #f)
(define t2542 #f)
(define t2543 #f)
(define t2544 #f)
(define t2545 #f)
(define t2546 #f)
(define t2547 #f)
(define t2548 #f)
(define t2549 #f)
(define t2550 #f)
(define t2551 #f)
(define t2552 #f)
(define t2553 #f)
(define t2554 #f)
(define t2555 #f)
(define t2556 #f)
(define t2557 #f)
(define t2558 #f)
(define t2559 #f)
(define t2560 #f)
(define t2561 #f)
(define t2562 #f)
(define t2563 #f)
(define t2564 #f)
(define t2565 #f)
(define t2566 #f)
(define t2567 #f)
(define t2568 #f)
(define t2569 #f)
(define t2570 #f)
(define t2571 #f)
(define t2572 #f)
(define t2573 #f)
(define t2574 #f)
(define t2575 #f)
(define t2576 #f)
(define t2577 #f)
(define t2578 #f)
(define t2579 #f)
(define t2580 #f)
(define t2581 #f)
(define t2582 #f)
(define t2583 #f)
(define t2584 #f)
(define t2585 #f)
(define t2586 #f)
(define t2587 #f)
(define t2588 #f)
(define t2589 #f)
(define t2590 #f)
(define t2591 #f)
(define t2592 #f)
(define t2593 #f)
(define t2594 #f)
(define t2595 #f)
(define t2596 #f)
(define t2597 #f)
(define t2598 #f)
(define t2599 #f)
(define t2600 #f)
(define t2601 #f)
(define t2602 #f)
(define t2603 #f)
(define t2604 #f)
(define t2605 #f)
(define t2606 #f)
(define t2607 #f)
(define t2608 #f)
(define t2609 #f)
(define t2610 #f)
(define t2611 #f)
(define t2612 #f)
(define t2613 #f)
(define t2614 #f)
(define t2615 #f)
(define t2616 #f)
(define t2617 #f)
(define t2618 #f)
(define t2619 #f)
(define t2620 #f)
(define t2621 #f)
(define t2622 #f)
(define t2623 #f)
(define t2624 #f)
(define t2625 #f)
(define t2626 #f)
(define t2627 #f)
(define t2628 #f)
(define t2629 #f)
(define t2630 #f)
(define t2631 #f)
(define t2632 #f)
(define t2633 #f)
(define t2634 #f)
(define t2635 #f)
(define t2636 #f)
(define t2637 #f)
(define t2638 #f)
(define t2639 #f)
(define t2640 #f)
(define t2641 #f)
(define t2642 #f)
(define t2643 #f)
(define t2644 #f)
(define t2645 #f)
(define t2646 #f)
(define t2647 #f)
(define t2648 #f)
(define t2649 #f)
(define t2650 #f)
(define t2651 #f)
(define t2652 #f)
(define t2653 #f)
(define t2654 #f)
(define t2655 #f)
(define t2656 #f)
(define t2657 #f)
(define t2658 #f)
(define t2659 #f)
(define t2660 #f)
(define t2661 #f)
(define t2662 #f)
(define t2663 #f)
(define t2664 #f)
(define t2665 #f)
(define t2666 #f)
(define t2667 #f)
(define t2668 #f)
(define t2669 #f)
(define t2670 #f)
(define t2671 #f)
(define t2672 #f)
(define t2673 #f)
(define t2674 #f)
(define t2675 #f)
(define t2676 #f)
(define t2677 #f)
(define t2678 #f)
(define t2679 #f)
(define t2680 #f)
(define t2681 #f)
(define t2682 #f)
(define t2683 #f)
(define t2684 #f)
(define t2685 #f)
(define t2686 #f)
(define t2687 #f)
(define t2688 #f)
(define t2689 #f)
(define t2690 #f)
(define t2691 #f)
(define t2692 #f)
(define t2693 #f)
(define t2694 #f)
(define t2695 #f)
(define t2696 #f)
(define t2697 #f)
(define t2698 #f)
(define t2699 #f)
(define t2700 #f)
(define t2701 #f)
(define t2702 #f)
(define t2703 #f)
(define t2704 #f)
(define t2705 #f)
(define t2706 #f)
(define t2707 #f)
(define t2708 #f)
(define t2709 #f)
(define t2710 #f)
(define t2711 #f)
(define t2712 #f)
(define t2713 #f)
(define t2714 #f)
(define t2715 #f)
(define t2716 #f)
(define t2717 #f)
(define t2718 #f)
(define t2719 #f)
(define t2720 #f)
(define t2721 #f)
(define t2722 #f)
(define t2723 #f)
(define t2724 #f)
(define t2725 #f)
(define t2726 #f)
(define t2727 #f)
(define t2728 #f)
(define t2729 #f)
(define t2730 #f)
(define t2731 #f)
(define t2732 #f)
(define t2733 #f)
(define t2734 #f)
(define t2735 #f)
(define t2736 #f)
(define t2737 #f)
(define t2738 #f)
(define t2739 #f)
(define t2740 #f)
(define t2741 #f)
(define t2742 #f)
(define t2743 #f)
(define t2744 #f)
(define t2745 #f)
(define t2746 #f)
(define t2747 #f)
(define t2748 #f)
(define t2749 #f)
(define t2750 #f)
(define t2751 #f)
(define t2752 #f)
(define t2753 #f)
(define t2754 #f)
(define t2755 #f)
(define t2756 #f)
(define t2757 #f)
(define t2758 #f)
(define t2759 #f)
(define t2760 #f)
(define t2761 #f)
(define t2762 #f)
(define t2763 #f)
(define t2764 #f)
(define t2765 #f)
(define t2766 #f)
(define t2767 #f)
(define t2768 #f)
(define t2769 #f)
(define t2770 #f)
(define t2771 #f)
(define t2772 #f)
(define t2773 #f)
(define t2774 #f)
(define t2775 #f)
(define t2776 #f)
(define t2777 #f)
(define t2778 #f)
(define t2779 #f)
(define t2780 #f)
(define t2781 #f)
(define t2782 #f)
(define t2783 #f)
(define t2784 #f)
(define t2785 #f)
(define t2786 #f)
(define t2787 #f)
(define t2788 #f)
(define t2789 #f)
(define t2790 #f)
(define t2791 #f)
(define t2792 #f)
(define t2793 #f)
(define t2794 #f)
(define t2795 #f)
(define t2796 #f)
(define t2797 #f)
(define t2798 #f)
(define t2799 #f)
(define t2800 #f)
(define t2801 #f)
(define t2802 #f)
(define t2803 #f)
(define t2804 #f)
(define t2805 #f)
(define t2806 #f)
(define t2807 #f)
(define t2808 #f)
(define t2809 #f)
(define t2810 #f)
(define t2811 #f)
(define t2812 #f)
(define t2813 #f)
(define t2814 #f)
(define t2815 #f)
(define t2816 #f)
(define t2817 #f)
(define t2818 #f)
(define t2819 #f)
(define t2820 #f)
(define t2821 #f)
(define t2822 #f)
(define t2823 #f)
(define t2824 #f)
(define t2825 #f)
(define t2826 #f)
(define t2827 #f)
(define t2828 #f)
(define t2829 #f)
(define t2830 #f)
(define t2831 #f)
(define t2832 #f)
(define t2833 #f)
(define t2834 #f)
(define t2835 #f)
(define t2836 #f)
(define t2837 #f)
(define t2838 #f)
(define t2839 #f)
(define t2840 #f)
(define t2841 #f)
(define t2842 #f)
(define t2843 #f)
(define t2844 #f)
(define t2845 #f)
(define t2846 #f)
(define t2847 #f)
(define t2848 #f)
(define t2849 #f)
(define t2850 #f)
(define t2851 #f)
(define t2852 #f)
(define t2853 #f)
(define t2854 #f)
(define t2855 #f)
(define t2856 #f)
(define t2857 #f)
(define t2858 #f)
(define t2859 #f)
(define t2860 #f)
(define t2861 #f)
(define t2862 #f)
(define t2863 #f)
(define t2864 #f)
(define t2865 #f)
(define t2866 #f)
(define t2867 #f)
(define t2868 #f)
(define t2869 #f)
(define t2870 #f)
(define t2871 #f)
(define t2872 #f)
(define t2873 #f)
(define t2874 #f)
(define t2875 #f)
(define t2876 #f)
(define t2877 #f)
(define t2878 #f)
(define t2879 #f)
(define t2880 #f)
(define t2881 #f)
(define t2882 #f)
(define t2883 #f)
(define t2884 #f)
(define t2885 #f)
(define t2886 #f)
(define t2887 #f)
(define t2888 #f)
(define t2889 #f)
(define t2890 #f)
(define t2891 #f)
(define t2892 #f)
(define t2893 #f)
(define t2894 #f)
(define t2895 #f)
(define t2896 #f)
(define t2897 #f)
(define t2898 #f)
(define t2899 #f)
(define t2900 #f)
(define t2901 #f)
(define t2902 #f)
(define t2903 #f)
(define t2904 #f)
(define t2905 #f)
(define t2906 #f)
(define t2907 #f)
(define t2908 #f)
(define t2909 #f)
(define t2910 #f)
(define t2911 #f)
(define t2912 #f)
(define t2913 #f)
(define t2914 #f)
(define t2915 #f)
(define t2916 #f)
(define t2917 #f)
(define t2918 #f)
(define t2919 #f)
(define t2920 #f)
(define t2921 #f)
(define t2922 #f)
(define t2923 #f)
(define t2924 #f)
(define t2925 #f)
(define t2926 #f)
(define t2927 #f)
(define t2928 #f)
(define t2929 #f)
(define t2930 #f)
(define t2931 #f)
(define t2932 #f)
(define t2933 #f)
(define t2934 #f)
(define t2935 #f)
(define t2936 #f)
(define t2937 #f)
(define t2938 #f)
(define t2939 #f)
(define t2940 #f)
(define t2941 #f)
(define t2942 #f)
(define t2943 #f)
(define t2944 #f)
(define t2945 #f)
(define t2946 #f)
(define t2947 #f)
(define t2948 #f)
(define t2949 #f)
(define t2950 #f)
(define t2951 #f)
(define t2952 #f)
(define t2953 #f)
(define t2954 #f)
(define t2955 #f)
(define t2956 #f)
(define t2957 #f)
(define t2958 #f)
(define t2959 #f)
(define t2960 #f)
(define t2961 #f)
(define t2962 #f)
(define t2963 #f)
(define t2964 #f)
(define t2965 #f)
(define t2966 #f)
(define t2967 #f)
(define t2968 #f)
(define t2969 #f)
(define t2970 #f)
(define t2971 #f)
(define t2972 #f)
(define t2973 #f)
(define t2974 #f)
(define t2975 #f)
(define t2976 #f)
(define t2977 #f)
(define t2978 #f)
(define t2979 #f)
(define t2980 #f)
(define t2981 #f)
(define t2982 #f)
(define t2983 #f)
(define t2984 #f)
(define t2985 #f)
(define t2986 #f)
(define t2987 #f)
(define t2988 #f)
(define t2989 #f)
(define t2990 #f)
(define t2991 #f)
(define t2992 #f)
(define t2993 #f)
(define t2994 #f)
(define t2995 #f)
(define t2996 #f)
(define t2997 #f)
(define t2998 #f)
(define t2999 #f)
(define t3000 #f)
(define t3001 #f)
(define t3002 #f)
(define t3003 #f)
(define t3004 #f)
(define t3005 #f)
(define t3006 #f)
(define t3007 #f)
(define t3008 #f)
(define t3009 #f)
(define t3010 #f)
(define t3011 #f)
(define t3012 #f)
(define t3013 #f)
(define t3014 #f)
(define t3015 #f)
(define t3016 #f)
(define t3017 #f)
(define t3018 #f)
(define t3019 #f)
(define t3020 #f)
(define t3021 #f)
(define t3022 #f)
(define t3023 #f)
(define t3024 #f)
(define t3025 #f)
(define t3026 #f)
(define t3027 #f)
(define t3028 #f)
(define t3029 #f)
(define t3030 #f)
(define t3031 #f)
(define t3032 #f)
(define t3033 #f)
(define t3034 #f)
(define t3035 #f)
(define t3036 #f)
(define t3037 #f)
(define t3038 #f)
(define t3039 #f)
(define t3040 #f)
(define t3041 #f)
(define t3042 #f)
(define t3043 #f)
(define t3044 #f)
(define t3045 #f)
(define t3046 #f)
(define t3047 #f)
(define t3048 #f)
(define t3049 #f)
(define t3050 #f)
(define t3051 #f)
(define t3052 #f)
(define t3053 #f)
(define t3054 #f)
(define t3055 #f)
(define t3056 #f)
(define t3057 #f)
(define t3058 #f)
(define t3059 #f)
(define t3060 #f)
(define t3061 #f)
(define t3062 #f)
(define t3063 #f)
(define t3064 #f)
(define t3065 #f)
(define t3066 #f)
(define t3067 #f)
(define t3068 #f)
(define t3069 #f)
(define t3070 #f)
(define t3071 #f)
(define t3072 #f)
(define t3073 #f)
(define t3074 #f)
(define t3075 #f)
(define t3076 #f)
(define t3077 #f)
(define t3078 #f)
(define t3079 #f)
(define t3080 #f)
(define t3081 #f)
(define t3082 #f)
(define t3083 #f)
(define t3084 #f)
(define t3085 #f)
(define t3086 #f)
(define t3087 #f)
(define t3088 #f)
(define t3089 #f)
(define t3090 #f)
(define t3091 #f)
(define t3092 #f)
(define t3093 #f)
(define t3094 #f)
(define t3095 #f)
(define t3096 #f)
(define t3097 #f)
(define t3098 #f)
(define t3099 #f)
(define t3100 #f)
(define t3101 #f)
(define t3102 #f)
(define t3103 #f)
(define t3104 #f)
(define t3105 #f)
(define t3106 #f)
(define t3107 #f)
(define t3108 #f)
(define t3109 #f)
(define t3110 #f)
(define t3111 #f)
(define t3112 #f)
(define t3113 #f)
(define t3114 #f)
(define t3115 #f)
(define t3116 #f)
(define t3117 #f)
(define t3118 #f)
(define t3119 #f)
(define t3120 #f)
(define t3121 #f)
(define t3122 #f)
(define t3123 #f)
(define t3124 #f)
(define t3125 #f)
(define t3126 #f)
(define t3127 #f)
(define t3128 #f)
(define t3129 #f)
(define t3130 #f)
(define t3131 #f)
(define t3132 #f)
(define t3133 #f)
(define t3134 #f)
(define t3135 #f)
(define t3136 #f)
(define t3137 #f)
(define t3138 #f)
(define t3139 #f)
(define t3140 #f)
(define t3141 #f)
(define t3142 #f)
(define t3143 #f)
(define t3144 #f)
(define t3145 #f)
(define t3146 #f)
(define t3147 #f)
(define t3148 #f)
(define t3149 #f)
(define t3150 #f)
(define t3151 #f)
(define t3152 #f)
(define t3153 #f)
(define t3154 #f)
(define t3155 #f)
(define t3156 #f)
(define t3157 #f)
(define t3158 #f)
(define t3159 #f)
(define t3160 #f)
(define t3161 #f)
(define t3162 #f)
(define t3163 #f)
(define t3164 #f)
(define t3165 #f)
(define t3166 #f)
(define t3167 #f)
(define t3168 #f)
(define t3169 #f)
(define t3170 #f)
(define t3171 #f)
(define t3172 #f)
(define t3173 #f)
(define t3174 #f)
(define t3175 #f)
(define t3176 #f)
(define t3177 #f)
(define t3178 #f)
(define t3179 #f)
(define t3180 #f)
(define t3181 #f)
(define t3182 #f)
(define t3183 #f)
(define t3184 #f)
(define t3185 #f)
(define t3186 #f)
(define t3187 #f)
(define t3188 #f)
(define t3189 #f)
(define t3190 #f)
(define t3191 #f)
(define t3192 #f)
(define t3193 #f)
(define t3194 #f)
(define t3195 #f)
(define t3196 #f)
(define t3197 #f)
(define t3198 #f)
(define t3199 #f)
(define t3200 #f)
(define t3201 #f)
(define t3202 #f)
(define t3203 #f)
(define t3204 #f)
(define t3205 #f)
(define t3206 #f)
(define t3207 #f)
(define t3208 #f)
(define t3209 #f)
(define t3210 #f)
(define t3211 #f)
(define t3212 #f)
(define t3213 #f)
(define t3214 #f)
(define t3215 #f)
(define t3216 #f)
(define t3217 #f)
(define t3218 #f)
(define t3219 #f)
(define t3220 #f)
(define t3221 #f)
(define t3222 #f)
(define t3223 #f)
(define t3224 #f)
(define t3225 #f)
(define t3226 #f)
(define t3227 #f)
(define t3228 #f)
(define t3229 #f)
(define t3230 #f)
(define t3231 #f)
(define t3232 #f)
(define t3233 #f)
(define t3234 #f)
(define t3235 #f)
(define t3236 #f)
(define t3237 #f)
(define t3238 #f)
(define t3239 #f)
(define t3240 #f)
(define t3241 #f)
(define t3242 #f)
(define t3243 #f)
(define t3244 #f)
(define t3245 #f)
(define t3246 #f)
(define t3247 #f)
(define t3248 #f)
(define t3249 #f)
(define t3250 #f)
(define t3251 #f)
(define t3252 #f)
(define t3253 #f)
(define t3254 #f)
(define t3255 #f)
(define t3256 #f)
(define t3257 #f)
(define t3258 #f)
(define t3259 #f)
(define t3260 #f)
(define t3261 #f)
(define t3262 #f)
(define t3263 #f)
(define t3264 #f)
(define t3265 #f)
(define t3266 #f)
(define t3267 #f)
(define t3268 #f)
(define t3269 #f)
(define t3270 #f)
(define t3271 #f)
(define t3272 #f)
(define t3273 #f)
(define t3274 #f)
(define t3275 #f)
(define t3276 #f)
(define t3277 #f)
(define t3278 #f)
(define t3279 #f)
(define t3280 #f)
(define t3281 #f)
(define t3282 #f)
(define t3283 #f)
(define t3284 #f)
(define t3285 #f)
(define t3286 #f)
(define t3287 #f)
(define t3288 #f)
(define t3289 #f)
(define t3290 #f)
(define t3291 #f)
(define t3292 #f)
(define t3293 #f)
(define t3294 #f)
(define t3295 #f)
(define t3296 #f)
(define t3297 #f)
(define t3298 #f)
(define t3299 #f)
(define t3300 #f)
(define t3301 #f)
(define t3302 #f)
(define t3303 #f)
(define t3304 #f)
(define t3305 #f)
(define t3306 #f)
(define t3307 #f)
(define t3308 #f)
(define t3309 #f)
(define t3310 #f)
(define t3311 #f)
(define t3312 #f)
(define t3313 #f)
(define t3314 #f)
(define t3315 #f)
(define t3316 #f)
(define t3317 #f)
(define t3318 #f)
(define t3319 #f)
(define t3320 #f)
(define t3321 #f)
(define t3322 #f)
(define t3323 #f)
(define t3324 #f)
(define t3325 #f)
(define t3326 #f)
(define t3327 #f)
(define t3328 #f)
(define t3329 #f)
(define t3330 #f)
(define t3331 #f)
(define t3332 #f)
(define t3333 #f)
(define t3334 #f)
(define t3335 #f)
(define t3336 #f)
(define t3337 #f)
(define t3338 #f)
(define t3339 #f)
(define t3340 #f)
(define t3341 #f)
(define t3342 #f)
(define t3343 #f)
(define t3344 #f)
(define t3345 #f)
(define t3346 #f)
(define t3347 #f)
(define t3348 #f)
(define t3349 #f)
(define t3350 #f)
(define t3351 #f)
(define t3352 #f)
(define t3353 #f)
(define t3354 #f)
(define t3355 #f)
(define t3356 #f)
(define t3357 #f)
(define t3358 #f)
(define t3359 #f)
(define t3360 #f)
(define t3361 #f)
(define t3362 #f)
(define t3363 #f)
(define t3364 #f)
(define t3365 #f)
(define t3366 #f)
(define t3367 #f)
(define t3368 #f)
(define t3369 #f)
(define t3370 #f)
(define t3371 #f)
(define t3372 #f)
(define t3373 #f)
(define t3374 #f)
(define t3375 #f)
(define t3376 #f)
(define t3377 #f)
(define t3378 #f)
(define t3379 #f)
(define t3380 #f)
(define t3381 #f)
(define t3382 #f)
(define t3383 #f)
(define t3384 #f)
(define t3385 #f)
(define t3386 #f)
(define t3387 #f)
(define t3388 #f)
(define t3389 #f)
(define t3390 #f)
(define t3391 #f)
(define t3392 #f)
(define t3393 #f)
(define t3394 #f)
(define t3395 #f)
(define t3396 #f)
(define t3397 #f)
(define t3398 #f)
(define t3399 #f)
(define t3400 #f)
(define t3401 #f)
(define t3402 #f)
(define t3403 #f)
(define t3404 #f)
(define t3405 #f)
(define t3406 #f)
(define t3407 #f)
(define t3408 #f)
(define t3409 #f)
(define t3410 #f)
(define t3411 #f)
(define t3412 #f)
(define t3413 #f)
(define t3414 #f)
(define t3415 #f)
(define t3416 #f)
(define t3417 #f)
(define t3418 #f)
(define t3419 #f)
(define t3420 #f)
(define t3421 #f)
(define t3422 #f)
(define t3423 #f)
(define t3424 #f)
(define t3425 #f)
(define t3426 #f)
(define t3427 #f)
(define t3428 #f)
(define t3429 #f)
(define t3430 #f)
(define t3431 #f)
(define t3432 #f)
(define t3433 #f)
(define t3434 #f)
(define t3435 #f)
(define t3436 #f)
(define t3437 #f)
(define t3438 #f)
(define t3439 #f)
(define t3440 #f)
(define t3441 #f)
(define t3442 #f)
(define t3443 #f)
(define t3444 #f)
(define t3445 #f)
(define t3446 #f)
(define t3447 #f)
(define t3448 #f)
(define t3449 #f)
(define t3450 #f)
(define t3451 #f)
(define t3452 #f)
(define t3453 #f)
(define t3454 #f)
(define t3455 #f)
(define t3456 #f)
(define t3457 #f)
(define t3458 #f)
(define t3459 #f)
(define t3460 #f)
(define t3461 #f)
(define t3462 #f)
(define t3463 #f)
(define t3464 #f)
(define t3465 #f)
(define t3466 #f)
(define t3467 #f)
(define t3468 #f)
(define t3469 #f)
(define t3470 #f)
(define t3471 #f)
(define t3472 #f)
(define t3473 #f)
(define t3474 #f)
(define t3475 #f)
(define t3476 #f)
(define t3477 #f)
(define t3478 #f)
(define t3479 #f)
(define t3480 #f)
(define t3481 #f)
(define t3482 #f)
(define t3483 #f)
(define t3484 #f)
(define t3485 #f)
(define t3486 #f)
(define t3487 #f)
(define t3488 #f)
(define t3489 #f)
(define t3490 #f)
(define t3491 #f)
(define t3492 #f)
(define t3493 #f)
(define t3494 #f)
(define t3495 #f)
(define t3496 #f)
(define t3497 #f)
(define t3498 #f)
(define t3499 #f)
(define t3500 #f)
(define t3501 #f)
(define t3502 #f)
(define t3503 #f)
(define t3504 #f)
(define t3505 #f)
(define t3506 #f)
(define t3507 #f)
(define t3508 #f)
(define t3509 #f)
(define t3510 #f)
(define t3511 #f)
(define t3512 #f)
(define t3513 #f)
(define t3514 #f)
(define t3515 #f)
(define t3516 #f)
(define t3517 #f)
(define t3518 #f)
(define t3519 #f)
(define t3520 #f)
(define t3521 #f)
(define t3522 #f)
(define t3523 #f)
(define t3524 #f)
(define t3525 #f)
(define t3526 #f)
(define t3527 #f)
(define t3528 #f)
(define t3529 #f)
(define t3530 #f)
(define t3531 #f)
(define t3532 #f)
(define t3533 #f)
(define t3534 #f)
(define t3535 #f)
(define t3536 #f)
(define t3537 #f)
(define t3538 #f)
(define t3539 #f)
(define t3540 #f)
(define t3541 #f)
(define t3542 #f)
(define t3543 #f)
(define t3544 #f)
(define t3545 #f)
(define t3546 #f)
(define t3547 #f)
(define t3548 #f)
(define t3549 #f)
(define t3550 #f)
(define t3551 #f)
(define t3552 #f)
(define t3553 #f)
(define t3554 #f)
(define t3555 #f)
(define t3556 #f)
(define t3557 #f)
(define t3558 #f)
(define t3559 #f)
(define t3560 #f)
(define t3561 #f)
(define t3562 #f)
(define t3563 #f)
(define t3564 #f)
(define t3565 #f)
(define t3566 #f)
(define t3567 #f)
(define t3568 #f)
(define t3569 #f)
(define t3570 #f)
(define t3571 #f)
(define t3572 #f)
(define t3573 #f)
(define t3574 #f)
(define t3575 #f)
(define t3576 #f)
(define t3577 #f)
(define t3578 #f)
(define t3579 #f)
(define t3580 #f)
(define t3581 #f)
(define t3582 #f)
(define t3583 #f)
(define t3584 #f)
(define t3585 #f)
(define t3586 #f)
(define t3587 #f)
(define t3588 #f)
(define t3589 #f)
(define t3590 #f)
(define t3591 #f)
(define t3592 #f)
(define t3593 #f)
(define t3594 #f)
(define t3595 #f)
(define t3596 #f)
(define t3597 #f)
(define t3598 #f)
(define t3599 #f)
(define t3600 #f)
(define t3601 #f)
(define t3602 #f)
(define t3603 #f)
(define t3604 #f)
(define t3605 #f)
(define t3606 #f)
(define t3607 #f)
(define t3608 #f)
(define t3609 #f)
(define t3610 #f)
(define t3611 #f)
(define t3612 #f)
(define t3613 #f)
(define t3614 #f)
(define t3615 #f)
(define t3616 #f)
(define t3617 #f)
(define t3618 #f)
(define t3619 #f)
(define t3620 #f)
(define t3621 #f)
(define t3622 #f)
(define t3623 #f)
(define t3624 #f)
(define t3625 #f)
(define t3626 #f)
(define t3627 #f)
(define t3628 #f)
(define t3629 #f)
(define t3630 #f)
(define t3631 #f)
(define t3632 #f)
(define t3633 #f)
(define t3634 #f)
(define t3635 #f)
(define t3636 #f)
(define t3637 #f)
(define t3638 #f)
(define t3639 #f)
(define t3640 #f)
(define t3641 #f)
(define t3642 #f)
(define t3643 #f)
(define t3644 #f)
(define t3645 #f)
(define t3646 #f)
(define t3647 #f)
(define t3648 #f)
(define t3649 #f)
(define t3650 #f)
(define t3651 #f)
(define t3652 #f)
(define t3653 #f)
(define t3654 #f)
(define t3655 #f)
(define t3656 #f)
(define t3657 #f)
(define t3658 #f)
(define t3659 #f)
(define t3660 #f)
(define t3661 #f)
(define t3662 #f)
(define t3663 #f)
(define t3664 #f)
(define t3665 #f)
(define t3666 #f)
(define t3667 #f)
(define t3668 #f)
(define t3669 #f)
(define t3670 #f)
(define t3671 #f)
(define t3672 #f)
(define t3673 #f)
(define t3674 #f)
(define t3675 #f)
(define t3676 #f)
(define t3677 #f)
(define t3678 #f)
(define t3679 #f)
(define t3680 #f)
(define t3681 #f)
(define t3682 #f)
(define t3683 #f)
(define t3684 #f)
(define t3685 #f)
(define t3686 #f)
(define t3687 #f)
(define t3688 #f)
(define t3689 #f)
(define t3690 #f)
(define t3691 #f)
(define t3692 #f)
(define t3693 #f)
(define t3694 #f)
(define t3695 #f)
(define t3696 #f)
(define t3697 #f)
(define t3698 #f)
(define t3699 #f)
(define t3700 #f)
(define t3701 #f)
(define t3702 #f)
(define t3703 #f)
(define t3704 #f)
(define t3705 #f)
(define t3706 #f)
(define t3707 #f)
(define t3708 #f)
(define t3709 #f)
(define t3710 #f)
(define t3711 #f)
(define t3712 #f)
(define t3713 #f)
(define t3714 #f)
(define t3715 #f)
(define t3716 #f)
(define t3717 #f)
(define t3718 #f)
(define t3719 #f)
(define t3720 #f)
(define t3721 #f)
(define t3722 #f)
(define t3723 #f)
(define t3724 #f)
(define t3725 #f)
(define t3726 #f)
(define t3727 #f)
(define t3728 #f)
(define t3729 #f)
(define t3730 #f)
(define t3731 #f)
(define t3732 #f)
(define t3733 #f)
(define t3734 #f)
(define t3735 #f)
(define t3736 #f)
(define t3737 #f)
(define t3738 #f)
(define t3739 #f)
(define t3740 #f)
(define t3741 #f)
(define t3742 #f)
(define t3743 #f)
(define t3744 #f)
(define t3745 #f)
(define t3746 #f)
(define t3747 #f)
(define t3748 #f)
(define t3749 #f)
(define t3750 #f)
(define t3751 #f)
(define t3752 #f)
(define t3753 #f)
(define t3754 #f)
(define t3755 #f)
(define t3756 #f)
(define t3757 #f)
(define t3758 #f)
(define t3759 #f)
(define t3760 #f)
(define t3761 #f)
(define t3762 #f)
(define t3763 #f)
(define t3764 #f)
(define t3765 #f)
(define t3766 #f)
(define t3767 #f)
(define t3768 #f)
(define t3769 #f)
(define t3770 #f)
(define t3771 #f)
(define t3772 #f)
(define t3773 #f)
(define t3774 #f)
(define t3775 #f)
(define t3776 #f)
(define t3777 #f)
(define t3778 #f)
(define t3779 #f)
(define t3780 #f)
(define t3781 #f)
(define t3782 #f)
(define t3783 #f)
(define t3784 #f)
(define t3785 #f)
(define t3786 #f)
(define t3787 #f)
(define t3788 #f)
(define t3789 #f)
(define t3790 #f)
(define t3791 #f)
(define t3792 #f)
(define t3793 #f)
(define t3794 #f)
(define t3795 #f)
(define t3796 #f)
(define t3797 #f)
(define t3798 #f)
(define t3799 #f)
(define t3800 #f)
(define t3801 #f)
(define t3802 #f)
(define t3803 #f)
(define t3804 #f)
(define t3805 #f)
(define t3806 #f)
(define t3807 #f)
(define t3808 #f)
(define t3809 #f)
(define t3810 #f)
(define t3811 #f)
(define t3812 #f)
(define t3813 #f)
(define t3814 #f)
(define t3815 #f)
(define t3816 #f)
(define t3817 #f)
(define t3818 #f)
(define t3819 #f)
(define t3820 #f)
(define t3821 #f)
(define t3822 #f)
(define t3823 #f)
(define t3824 #f)
(define t3825 #f)
(define t3826 #f)
(define t3827 #f)
(define t3828 #f)
(define t3829 #f)
(define t3830 #f)
(define t3831 #f)
(define t3832 #f)
(define t3833 #f)
(define t3834 #f)
(define t3835 #f)
(define t3836 #f)
(define t3837 #f)
(define t3838 #f)
(define t3839 #f)
(define t3840 #f)
(define t3841 #f)
(define t3842 #f)
(define t3843 #f)
(define t3844 #f)
(define t3845 #f)
(define t3846 #f)
(define t3847 #f)
(define t3848 #f)
(define t3849 #f)
(define t3850 #f)
(define t3851 #f)
(define t3852 #f)
(define t3853 #f)
(define t3854 #f)
(define t3855 #f)
(define t3856 #f)
(define t3857 #f)
(define t3858 #f)
(define t3859 #f)
(define t3860 #f)
(define t3861 #f)
(define t3862 #f)
(define t3863 #f)
(define t3864 #f)
(define t3865 #f)
(define t3866 #f)
(define t3867 #f)
(define t3868 #f)
(define t3869 #f)
(define t3870 #f)
(define t3871 #f)
(define t3872 #f)
(define t3873 #f)
(define t3874 #f)
(define t3875 #f)
(define t3876 #f)
(define t3877 #f)
(define t3878 #f)
(define t3879 #f)
(define t3880 #f)
(define t3881 #f)
(define t3882 #f)
(define t3883 #f)
(define t3884 #f)
(define t3885 #f)
(define t3886 #f)
(define t3887 #f)
(define t3888 #f)
(define t3889 #f)
(define t3890 #f)
(define t3891 #f)
(define t3892 #f)
(define t3893 #f)
(define t3894 #f)
(define t3895 #f)
(define t3896 #f)
(define t3897 #f)
(define t3898 #f)
(define t3899 #f)
(define t3900 #f)
(define t3901 #f)
(define t3902 #f)
(define t3903 #f)
(define t3904 #f)
(define t3905 #f)
(define t3906 #f)
(define t3907 #f)
(define t3908 #f)
(define t3909 #f)
(define t3910 #f)
(define t3911 #f)
(define t3912 #f)
(define t3913 #f)
(define t3914 #f)
(define t3915 #f)
(define t3916 #f)
(define t3917 #f)
(define t3918 #f)
(define t3919 #f)
(define t3920 #f)
(define t3921 #f)
(define t3922 #f)
(define t3923 #f)
(define t3924 #f)
(define t3925 #f)
(define t3926 #f)
(define t3927 #f)
(define t3928 #f)
(define t3929 #f)
(define t3930 #f)
(define t3931 #f)
(define t3932 #f)
(define t3933 #f)
(define t3934 #f)
(define t3935 #f)
(define t3936 #f)
(define t3937 #f)
(define t3938 #f)
(define t3939 #f)
(define t3940 #f)
(define t3941 #f)
(define t3942 #f)
(define t3943 #f)
(define t3944 #f)
(define t3945 #f)
(define t3946 #f)
(define t3947 #f)
(define t3948 #f)
(define t3949 #f)
(define t3950 #f)
(define t3951 #f)
(define t3952 #f)
(define t3953 #f)
(define t3954 #f)
(define t3955 #f)
(define t3956 #f)
(define t3957 #f)
(define t3958 #f)
(define t3959 #f)
(define t3960 #f)
(define t3961 #f)
(define t3962 #f)
(define t3963 #f)
(define t3964 #f)
(define t3965 #f)
(define t3966 #f)
(define t3967 #f)
(define t3968 #f)
(define t3969 #f)
(define t3970 #f)
(define t3971 #f)
(define t3972 #f)
(define t3973 #f)
(define t3974 #f)
(define t3975 #f)
(define t3976 #f)
(define t3977 #f)
(define t3978 #f)
(define t3979 #f)
(define t3980 #f)
(define t3981 #f)
(define t3982 #f)
(define t3983 #f)
(define t3984 #f)
(define t3985 #f)
(define t3986 #f)
(define t3987 #f)
(define t3988 #f)
(define t3989 #f)
(define t3990 #f)
(define t3991 #f)
(define t3992 #f)
(define t3993 #f)
(define t3994 #f)
(define t3995 #f)
(define t3996 #f)
(define t3997 #f)
(define t3998 #f)
(define t3999 #f)
(define t4000 #f)
(define t4001 #f)
(define t4002 #f)
(define t4003 #f)
(define t4004 #f)
(define t4005 #f)
(define t4006 #f)
(define t4007 #f)
(define t4008 #f)
(define t4009 #f)
(define t4010 #f)
(define t4011 #f)
(define t4012 #f)
(define t4013 #f)
(define t4014 #f)
(define t4015 #f)
(define t4016 #f)
(define t4017 #f)
(define t4018 #f)
(define t4019 #f)
(define t4020 #f)
(define t4021 #f)
(define t4022 #f)
(define t4023 #f)
(define t4024 #f)
(define t4025 #f)
(define t4026 #f)
(define t4027 #f)
(define t4028 #f)
(define t4029 #f)
(define t4030 #f)
(define t4031 #f)
(define t4032 #f)
(define t4033 #f)
(define t4034 #f)
(define t4035 #f)
(define t4036 #f)
(define t4037 #f)
(define t4038 #f)
(define t4039 #f)
(define t4040 #f)
(define t4041 #f)
(define t4042 #f)
(define t4043 #f)
(define t4044 #f)
(define t4045 #f)
(define t4046 #f)
(define t4047 #f)
(define t4048 #f)
(define t4049 #f)
(define t4050 #f)
(define t4051 #f)
(define t4052 #f)
(define t4053 #f)
(define t4054 #f)
(define t4055 #f)
(define t4056 #f)
(define t4057 #f)
(define t4058 #f)
(define t4059 #f)
(define t4060 #f)
(define t4061 #f)
(define t4062 #f)
(define t4063 #f)
(define t4064 #f)
(define t4065 #f)
(define t4066 #f)
(define t4067 #f)
(define t4068 #f)
(define t4069 #f)
(define t4070 #f)
(define t4071 #f)
(define t4072 #f)
(define t4073 #f)
(define t4074 #f)
(define t4075 #f)
(define t4076 #f)
(define t4077 #f)
(define t4078 #f)
(define t4079 #f)
(define t4080 #f)
(define t4081 #f)
(define t4082 #f)
(define t4083 #f)
(define t4084 #f)
(define t4085 #f)
(define t4086 #f)
(define t4087 #f)
(define t4088 #f)
(define t4089 #f)
(define t4090 #f)
(define t4091 #f)
(define t4092 #f)
(define t4093 #f)
(define t4094 #f)
(define t4095 #f)
(define t4096 #f)
(define t4097 #f)
(define t4098 #f)
(define t4099 #f)
(define t4100 #f)
(define t4101 #f)
(define t4102 #f)
(define t4103 #f)
(define t4104 #f)
(define t4105 #f)
(define t4106 #f)
(define t4107 #f)
(define t4108 #f)
(define t4109 #f)
(define t4110 #f)
(define t4111 #f)
(define t4112 #f)
(define t4113 #f)
(define t4114 #f)
(define t4115 #f)
(define t4116 #f)
(define t4117 #f)
(define t4118 #f)
(define t4119 #f)
(define t4120 #f)
(define t4121 #f)
(define t4122 #f)
(define t4123 #f)
(define t4124 #f)
(define t4125 #f)
(define t4126 #f)
(define t4127 #f)
(define t4128 #f)
(define t4129 #f)
(define t4130 #f)
(define t4131 #f)
(define t4132 #f)
(define t4133 #f)
(define t4134 #f)
(define t4135 #f)
(define t4136 #f)
(define t4137 #f)
(define t4138 #f)
(define t4139 #f)
(define t4140 #f)
(define t4141 #f)
(define t4142 #f)
(define t4143 #f)
(define t4144 #f)
(define t4145 #f)
(define t4146 #f)
(define t4147 #f)
(define t4148 #f)
(define t4149 #f)
(define t4150 #f)
(define t4151 #f)
(define t4152 #f)
(define t4153 #f)
(define t4154 #f)
(define t4155 #f)
(define t4156 #f)
(define t4157 #f)
(define t4158 #f)
(define t4159 #f)
(define t4160 #f)
(define t4161 #f)
(define t4162 #f)
(define t4163 #f)
(define t4164 #f)
(define t4165 #f)
(define t4166 #f)
(define t4167 #f)
(define t4168 #f)
(define t4169 #f)
(define t4170 #f)
(define t4171 #f)
(define t4172 #f)
(define t4173 #f)
(define t4174 #f)
(define t4175 #f)
(define t4176 #f)
(define t4177 #f)
(define t4178 #f)
(define t4179 #f)
(define t4180 #f)
(define t4181 #f)
(define t4182 #f)
(define t4183 #f)
(define t4184 #f)
(define t4185 #f)
(define t4186 #f)
(define t4187 #f)
(define t4188 #f)
(define t4189 #f)
(define t4190 #f)
(define t4191 #f)
(define t4192 #f)
(define t4193 #f)
(define t4194 #f)
(define t4195 #f)
(define t4196 #f)
(define t4197 #f)
(define t4198 #f)
(define t4199 #f)
(define t4200 #f)
(define t4201 #f)
(define t4202 #f)
(define t4203 #f)
(define t4204 #f)
(define t4205 #f)
(define t4206 #f)
(define t4207 #f)
(define t4208 #f)
(define t4209 #f)
(define t4210 #f)
(define t4211 #f)
(define t4212 #f)
(define t4213 #f)
(define t4214 #f)
(define t4215 #f)
(define t4216 #f)
(define t4217 #f)
(define t4218 #f)
(define t4219 #f)
(define t4220 #f)
(define t4221 #f)
(define t4222 #f)
(define t4223 #f)
(define t4224 #f)
(define t4225 #f)
(define t4226 #f)
(define t4227 #f)
(define t4228 #f)
(define t4229 #f)
(define t4230 #f)
(define t4231 #f)
(define t4232 #f)
(define t4233 #f)
(define t4234 #f)
(define t4235 #f)
(define t4236 #f)
(define t4237 #f)
(define t4238 #f)
(define t4239 #f)
(define t4240 #f)
(define t4241 #f)
(define t4242 #f)
(define t4243 #f)
(define t4244 #f)
(define t4245 #f)
(define t4246 #f)
(define t4247 #f)
(define t4248 #f)
(define t4249 #f)
(define t4250 #f)
(define t4251 #f)
(define t4252 #f)
(define t4253 #f)
(define t4254 #f)
(define t4255 #f)
(define t4256 #f)
(define t4257 #f)
(define t4258 #f)
(define t4259 #f)
(define t4260 #f)
(define t4261 #f)
(define t4262 #f)
(define t4263 #f)
(define t4264 #f)
(define t4265 #f)
(define t4266 #f)
(define t4267 #f)
(define t4268 #f)
(define t4269 #f)
(define t4270 #f)
(define t4271 #f)
(define t4272 #f)
(define t4273 #f)
(define t4274 #f)
(define t4275 #f)
(define t4276 #f)
(define t4277 #f)
(define t4278 #f)
(define t4279 #f)
(define t4280 #f)
(define t4281 #f)
(define t4282 #f)
(define t4283 #f)
(define t4284 #f)
(define t4285 #f)
(define t4286 #f)
(define t4287 #f)
(define t4288 #f)
(define t4289 #f)
(define t4290 #f)
(define t4291 #f)
(define t4292 #f)
(define t4293 #f)
(define t4294 #f)
(define t4295 #f)
(define t4296 #f)
(define t4297 #f)
(define t4298 #f)
(define t4299 #f)
(define t4300 #f)
(define t4301 #f)
(define t4302 #f)
(define t4303 #f)
(define t4304 #f)
(define t4305 #f)
(define t4306 #f)
(define t4307 #f)
(define t4308 #f)
(define t4309 #f)
(define t4310 #f)
(define t4311 #f)
(define t4312 #f)
(define t4313 #f)
(define t4314 #f)
(define t4315 #f)
(define t4316 #f)
(define t4317 #f)
(define t4318 #f)
(define t4319 #f)
(define t4320 #f)
(define t4321 #f)
(define t4322 #f)
(define t4323 #f)
(define t4324 #f)
(define t4325 #f)
(define t4326 #f)
(define t4327 #f)
(define t4328 #f)
(define t4329 #f)
(define t4330 #f)
(define t4331 #f)
(define t4332 #f)
(define t4333 #f)
(define t4334 #f)
(define t4335 #f)
(define t4336 #f)
(define t4337 #f)
(define t4338 #f)
(define t4339 #f)
(define t4340 #f)
(define t4341 #f)
(define t4342 #f)
(define t4343 #f)
(define t4344 #f)
(define t4345 #f)
(define t4346 #f)
(define t4347 #f)
(define t4348 #f)
(define t4349 #f)
(define t4350 #f)
(define t4351 #f)
(define t4352 #f)
(define t4353 #f)

(loading)

(set! t2 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t8 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t10 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t11 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t9 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t10 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t11 pts)))
 (union-points new-pts))))

(loading)

(set! t7 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t8 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t9 pts)))
 (union-points new-pts))))

(loading)

(set! t14 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t15 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t13 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t14 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t15 pts)))
 (union-points new-pts))))

(loading)

(set! t18 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t19 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t17 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t18 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t19 pts)))
 (union-points new-pts))))

(loading)

(set! t16 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t17 pts))
 pts))

(loading)

(set! t20 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t12 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t13 pts))
 (set! pts (t16 pts))
 (set! pts (t20 pts))
 pts))

(loading)

(set! t6 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t7 pts))
 (set! pts (t12 pts))
 pts))

(loading)

(set! t21 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t5 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t6 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t21 pts)))
 (union-points new-pts))))

(loading)

(set! t23 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t27 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t28 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t26 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t27 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t28 pts)))
 (union-points new-pts))))

(loading)

(set! t31 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t32 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t30 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t31 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t32 pts)))
 (union-points new-pts))))

(loading)

(set! t29 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t30 pts))
 pts))

(loading)

(set! t33 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t36 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t37 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t35 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t36 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t37 pts)))
 (union-points new-pts))))

(loading)

(set! t34 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t35 pts))
 pts))

(loading)

(set! t38 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t41 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t42 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t40 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t41 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t42 pts)))
 (union-points new-pts))))

(loading)

(set! t44 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t47 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t50 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t51 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t49 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t50 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t51 pts)))
 (union-points new-pts))))

(loading)

(set! t48 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t49 pts))
 pts))

(loading)

(set! t52 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t56 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t57 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t55 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t56 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t57 pts)))
 (union-points new-pts))))

(loading)

(set! t59 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t63 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t64 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t62 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t63 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t64 pts)))
 (union-points new-pts))))

(loading)

(set! t67 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t68 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t66 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t67 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t68 pts)))
 (union-points new-pts))))

(loading)

(set! t70 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t73 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t76 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t77 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t75 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t76 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t77 pts)))
 (union-points new-pts))))

(loading)

(set! t74 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t75 pts))
 pts))

(loading)

(set! t78 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t81 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t82 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t80 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t81 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t82 pts)))
 (union-points new-pts))))

(loading)

(set! t79 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t80 pts))
 pts))

(loading)

(set! t84 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t85 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t83 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t84 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t85 pts)))
 (union-points new-pts))))

(loading)

(set! t88 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t89 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t87 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t88 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t89 pts)))
 (union-points new-pts))))

(loading)

(set! t86 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t87 pts))
 pts))

(loading)

(set! t90 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t92 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t96 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t97 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t95 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t96 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t97 pts)))
 (union-points new-pts))))

(loading)

(set! t94 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t95 pts))
 pts))

(loading)

(set! t98 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t93 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t94 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t98 pts)))
 (union-points new-pts))))

(loading)

(set! t101 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t102 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t100 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t101 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t102 pts)))
 (union-points new-pts))))

(loading)

(set! t99 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t100 pts))
 pts))

(loading)

(set! t103 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t106 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t107 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t105 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t106 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t107 pts)))
 (union-points new-pts))))

(loading)

(set! t104 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t105 pts))
 pts))

(loading)

(set! t108 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t111 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t112 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t110 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t111 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t112 pts)))
 (union-points new-pts))))

(loading)

(set! t115 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t116 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t114 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t115 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t116 pts)))
 (union-points new-pts))))

(loading)

(set! t113 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t114 pts))
 pts))

(loading)

(set! t117 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t120 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t121 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t119 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t120 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t121 pts)))
 (union-points new-pts))))

(loading)

(set! t123 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t127 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t128 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t126 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t127 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t128 pts)))
 (union-points new-pts))))

(loading)

(set! t131 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t132 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t130 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t131 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t132 pts)))
 (union-points new-pts))))

(loading)

(set! t129 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t130 pts))
 pts))

(loading)

(set! t133 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t136 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t137 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t135 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t136 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t137 pts)))
 (union-points new-pts))))

(loading)

(set! t139 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t143 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t144 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t142 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t143 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t144 pts)))
 (union-points new-pts))))

(loading)

(set! t146 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t149 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t152 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t155 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t156 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t154 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t155 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t156 pts)))
 (union-points new-pts))))

(loading)

(set! t153 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t154 pts))
 pts))

(loading)

(set! t158 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t159 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t157 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t158 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t159 pts)))
 (union-points new-pts))))

(loading)

(set! t162 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t163 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t161 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t162 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t163 pts)))
 (union-points new-pts))))

(loading)

(set! t160 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t161 pts))
 pts))

(loading)

(set! t164 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t166 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t170 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t171 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t169 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t170 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t171 pts)))
 (union-points new-pts))))

(loading)

(set! t168 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t169 pts))
 pts))

(loading)

(set! t172 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t167 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t168 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t172 pts)))
 (union-points new-pts))))

(loading)

(set! t174 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t177 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t180 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t181 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t179 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t180 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t181 pts)))
 (union-points new-pts))))

(loading)

(set! t178 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t179 pts))
 pts))

(loading)

(set! t182 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t185 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t188 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t191 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t195 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t196 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t194 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t195 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t196 pts)))
 (union-points new-pts))))

(loading)

(set! t193 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t194 pts))
 pts))

(loading)

(set! t197 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t192 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t193 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t197 pts)))
 (union-points new-pts))))

(loading)

(set! t199 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t202 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t205 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t209 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t210 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t208 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t209 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t210 pts)))
 (union-points new-pts))))

(loading)

(set! t207 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t208 pts))
 pts))

(loading)

(set! t211 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t206 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t207 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t211 pts)))
 (union-points new-pts))))

(loading)

(set! t214 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t215 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t213 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t214 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t215 pts)))
 (union-points new-pts))))

(loading)

(set! t218 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t219 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t217 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t218 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t219 pts)))
 (union-points new-pts))))

(loading)

(set! t221 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t225 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t226 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t224 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t225 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t226 pts)))
 (union-points new-pts))))

(loading)

(set! t229 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t230 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t228 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t229 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t230 pts)))
 (union-points new-pts))))

(loading)

(set! t227 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t228 pts))
 pts))

(loading)

(set! t231 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t233 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t236 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t239 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t243 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t244 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t242 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t243 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t244 pts)))
 (union-points new-pts))))

(loading)

(set! t241 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t242 pts))
 pts))

(loading)

(set! t245 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t240 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t241 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t245 pts)))
 (union-points new-pts))))

(loading)

(set! t247 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t250 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t254 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t255 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t253 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t254 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t255 pts)))
 (union-points new-pts))))

(loading)

(set! t252 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t253 pts))
 pts))

(loading)

(set! t256 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t251 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t252 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t256 pts)))
 (union-points new-pts))))

(loading)

(set! t259 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t260 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t258 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t259 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t260 pts)))
 (union-points new-pts))))

(loading)

(set! t262 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t265 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t268 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t269 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t267 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t268 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t269 pts)))
 (union-points new-pts))))

(loading)

(set! t266 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t267 pts))
 pts))

(loading)

(set! t270 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t273 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t276 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t279 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t282 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t286 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t287 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t285 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t286 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t287 pts)))
 (union-points new-pts))))

(loading)

(set! t289 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t292 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t293 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t291 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t292 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t293 pts)))
 (union-points new-pts))))

(loading)

(set! t290 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t291 pts))
 pts))

(loading)

(set! t294 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t297 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t298 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t296 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t297 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t298 pts)))
 (union-points new-pts))))

(loading)

(set! t295 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t296 pts))
 pts))

(loading)

(set! t299 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t303 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t304 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t302 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t303 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t304 pts)))
 (union-points new-pts))))

(loading)

(set! t306 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t309 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t312 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t316 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t317 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t315 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t316 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t317 pts)))
 (union-points new-pts))))

(loading)

(set! t314 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t315 pts))
 pts))

(loading)

(set! t318 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t313 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t314 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t318 pts)))
 (union-points new-pts))))

(loading)

(set! t320 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t324 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t325 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t323 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t324 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t325 pts)))
 (union-points new-pts))))

(loading)

(set! t327 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t330 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t334 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t335 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t333 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t334 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t335 pts)))
 (union-points new-pts))))

(loading)

(set! t338 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t339 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t337 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t338 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t339 pts)))
 (union-points new-pts))))

(loading)

(set! t336 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t337 pts))
 pts))

(loading)

(set! t340 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t342 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t346 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t347 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t345 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t346 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t347 pts)))
 (union-points new-pts))))

(loading)

(set! t350 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t351 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t349 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t350 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t351 pts)))
 (union-points new-pts))))

(loading)

(set! t348 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t349 pts))
 pts))

(loading)

(set! t344 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t345 pts))
 (set! pts (t348 pts))
 pts))

(loading)

(set! t352 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t343 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t344 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t352 pts)))
 (union-points new-pts))))

(loading)

(set! t341 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t342 pts))
 (set! pts (t343 pts))
 pts))

(loading)

(set! t332 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t333 pts))
 (set! pts (t336 pts))
 (set! pts (t340 pts))
 (set! pts (t341 pts))
 pts))

(loading)

(set! t353 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t331 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t332 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t353 pts)))
 (union-points new-pts))))

(loading)

(set! t356 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t357 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t355 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t356 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t357 pts)))
 (union-points new-pts))))

(loading)

(set! t359 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t362 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t366 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t367 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t365 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t366 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t367 pts)))
 (union-points new-pts))))

(loading)

(set! t364 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t365 pts))
 pts))

(loading)

(set! t368 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t363 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t364 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t368 pts)))
 (union-points new-pts))))

(loading)

(set! t371 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t372 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t370 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t371 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t372 pts)))
 (union-points new-pts))))

(loading)

(set! t375 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t376 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t374 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t375 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t376 pts)))
 (union-points new-pts))))

(loading)

(set! t378 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t381 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t385 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t386 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t384 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t385 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t386 pts)))
 (union-points new-pts))))

(loading)

(set! t388 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t392 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t393 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t391 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t392 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t393 pts)))
 (union-points new-pts))))

(loading)

(set! t396 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t397 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t395 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t396 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t397 pts)))
 (union-points new-pts))))

(loading)

(set! t400 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t401 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t399 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t400 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t401 pts)))
 (union-points new-pts))))

(loading)

(set! t403 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t407 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t408 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t406 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t407 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t408 pts)))
 (union-points new-pts))))

(loading)

(set! t410 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t413 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t414 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t412 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t413 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t414 pts)))
 (union-points new-pts))))

(loading)

(set! t411 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t412 pts))
 pts))

(loading)

(set! t415 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t418 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t419 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t417 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t418 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t419 pts)))
 (union-points new-pts))))

(loading)

(set! t416 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t417 pts))
 pts))

(loading)

(set! t421 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t422 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t420 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t421 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t422 pts)))
 (union-points new-pts))))

(loading)

(set! t425 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t426 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t424 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t425 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t426 pts)))
 (union-points new-pts))))

(loading)

(set! t423 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t424 pts))
 pts))

(loading)

(set! t409 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t410 pts))
 (set! pts (t411 pts))
 (set! pts (t415 pts))
 (set! pts (t416 pts))
 (set! pts (t420 pts))
 (set! pts (t423 pts))
 pts))

(loading)

(set! t405 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t406 pts))
 (set! pts (t409 pts))
 pts))

(loading)

(set! t427 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t404 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t405 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t427 pts)))
 (union-points new-pts))))

(loading)

(set! t430 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t431 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t429 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t430 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t431 pts)))
 (union-points new-pts))))

(loading)

(set! t428 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t429 pts))
 pts))

(loading)

(set! t432 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t434 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t437 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t440 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t444 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t445 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t443 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t444 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t445 pts)))
 (union-points new-pts))))

(loading)

(set! t447 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t451 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t452 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t450 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t451 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t452 pts)))
 (union-points new-pts))))

(loading)

(set! t449 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t450 pts))
 pts))

(loading)

(set! t453 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t448 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t449 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t453 pts)))
 (union-points new-pts))))

(loading)

(set! t446 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t447 pts))
 (set! pts (t448 pts))
 pts))

(loading)

(set! t442 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t443 pts))
 (set! pts (t446 pts))
 pts))

(loading)

(set! t454 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t441 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t442 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t454 pts)))
 (union-points new-pts))))

(loading)

(set! t456 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t460 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t461 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t459 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t460 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t461 pts)))
 (union-points new-pts))))

(loading)

(set! t464 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t465 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t463 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t464 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t465 pts)))
 (union-points new-pts))))

(loading)

(set! t467 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t470 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t471 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t469 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t470 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t471 pts)))
 (union-points new-pts))))

(loading)

(set! t468 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t469 pts))
 pts))

(loading)

(set! t472 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t475 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t476 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t474 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t475 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t476 pts)))
 (union-points new-pts))))

(loading)

(set! t473 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t474 pts))
 pts))

(loading)

(set! t477 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t480 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t484 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t485 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t483 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t484 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t485 pts)))
 (union-points new-pts))))

(loading)

(set! t487 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t490 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t493 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t494 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t492 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t493 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t494 pts)))
 (union-points new-pts))))

(loading)

(set! t491 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t492 pts))
 pts))

(loading)

(set! t496 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t497 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t495 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t496 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t497 pts)))
 (union-points new-pts))))

(loading)

(set! t489 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t490 pts))
 (set! pts (t491 pts))
 (set! pts (t495 pts))
 pts))

(loading)

(set! t498 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t488 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t489 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t498 pts)))
 (union-points new-pts))))

(loading)

(set! t500 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t503 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t506 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t507 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t505 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t506 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t507 pts)))
 (union-points new-pts))))

(loading)

(set! t504 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t505 pts))
 pts))

(loading)

(set! t508 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t511 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t512 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t510 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t511 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t512 pts)))
 (union-points new-pts))))

(loading)

(set! t509 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t510 pts))
 pts))

(loading)

(set! t513 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t516 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t519 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t520 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t518 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t519 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t520 pts)))
 (union-points new-pts))))

(loading)

(set! t517 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t518 pts))
 pts))

(loading)

(set! t521 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t525 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t526 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t524 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t525 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t526 pts)))
 (union-points new-pts))))

(loading)

(set! t529 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t530 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t528 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t529 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t530 pts)))
 (union-points new-pts))))

(loading)

(set! t532 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t535 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t539 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t540 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t538 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t539 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t540 pts)))
 (union-points new-pts))))

(loading)

(set! t542 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t545 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t546 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t544 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t545 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t546 pts)))
 (union-points new-pts))))

(loading)

(set! t543 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t544 pts))
 pts))

(loading)

(set! t547 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t550 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t551 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t549 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t550 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t551 pts)))
 (union-points new-pts))))

(loading)

(set! t548 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t549 pts))
 pts))

(loading)

(set! t553 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t554 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t552 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t553 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t554 pts)))
 (union-points new-pts))))

(loading)

(set! t541 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t542 pts))
 (set! pts (t543 pts))
 (set! pts (t547 pts))
 (set! pts (t548 pts))
 (set! pts (t552 pts))
 pts))

(loading)

(set! t537 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t538 pts))
 (set! pts (t541 pts))
 pts))

(loading)

(set! t555 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t536 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t537 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t555 pts)))
 (union-points new-pts))))

(loading)

(set! t558 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t559 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t557 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t558 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t559 pts)))
 (union-points new-pts))))

(loading)

(set! t556 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t557 pts))
 pts))

(loading)

(set! t534 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t535 pts))
 (set! pts (t536 pts))
 (set! pts (t556 pts))
 pts))

(loading)

(set! t560 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t533 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t534 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t560 pts)))
 (union-points new-pts))))

(loading)

(set! t562 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t565 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t569 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t570 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t568 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t569 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t570 pts)))
 (union-points new-pts))))

(loading)

(set! t567 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t568 pts))
 pts))

(loading)

(set! t571 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t566 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t567 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t571 pts)))
 (union-points new-pts))))

(loading)

(set! t573 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t576 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t577 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t575 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t576 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t577 pts)))
 (union-points new-pts))))

(loading)

(set! t574 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t575 pts))
 pts))

(loading)

(set! t578 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t581 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t584 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t587 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t591 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t592 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t590 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t591 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t592 pts)))
 (union-points new-pts))))

(loading)

(set! t594 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t597 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t600 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t601 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t599 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t600 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t601 pts)))
 (union-points new-pts))))

(loading)

(set! t598 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t599 pts))
 pts))

(loading)

(set! t602 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t605 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t608 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t611 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t614 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t617 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t620 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t623 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t626 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t629 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t630 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t628 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t629 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t630 pts)))
 (union-points new-pts))))

(loading)

(set! t627 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t628 pts))
 pts))

(loading)

(set! t631 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t635 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t636 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t634 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t635 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t636 pts)))
 (union-points new-pts))))

(loading)

(set! t639 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t640 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t638 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t639 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t640 pts)))
 (union-points new-pts))))

(loading)

(set! t637 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t638 pts))
 pts))

(loading)

(set! t633 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t634 pts))
 (set! pts (t637 pts))
 pts))

(loading)

(set! t641 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t632 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t633 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t641 pts)))
 (union-points new-pts))))

(loading)

(set! t644 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t645 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t643 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t644 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t645 pts)))
 (union-points new-pts))))

(loading)

(set! t642 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t643 pts))
 pts))

(loading)

(set! t647 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t650 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t653 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t657 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t658 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t656 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t657 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t658 pts)))
 (union-points new-pts))))

(loading)

(set! t661 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t662 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t660 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t661 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t662 pts)))
 (union-points new-pts))))

(loading)

(set! t665 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t666 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t664 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t665 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t666 pts)))
 (union-points new-pts))))

(loading)

(set! t663 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t664 pts))
 pts))

(loading)

(set! t667 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t659 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t660 pts))
 (set! pts (t663 pts))
 (set! pts (t667 pts))
 pts))

(loading)

(set! t655 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t656 pts))
 (set! pts (t659 pts))
 pts))

(loading)

(set! t668 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t654 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t655 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t668 pts)))
 (union-points new-pts))))

(loading)

(set! t652 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t653 pts))
 (set! pts (t654 pts))
 pts))

(loading)

(set! t669 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t651 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t652 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t669 pts)))
 (union-points new-pts))))

(loading)

(set! t671 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t675 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t676 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t674 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t675 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t676 pts)))
 (union-points new-pts))))

(loading)

(set! t679 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t680 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t678 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t679 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t680 pts)))
 (union-points new-pts))))

(loading)

(set! t677 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t678 pts))
 pts))

(loading)

(set! t681 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t673 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t674 pts))
 (set! pts (t677 pts))
 (set! pts (t681 pts))
 pts))

(loading)

(set! t682 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t672 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t673 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t682 pts)))
 (union-points new-pts))))

(loading)

(set! t684 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t688 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t689 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t687 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t688 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t689 pts)))
 (union-points new-pts))))

(loading)

(set! t686 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t687 pts))
 pts))

(loading)

(set! t690 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t685 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t686 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t690 pts)))
 (union-points new-pts))))

(loading)

(set! t692 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t695 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t699 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t700 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t698 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t699 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t700 pts)))
 (union-points new-pts))))

(loading)

(set! t697 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t698 pts))
 pts))

(loading)

(set! t701 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t696 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t697 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t701 pts)))
 (union-points new-pts))))

(loading)

(set! t703 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t706 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t709 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t710 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t708 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t709 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t710 pts)))
 (union-points new-pts))))

(loading)

(set! t707 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t708 pts))
 pts))

(loading)

(set! t711 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t715 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t716 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t714 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t715 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t716 pts)))
 (union-points new-pts))))

(loading)

(set! t719 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t720 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t718 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t719 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t720 pts)))
 (union-points new-pts))))

(loading)

(set! t717 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t718 pts))
 pts))

(loading)

(set! t721 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t723 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t727 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t728 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t726 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t727 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t728 pts)))
 (union-points new-pts))))

(loading)

(set! t731 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t732 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t730 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t731 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t732 pts)))
 (union-points new-pts))))

(loading)

(set! t729 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t730 pts))
 pts))

(loading)

(set! t733 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t725 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t726 pts))
 (set! pts (t729 pts))
 (set! pts (t733 pts))
 pts))

(loading)

(set! t734 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t724 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t725 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t734 pts)))
 (union-points new-pts))))

(loading)

(set! t737 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t738 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t736 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t737 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t738 pts)))
 (union-points new-pts))))

(loading)

(set! t735 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t736 pts))
 pts))

(loading)

(set! t739 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t722 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t723 pts))
 (set! pts (t724 pts))
 (set! pts (t735 pts))
 (set! pts (t739 pts))
 pts))

(loading)

(set! t713 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t714 pts))
 (set! pts (t717 pts))
 (set! pts (t721 pts))
 (set! pts (t722 pts))
 pts))

(loading)

(set! t740 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t712 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t713 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t740 pts)))
 (union-points new-pts))))

(loading)

(set! t742 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t746 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t747 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t745 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t746 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t747 pts)))
 (union-points new-pts))))

(loading)

(set! t749 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t752 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t753 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t751 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t752 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t753 pts)))
 (union-points new-pts))))

(loading)

(set! t750 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t751 pts))
 pts))

(loading)

(set! t754 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t758 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t759 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t757 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t758 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t759 pts)))
 (union-points new-pts))))

(loading)

(set! t756 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t757 pts))
 pts))

(loading)

(set! t760 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t755 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t756 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t760 pts)))
 (union-points new-pts))))

(loading)

(set! t762 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t765 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t769 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t770 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t768 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t769 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t770 pts)))
 (union-points new-pts))))

(loading)

(set! t773 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t774 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t772 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t773 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t774 pts)))
 (union-points new-pts))))

(loading)

(set! t777 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t778 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t776 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t777 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t778 pts)))
 (union-points new-pts))))

(loading)

(set! t775 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t776 pts))
 pts))

(loading)

(set! t779 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t781 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t784 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t787 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t791 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t792 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t790 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t791 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t792 pts)))
 (union-points new-pts))))

(loading)

(set! t789 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t790 pts))
 pts))

(loading)

(set! t793 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t788 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t789 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t793 pts)))
 (union-points new-pts))))

(loading)

(set! t786 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t787 pts))
 (set! pts (t788 pts))
 pts))

(loading)

(set! t794 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t785 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t786 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t794 pts)))
 (union-points new-pts))))

(loading)

(set! t796 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t799 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t803 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t804 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t802 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t803 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t804 pts)))
 (union-points new-pts))))

(loading)

(set! t807 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t808 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t806 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t807 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t808 pts)))
 (union-points new-pts))))

(loading)

(set! t805 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t806 pts))
 pts))

(loading)

(set! t809 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t811 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t814 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t815 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t813 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t814 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t815 pts)))
 (union-points new-pts))))

(loading)

(set! t812 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t813 pts))
 pts))

(loading)

(set! t817 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t818 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t816 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t817 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t818 pts)))
 (union-points new-pts))))

(loading)

(set! t821 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t822 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t820 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t821 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t822 pts)))
 (union-points new-pts))))

(loading)

(set! t819 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t820 pts))
 pts))

(loading)

(set! t823 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t825 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t828 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t831 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t832 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t830 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t831 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t832 pts)))
 (union-points new-pts))))

(loading)

(set! t829 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t830 pts))
 pts))

(loading)

(set! t834 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t835 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t833 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t834 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t835 pts)))
 (union-points new-pts))))

(loading)

(set! t827 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t828 pts))
 (set! pts (t829 pts))
 (set! pts (t833 pts))
 pts))

(loading)

(set! t836 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t826 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t827 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t836 pts)))
 (union-points new-pts))))

(loading)

(set! t839 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t840 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t838 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t839 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t840 pts)))
 (union-points new-pts))))

(loading)

(set! t837 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t838 pts))
 pts))

(loading)

(set! t841 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t844 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t845 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t843 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t844 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t845 pts)))
 (union-points new-pts))))

(loading)

(set! t842 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t843 pts))
 pts))

(loading)

(set! t846 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t824 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t825 pts))
 (set! pts (t826 pts))
 (set! pts (t837 pts))
 (set! pts (t841 pts))
 (set! pts (t842 pts))
 (set! pts (t846 pts))
 pts))

(loading)

(set! t810 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t811 pts))
 (set! pts (t812 pts))
 (set! pts (t816 pts))
 (set! pts (t819 pts))
 (set! pts (t823 pts))
 (set! pts (t824 pts))
 pts))

(loading)

(set! t801 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t802 pts))
 (set! pts (t805 pts))
 (set! pts (t809 pts))
 (set! pts (t810 pts))
 pts))

(loading)

(set! t847 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t800 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t801 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t847 pts)))
 (union-points new-pts))))

(loading)

(set! t850 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t851 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t849 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t850 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t851 pts)))
 (union-points new-pts))))

(loading)

(set! t854 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t856 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t857 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t855 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t856 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t857 pts)))
 (union-points new-pts))))

(loading)

(set! t853 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t854 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t855 pts)))
 (union-points new-pts))))

(loading)

(set! t852 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t853 pts))
 pts))

(loading)

(set! t848 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t849 pts))
 (set! pts (t852 pts))
 pts))

(loading)

(set! t798 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t799 pts))
 (set! pts (t800 pts))
 (set! pts (t848 pts))
 pts))

(loading)

(set! t858 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t797 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t798 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t858 pts)))
 (union-points new-pts))))

(loading)

(set! t861 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t862 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t860 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t861 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t862 pts)))
 (union-points new-pts))))

(loading)

(set! t865 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t866 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t864 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t865 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t866 pts)))
 (union-points new-pts))))

(loading)

(set! t863 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t864 pts))
 pts))

(loading)

(set! t859 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t860 pts))
 (set! pts (t863 pts))
 pts))

(loading)

(set! t795 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t796 pts))
 (set! pts (t797 pts))
 (set! pts (t859 pts))
 pts))

(loading)

(set! t783 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t784 pts))
 (set! pts (t785 pts))
 (set! pts (t795 pts))
 pts))

(loading)

(set! t867 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t782 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t783 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t867 pts)))
 (union-points new-pts))))

(loading)

(set! t780 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t781 pts))
 (set! pts (t782 pts))
 pts))

(loading)

(set! t771 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t772 pts))
 (set! pts (t775 pts))
 (set! pts (t779 pts))
 (set! pts (t780 pts))
 pts))

(loading)

(set! t767 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t768 pts))
 (set! pts (t771 pts))
 pts))

(loading)

(set! t868 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t766 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t767 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t868 pts)))
 (union-points new-pts))))

(loading)

(set! t870 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t874 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t875 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t873 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t874 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t875 pts)))
 (union-points new-pts))))

(loading)

(set! t872 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t873 pts))
 pts))

(loading)

(set! t876 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t871 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t872 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t876 pts)))
 (union-points new-pts))))

(loading)

(set! t878 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t882 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t883 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t881 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t882 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t883 pts)))
 (union-points new-pts))))

(loading)

(set! t886 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t887 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t885 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t886 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t887 pts)))
 (union-points new-pts))))

(loading)

(set! t884 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t885 pts))
 pts))

(loading)

(set! t888 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t890 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t894 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t895 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t893 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t894 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t895 pts)))
 (union-points new-pts))))

(loading)

(set! t897 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t900 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t903 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t904 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t902 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t903 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t904 pts)))
 (union-points new-pts))))

(loading)

(set! t901 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t902 pts))
 pts))

(loading)

(set! t905 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t908 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t911 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t912 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t910 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t911 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t912 pts)))
 (union-points new-pts))))

(loading)

(set! t909 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t910 pts))
 pts))

(loading)

(set! t913 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t917 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t918 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t916 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t917 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t918 pts)))
 (union-points new-pts))))

(loading)

(set! t915 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t916 pts))
 pts))

(loading)

(set! t919 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t914 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t915 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t919 pts)))
 (union-points new-pts))))

(loading)

(set! t922 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t923 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t921 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t922 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t923 pts)))
 (union-points new-pts))))

(loading)

(set! t920 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t921 pts))
 pts))

(loading)

(set! t924 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t907 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t908 pts))
 (set! pts (t909 pts))
 (set! pts (t913 pts))
 (set! pts (t914 pts))
 (set! pts (t920 pts))
 (set! pts (t924 pts))
 pts))

(loading)

(set! t925 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t906 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t907 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t925 pts)))
 (union-points new-pts))))

(loading)

(set! t899 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t900 pts))
 (set! pts (t901 pts))
 (set! pts (t905 pts))
 (set! pts (t906 pts))
 pts))

(loading)

(set! t926 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t898 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t899 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t926 pts)))
 (union-points new-pts))))

(loading)

(set! t929 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t930 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t928 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t929 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t930 pts)))
 (union-points new-pts))))

(loading)

(set! t927 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t928 pts))
 pts))

(loading)

(set! t896 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t897 pts))
 (set! pts (t898 pts))
 (set! pts (t927 pts))
 pts))

(loading)

(set! t892 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t893 pts))
 (set! pts (t896 pts))
 pts))

(loading)

(set! t931 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t891 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t892 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t931 pts)))
 (union-points new-pts))))

(loading)

(set! t933 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t936 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t937 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t935 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t936 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t937 pts)))
 (union-points new-pts))))

(loading)

(set! t934 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t935 pts))
 pts))

(loading)

(set! t938 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t941 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t944 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t945 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t943 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t944 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t945 pts)))
 (union-points new-pts))))

(loading)

(set! t942 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t943 pts))
 pts))

(loading)

(set! t946 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t950 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t951 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t949 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t950 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t951 pts)))
 (union-points new-pts))))

(loading)

(set! t953 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t956 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t959 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t962 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t965 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t968 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t971 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t972 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t970 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t971 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t972 pts)))
 (union-points new-pts))))

(loading)

(set! t969 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t970 pts))
 pts))

(loading)

(set! t973 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t977 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t978 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t976 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t977 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t978 pts)))
 (union-points new-pts))))

(loading)

(set! t975 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t976 pts))
 pts))

(loading)

(set! t979 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t974 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t975 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t979 pts)))
 (union-points new-pts))))

(loading)

(set! t981 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t985 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t986 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t984 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t985 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t986 pts)))
 (union-points new-pts))))

(loading)

(set! t988 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t991 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t995 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t996 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t994 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t995 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t996 pts)))
 (union-points new-pts))))

(loading)

(set! t998 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1001 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1002 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1000 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1001 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1002 pts)))
 (union-points new-pts))))

(loading)

(set! t999 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1000 pts))
 pts))

(loading)

(set! t1003 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1006 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1009 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1013 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1014 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1012 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1013 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1014 pts)))
 (union-points new-pts))))

(loading)

(set! t1016 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1019 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1020 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1018 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1019 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1020 pts)))
 (union-points new-pts))))

(loading)

(set! t1017 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1018 pts))
 pts))

(loading)

(set! t1021 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1025 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1026 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1024 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1025 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1026 pts)))
 (union-points new-pts))))

(loading)

(set! t1028 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1032 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1033 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1031 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1032 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1033 pts)))
 (union-points new-pts))))

(loading)

(set! t1035 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1039 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1040 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1038 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1039 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1040 pts)))
 (union-points new-pts))))

(loading)

(set! t1037 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1038 pts))
 pts))

(loading)

(set! t1041 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1036 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1037 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1041 pts)))
 (union-points new-pts))))

(loading)

(set! t1044 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1045 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1043 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1044 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1045 pts)))
 (union-points new-pts))))

(loading)

(set! t1042 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1043 pts))
 pts))

(loading)

(set! t1046 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1034 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1035 pts))
 (set! pts (t1036 pts))
 (set! pts (t1042 pts))
 (set! pts (t1046 pts))
 pts))

(loading)

(set! t1030 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1031 pts))
 (set! pts (t1034 pts))
 pts))

(loading)

(set! t1047 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1029 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1030 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1047 pts)))
 (union-points new-pts))))

(loading)

(set! t1049 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1052 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1055 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1056 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1054 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1055 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1056 pts)))
 (union-points new-pts))))

(loading)

(set! t1053 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1054 pts))
 pts))

(loading)

(set! t1057 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1060 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1063 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1066 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1067 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1065 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1066 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1067 pts)))
 (union-points new-pts))))

(loading)

(set! t1064 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1065 pts))
 pts))

(loading)

(set! t1069 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1070 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1068 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1069 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1070 pts)))
 (union-points new-pts))))

(loading)

(set! t1073 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1074 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1072 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1073 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1074 pts)))
 (union-points new-pts))))

(loading)

(set! t1071 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1072 pts))
 pts))

(loading)

(set! t1062 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1063 pts))
 (set! pts (t1064 pts))
 (set! pts (t1068 pts))
 (set! pts (t1071 pts))
 pts))

(loading)

(set! t1075 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1061 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1062 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1075 pts)))
 (union-points new-pts))))

(loading)

(set! t1078 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1079 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1077 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1078 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1079 pts)))
 (union-points new-pts))))

(loading)

(set! t1076 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1077 pts))
 pts))

(loading)

(set! t1080 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1082 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1086 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1087 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1085 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1086 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1087 pts)))
 (union-points new-pts))))

(loading)

(set! t1084 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1085 pts))
 pts))

(loading)

(set! t1088 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1083 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1084 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1088 pts)))
 (union-points new-pts))))

(loading)

(set! t1091 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1092 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1090 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1091 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1092 pts)))
 (union-points new-pts))))

(loading)

(set! t1089 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1090 pts))
 pts))

(loading)

(set! t1093 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1096 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1097 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1095 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1096 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1097 pts)))
 (union-points new-pts))))

(loading)

(set! t1100 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1101 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1099 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1100 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1101 pts)))
 (union-points new-pts))))

(loading)

(set! t1103 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1107 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1108 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1106 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1107 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1108 pts)))
 (union-points new-pts))))

(loading)

(set! t1105 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1106 pts))
 pts))

(loading)

(set! t1109 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1104 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1105 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1109 pts)))
 (union-points new-pts))))

(loading)

(set! t1112 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1113 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1111 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1112 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1113 pts)))
 (union-points new-pts))))

(loading)

(set! t1116 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1117 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1115 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1116 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1117 pts)))
 (union-points new-pts))))

(loading)

(set! t1120 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1121 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1119 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1120 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1121 pts)))
 (union-points new-pts))))

(loading)

(set! t1118 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1119 pts))
 pts))

(loading)

(set! t1122 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1125 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1126 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1124 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1125 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1126 pts)))
 (union-points new-pts))))

(loading)

(set! t1128 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1132 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1133 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1131 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1132 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1133 pts)))
 (union-points new-pts))))

(loading)

(set! t1136 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1137 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1135 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1136 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1137 pts)))
 (union-points new-pts))))

(loading)

(set! t1134 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1135 pts))
 pts))

(loading)

(set! t1138 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1130 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1131 pts))
 (set! pts (t1134 pts))
 (set! pts (t1138 pts))
 pts))

(loading)

(set! t1139 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1129 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1130 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1139 pts)))
 (union-points new-pts))))

(loading)

(set! t1142 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1143 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1141 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1142 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1143 pts)))
 (union-points new-pts))))

(loading)

(set! t1140 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1141 pts))
 pts))

(loading)

(set! t1144 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1127 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1128 pts))
 (set! pts (t1129 pts))
 (set! pts (t1140 pts))
 (set! pts (t1144 pts))
 pts))

(loading)

(set! t1123 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1124 pts))
 (set! pts (t1127 pts))
 pts))

(loading)

(set! t1114 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1115 pts))
 (set! pts (t1118 pts))
 (set! pts (t1122 pts))
 (set! pts (t1123 pts))
 pts))

(loading)

(set! t1110 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1111 pts))
 (set! pts (t1114 pts))
 pts))

(loading)

(set! t1102 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1103 pts))
 (set! pts (t1104 pts))
 (set! pts (t1110 pts))
 pts))

(loading)

(set! t1098 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1099 pts))
 (set! pts (t1102 pts))
 pts))

(loading)

(set! t1094 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1095 pts))
 (set! pts (t1098 pts))
 pts))

(loading)

(set! t1081 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1082 pts))
 (set! pts (t1083 pts))
 (set! pts (t1089 pts))
 (set! pts (t1093 pts))
 (set! pts (t1094 pts))
 pts))

(loading)

(set! t1059 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1060 pts))
 (set! pts (t1061 pts))
 (set! pts (t1076 pts))
 (set! pts (t1080 pts))
 (set! pts (t1081 pts))
 pts))

(loading)

(set! t1145 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1058 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1059 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1145 pts)))
 (union-points new-pts))))

(loading)

(set! t1147 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1150 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1151 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1149 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1150 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1151 pts)))
 (union-points new-pts))))

(loading)

(set! t1148 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1149 pts))
 pts))

(loading)

(set! t1153 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1154 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1152 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1153 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1154 pts)))
 (union-points new-pts))))

(loading)

(set! t1146 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1147 pts))
 (set! pts (t1148 pts))
 (set! pts (t1152 pts))
 pts))

(loading)

(set! t1051 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1052 pts))
 (set! pts (t1053 pts))
 (set! pts (t1057 pts))
 (set! pts (t1058 pts))
 (set! pts (t1146 pts))
 pts))

(loading)

(set! t1155 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1050 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1051 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1155 pts)))
 (union-points new-pts))))

(loading)

(set! t1158 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1159 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1157 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1158 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1159 pts)))
 (union-points new-pts))))

(loading)

(set! t1156 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1157 pts))
 pts))

(loading)

(set! t1160 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1048 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1049 pts))
 (set! pts (t1050 pts))
 (set! pts (t1156 pts))
 (set! pts (t1160 pts))
 pts))

(loading)

(set! t1027 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1028 pts))
 (set! pts (t1029 pts))
 (set! pts (t1048 pts))
 pts))

(loading)

(set! t1023 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1024 pts))
 (set! pts (t1027 pts))
 pts))

(loading)

(set! t1161 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1022 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1023 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1161 pts)))
 (union-points new-pts))))

(loading)

(set! t1163 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1167 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1168 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1166 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1167 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1168 pts)))
 (union-points new-pts))))

(loading)

(set! t1170 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1174 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1175 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1173 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1174 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1175 pts)))
 (union-points new-pts))))

(loading)

(set! t1172 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1173 pts))
 pts))

(loading)

(set! t1176 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1171 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1172 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1176 pts)))
 (union-points new-pts))))

(loading)

(set! t1178 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1181 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1185 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1186 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1184 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1185 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1186 pts)))
 (union-points new-pts))))

(loading)

(set! t1188 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1191 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1192 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1190 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1191 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1192 pts)))
 (union-points new-pts))))

(loading)

(set! t1189 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1190 pts))
 pts))

(loading)

(set! t1193 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1196 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1200 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1201 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1199 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1200 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1201 pts)))
 (union-points new-pts))))

(loading)

(set! t1198 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1199 pts))
 pts))

(loading)

(set! t1202 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1197 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1198 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1202 pts)))
 (union-points new-pts))))

(loading)

(set! t1195 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1196 pts))
 (set! pts (t1197 pts))
 pts))

(loading)

(set! t1203 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1194 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1195 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1203 pts)))
 (union-points new-pts))))

(loading)

(set! t1206 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1207 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1205 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1206 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1207 pts)))
 (union-points new-pts))))

(loading)

(set! t1204 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1205 pts))
 pts))

(loading)

(set! t1208 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1210 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1213 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1214 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1212 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1213 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1214 pts)))
 (union-points new-pts))))

(loading)

(set! t1211 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1212 pts))
 pts))

(loading)

(set! t1215 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1219 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1220 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1218 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1219 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1220 pts)))
 (union-points new-pts))))

(loading)

(set! t1223 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1224 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1222 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1223 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1224 pts)))
 (union-points new-pts))))

(loading)

(set! t1221 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1222 pts))
 pts))

(loading)

(set! t1225 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1227 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1231 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1232 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1230 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1231 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1232 pts)))
 (union-points new-pts))))

(loading)

(set! t1234 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1237 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1238 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1236 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1237 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1238 pts)))
 (union-points new-pts))))

(loading)

(set! t1235 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1236 pts))
 pts))

(loading)

(set! t1239 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1243 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1244 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1242 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1243 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1244 pts)))
 (union-points new-pts))))

(loading)

(set! t1241 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1242 pts))
 pts))

(loading)

(set! t1245 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1240 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1241 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1245 pts)))
 (union-points new-pts))))

(loading)

(set! t1233 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1234 pts))
 (set! pts (t1235 pts))
 (set! pts (t1239 pts))
 (set! pts (t1240 pts))
 pts))

(loading)

(set! t1229 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1230 pts))
 (set! pts (t1233 pts))
 pts))

(loading)

(set! t1246 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1228 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1229 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1246 pts)))
 (union-points new-pts))))

(loading)

(set! t1249 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1250 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1248 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1249 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1250 pts)))
 (union-points new-pts))))

(loading)

(set! t1247 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1248 pts))
 pts))

(loading)

(set! t1251 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1226 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1227 pts))
 (set! pts (t1228 pts))
 (set! pts (t1247 pts))
 (set! pts (t1251 pts))
 pts))

(loading)

(set! t1217 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1218 pts))
 (set! pts (t1221 pts))
 (set! pts (t1225 pts))
 (set! pts (t1226 pts))
 pts))

(loading)

(set! t1252 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1216 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1217 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1252 pts)))
 (union-points new-pts))))

(loading)

(set! t1255 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1256 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1254 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1255 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1256 pts)))
 (union-points new-pts))))

(loading)

(set! t1253 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1254 pts))
 pts))

(loading)

(set! t1209 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1210 pts))
 (set! pts (t1211 pts))
 (set! pts (t1215 pts))
 (set! pts (t1216 pts))
 (set! pts (t1253 pts))
 pts))

(loading)

(set! t1187 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1188 pts))
 (set! pts (t1189 pts))
 (set! pts (t1193 pts))
 (set! pts (t1194 pts))
 (set! pts (t1204 pts))
 (set! pts (t1208 pts))
 (set! pts (t1209 pts))
 pts))

(loading)

(set! t1183 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1184 pts))
 (set! pts (t1187 pts))
 pts))

(loading)

(set! t1257 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1182 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1183 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1257 pts)))
 (union-points new-pts))))

(loading)

(set! t1259 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1262 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1263 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1261 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1262 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1263 pts)))
 (union-points new-pts))))

(loading)

(set! t1260 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1261 pts))
 pts))

(loading)

(set! t1265 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1266 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1264 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1265 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1266 pts)))
 (union-points new-pts))))

(loading)

(set! t1269 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1270 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1268 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1269 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1270 pts)))
 (union-points new-pts))))

(loading)

(set! t1267 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1268 pts))
 pts))

(loading)

(set! t1271 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1274 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1275 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1273 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1274 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1275 pts)))
 (union-points new-pts))))

(loading)

(set! t1272 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1273 pts))
 pts))

(loading)

(set! t1258 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1259 pts))
 (set! pts (t1260 pts))
 (set! pts (t1264 pts))
 (set! pts (t1267 pts))
 (set! pts (t1271 pts))
 (set! pts (t1272 pts))
 pts))

(loading)

(set! t1180 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1181 pts))
 (set! pts (t1182 pts))
 (set! pts (t1258 pts))
 pts))

(loading)

(set! t1276 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1179 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1180 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1276 pts)))
 (union-points new-pts))))

(loading)

(set! t1279 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1280 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1278 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1279 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1280 pts)))
 (union-points new-pts))))

(loading)

(set! t1277 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1278 pts))
 pts))

(loading)

(set! t1177 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1178 pts))
 (set! pts (t1179 pts))
 (set! pts (t1277 pts))
 pts))

(loading)

(set! t1169 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1170 pts))
 (set! pts (t1171 pts))
 (set! pts (t1177 pts))
 pts))

(loading)

(set! t1165 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1166 pts))
 (set! pts (t1169 pts))
 pts))

(loading)

(set! t1281 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1164 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1165 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1281 pts)))
 (union-points new-pts))))

(loading)

(set! t1162 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1163 pts))
 (set! pts (t1164 pts))
 pts))

(loading)

(set! t1015 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1016 pts))
 (set! pts (t1017 pts))
 (set! pts (t1021 pts))
 (set! pts (t1022 pts))
 (set! pts (t1162 pts))
 pts))

(loading)

(set! t1011 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1012 pts))
 (set! pts (t1015 pts))
 pts))

(loading)

(set! t1282 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1010 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1011 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1282 pts)))
 (union-points new-pts))))

(loading)

(set! t1284 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1288 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1289 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1287 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1288 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1289 pts)))
 (union-points new-pts))))

(loading)

(set! t1286 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1287 pts))
 pts))

(loading)

(set! t1290 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1285 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1286 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1290 pts)))
 (union-points new-pts))))

(loading)

(set! t1283 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1284 pts))
 (set! pts (t1285 pts))
 pts))

(loading)

(set! t1008 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1009 pts))
 (set! pts (t1010 pts))
 (set! pts (t1283 pts))
 pts))

(loading)

(set! t1291 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1007 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1008 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1291 pts)))
 (union-points new-pts))))

(loading)

(set! t1005 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1006 pts))
 (set! pts (t1007 pts))
 pts))

(loading)

(set! t1292 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1004 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1005 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1292 pts)))
 (union-points new-pts))))

(loading)

(set! t997 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t998 pts))
 (set! pts (t999 pts))
 (set! pts (t1003 pts))
 (set! pts (t1004 pts))
 pts))

(loading)

(set! t993 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t994 pts))
 (set! pts (t997 pts))
 pts))

(loading)

(set! t1293 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t992 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t993 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1293 pts)))
 (union-points new-pts))))

(loading)

(set! t990 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t991 pts))
 (set! pts (t992 pts))
 pts))

(loading)

(set! t1294 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t989 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t990 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1294 pts)))
 (union-points new-pts))))

(loading)

(set! t987 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t988 pts))
 (set! pts (t989 pts))
 pts))

(loading)

(set! t983 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t984 pts))
 (set! pts (t987 pts))
 pts))

(loading)

(set! t1295 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t982 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t983 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1295 pts)))
 (union-points new-pts))))

(loading)

(set! t1298 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1299 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1297 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1298 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1299 pts)))
 (union-points new-pts))))

(loading)

(set! t1296 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1297 pts))
 pts))

(loading)

(set! t980 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t981 pts))
 (set! pts (t982 pts))
 (set! pts (t1296 pts))
 pts))

(loading)

(set! t967 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t968 pts))
 (set! pts (t969 pts))
 (set! pts (t973 pts))
 (set! pts (t974 pts))
 (set! pts (t980 pts))
 pts))

(loading)

(set! t1300 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t966 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t967 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1300 pts)))
 (union-points new-pts))))

(loading)

(set! t964 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t965 pts))
 (set! pts (t966 pts))
 pts))

(loading)

(set! t1301 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t963 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t964 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1301 pts)))
 (union-points new-pts))))

(loading)

(set! t961 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t962 pts))
 (set! pts (t963 pts))
 pts))

(loading)

(set! t1302 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t960 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t961 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1302 pts)))
 (union-points new-pts))))

(loading)

(set! t1304 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1307 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1310 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1311 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1309 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1310 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1311 pts)))
 (union-points new-pts))))

(loading)

(set! t1308 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1309 pts))
 pts))

(loading)

(set! t1312 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1315 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1316 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1314 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1315 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1316 pts)))
 (union-points new-pts))))

(loading)

(set! t1313 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1314 pts))
 pts))

(loading)

(set! t1317 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1321 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1322 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1320 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1321 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1322 pts)))
 (union-points new-pts))))

(loading)

(set! t1325 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1326 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1324 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1325 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1326 pts)))
 (union-points new-pts))))

(loading)

(set! t1329 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1330 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1328 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1329 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1330 pts)))
 (union-points new-pts))))

(loading)

(set! t1327 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1328 pts))
 pts))

(loading)

(set! t1331 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1334 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1336 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1337 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1335 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1336 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1337 pts)))
 (union-points new-pts))))

(loading)

(set! t1333 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1334 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1335 pts)))
 (union-points new-pts))))

(loading)

(set! t1332 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1333 pts))
 pts))

(loading)

(set! t1323 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1324 pts))
 (set! pts (t1327 pts))
 (set! pts (t1331 pts))
 (set! pts (t1332 pts))
 pts))

(loading)

(set! t1319 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1320 pts))
 (set! pts (t1323 pts))
 pts))

(loading)

(set! t1338 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1318 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1319 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1338 pts)))
 (union-points new-pts))))

(loading)

(set! t1306 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1307 pts))
 (set! pts (t1308 pts))
 (set! pts (t1312 pts))
 (set! pts (t1313 pts))
 (set! pts (t1317 pts))
 (set! pts (t1318 pts))
 pts))

(loading)

(set! t1339 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1305 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1306 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1339 pts)))
 (union-points new-pts))))

(loading)

(set! t1342 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1343 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1341 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1342 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1343 pts)))
 (union-points new-pts))))

(loading)

(set! t1340 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1341 pts))
 pts))

(loading)

(set! t1303 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1304 pts))
 (set! pts (t1305 pts))
 (set! pts (t1340 pts))
 pts))

(loading)

(set! t958 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t959 pts))
 (set! pts (t960 pts))
 (set! pts (t1303 pts))
 pts))

(loading)

(set! t1344 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t957 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t958 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1344 pts)))
 (union-points new-pts))))

(loading)

(set! t955 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t956 pts))
 (set! pts (t957 pts))
 pts))

(loading)

(set! t1345 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t954 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t955 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1345 pts)))
 (union-points new-pts))))

(loading)

(set! t952 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t953 pts))
 (set! pts (t954 pts))
 pts))

(loading)

(set! t948 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t949 pts))
 (set! pts (t952 pts))
 pts))

(loading)

(set! t1346 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t947 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t948 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1346 pts)))
 (union-points new-pts))))

(loading)

(set! t940 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t941 pts))
 (set! pts (t942 pts))
 (set! pts (t946 pts))
 (set! pts (t947 pts))
 pts))

(loading)

(set! t1347 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t939 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t940 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1347 pts)))
 (union-points new-pts))))

(loading)

(set! t1350 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1351 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1349 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1350 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1351 pts)))
 (union-points new-pts))))

(loading)

(set! t1348 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1349 pts))
 pts))

(loading)

(set! t932 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t933 pts))
 (set! pts (t934 pts))
 (set! pts (t938 pts))
 (set! pts (t939 pts))
 (set! pts (t1348 pts))
 pts))

(loading)

(set! t889 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t890 pts))
 (set! pts (t891 pts))
 (set! pts (t932 pts))
 pts))

(loading)

(set! t880 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t881 pts))
 (set! pts (t884 pts))
 (set! pts (t888 pts))
 (set! pts (t889 pts))
 pts))

(loading)

(set! t1352 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t879 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t880 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1352 pts)))
 (union-points new-pts))))

(loading)

(set! t877 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t878 pts))
 (set! pts (t879 pts))
 pts))

(loading)

(set! t869 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t870 pts))
 (set! pts (t871 pts))
 (set! pts (t877 pts))
 pts))

(loading)

(set! t764 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t765 pts))
 (set! pts (t766 pts))
 (set! pts (t869 pts))
 pts))

(loading)

(set! t1353 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t763 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t764 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1353 pts)))
 (union-points new-pts))))

(loading)

(set! t761 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t762 pts))
 (set! pts (t763 pts))
 pts))

(loading)

(set! t748 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t749 pts))
 (set! pts (t750 pts))
 (set! pts (t754 pts))
 (set! pts (t755 pts))
 (set! pts (t761 pts))
 pts))

(loading)

(set! t744 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t745 pts))
 (set! pts (t748 pts))
 pts))

(loading)

(set! t1354 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t743 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t744 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1354 pts)))
 (union-points new-pts))))

(loading)

(set! t1356 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1359 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1362 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1365 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1368 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1371 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1374 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1375 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1373 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1374 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1375 pts)))
 (union-points new-pts))))

(loading)

(set! t1372 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1373 pts))
 pts))

(loading)

(set! t1377 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1378 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1376 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1377 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1378 pts)))
 (union-points new-pts))))

(loading)

(set! t1380 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1383 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1386 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1390 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1391 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1389 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1390 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1391 pts)))
 (union-points new-pts))))

(loading)

(set! t1388 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1389 pts))
 pts))

(loading)

(set! t1392 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1387 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1388 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1392 pts)))
 (union-points new-pts))))

(loading)

(set! t1395 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1396 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1394 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1395 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1396 pts)))
 (union-points new-pts))))

(loading)

(set! t1393 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1394 pts))
 pts))

(loading)

(set! t1397 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1400 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1401 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1399 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1400 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1401 pts)))
 (union-points new-pts))))

(loading)

(set! t1404 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1405 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1403 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1404 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1405 pts)))
 (union-points new-pts))))

(loading)

(set! t1407 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1410 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1411 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1409 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1410 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1411 pts)))
 (union-points new-pts))))

(loading)

(set! t1408 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1409 pts))
 pts))

(loading)

(set! t1412 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1415 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1418 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1421 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1424 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1427 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1428 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1426 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1427 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1428 pts)))
 (union-points new-pts))))

(loading)

(set! t1425 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1426 pts))
 pts))

(loading)

(set! t1430 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1431 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1429 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1430 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1431 pts)))
 (union-points new-pts))))

(loading)

(set! t1434 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1435 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1433 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1434 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1435 pts)))
 (union-points new-pts))))

(loading)

(set! t1432 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1433 pts))
 pts))

(loading)

(set! t1436 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1438 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1442 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1443 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1441 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1442 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1443 pts)))
 (union-points new-pts))))

(loading)

(set! t1440 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1441 pts))
 pts))

(loading)

(set! t1444 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1439 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1440 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1444 pts)))
 (union-points new-pts))))

(loading)

(set! t1437 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1438 pts))
 (set! pts (t1439 pts))
 pts))

(loading)

(set! t1423 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1424 pts))
 (set! pts (t1425 pts))
 (set! pts (t1429 pts))
 (set! pts (t1432 pts))
 (set! pts (t1436 pts))
 (set! pts (t1437 pts))
 pts))

(loading)

(set! t1445 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1422 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1423 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1445 pts)))
 (union-points new-pts))))

(loading)

(set! t1420 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1421 pts))
 (set! pts (t1422 pts))
 pts))

(loading)

(set! t1446 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1419 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1420 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1446 pts)))
 (union-points new-pts))))

(loading)

(set! t1449 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1450 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1448 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1449 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1450 pts)))
 (union-points new-pts))))

(loading)

(set! t1452 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1455 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1458 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1459 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1457 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1458 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1459 pts)))
 (union-points new-pts))))

(loading)

(set! t1456 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1457 pts))
 pts))

(loading)

(set! t1460 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1464 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1465 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1463 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1464 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1465 pts)))
 (union-points new-pts))))

(loading)

(set! t1462 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1463 pts))
 pts))

(loading)

(set! t1466 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1461 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1462 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1466 pts)))
 (union-points new-pts))))

(loading)

(set! t1468 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1471 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1474 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1477 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1480 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1484 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1485 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1483 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1484 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1485 pts)))
 (union-points new-pts))))

(loading)

(set! t1487 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1490 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1491 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1489 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1490 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1491 pts)))
 (union-points new-pts))))

(loading)

(set! t1488 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1489 pts))
 pts))

(loading)

(set! t1492 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1495 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1496 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1494 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1495 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1496 pts)))
 (union-points new-pts))))

(loading)

(set! t1493 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1494 pts))
 pts))

(loading)

(set! t1497 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1500 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1501 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1499 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1500 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1501 pts)))
 (union-points new-pts))))

(loading)

(set! t1498 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1499 pts))
 pts))

(loading)

(set! t1502 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1505 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1508 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1512 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1513 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1511 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1512 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1513 pts)))
 (union-points new-pts))))

(loading)

(set! t1510 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1511 pts))
 pts))

(loading)

(set! t1514 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1509 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1510 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1514 pts)))
 (union-points new-pts))))

(loading)

(set! t1507 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1508 pts))
 (set! pts (t1509 pts))
 pts))

(loading)

(set! t1515 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1506 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1507 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1515 pts)))
 (union-points new-pts))))

(loading)

(set! t1518 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1519 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1517 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1518 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1519 pts)))
 (union-points new-pts))))

(loading)

(set! t1516 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1517 pts))
 pts))

(loading)

(set! t1504 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1505 pts))
 (set! pts (t1506 pts))
 (set! pts (t1516 pts))
 pts))

(loading)

(set! t1520 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1503 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1504 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1520 pts)))
 (union-points new-pts))))

(loading)

(set! t1522 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1525 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1526 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1524 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1525 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1526 pts)))
 (union-points new-pts))))

(loading)

(set! t1523 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1524 pts))
 pts))

(loading)

(set! t1528 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1529 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1527 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1528 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1529 pts)))
 (union-points new-pts))))

(loading)

(set! t1532 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1533 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1531 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1532 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1533 pts)))
 (union-points new-pts))))

(loading)

(set! t1530 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1531 pts))
 pts))

(loading)

(set! t1534 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1521 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1522 pts))
 (set! pts (t1523 pts))
 (set! pts (t1527 pts))
 (set! pts (t1530 pts))
 (set! pts (t1534 pts))
 pts))

(loading)

(set! t1486 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1487 pts))
 (set! pts (t1488 pts))
 (set! pts (t1492 pts))
 (set! pts (t1493 pts))
 (set! pts (t1497 pts))
 (set! pts (t1498 pts))
 (set! pts (t1502 pts))
 (set! pts (t1503 pts))
 (set! pts (t1521 pts))
 pts))

(loading)

(set! t1482 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1483 pts))
 (set! pts (t1486 pts))
 pts))

(loading)

(set! t1535 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1481 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1482 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1535 pts)))
 (union-points new-pts))))

(loading)

(set! t1537 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1540 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1541 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1539 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1540 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1541 pts)))
 (union-points new-pts))))

(loading)

(set! t1538 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1539 pts))
 pts))

(loading)

(set! t1543 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1544 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1542 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1543 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1544 pts)))
 (union-points new-pts))))

(loading)

(set! t1536 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1537 pts))
 (set! pts (t1538 pts))
 (set! pts (t1542 pts))
 pts))

(loading)

(set! t1479 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1480 pts))
 (set! pts (t1481 pts))
 (set! pts (t1536 pts))
 pts))

(loading)

(set! t1545 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1478 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1479 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1545 pts)))
 (union-points new-pts))))

(loading)

(set! t1476 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1477 pts))
 (set! pts (t1478 pts))
 pts))

(loading)

(set! t1546 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1475 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1476 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1546 pts)))
 (union-points new-pts))))

(loading)

(set! t1473 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1474 pts))
 (set! pts (t1475 pts))
 pts))

(loading)

(set! t1547 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1472 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1473 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1547 pts)))
 (union-points new-pts))))

(loading)

(set! t1470 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1471 pts))
 (set! pts (t1472 pts))
 pts))

(loading)

(set! t1548 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1469 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1470 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1548 pts)))
 (union-points new-pts))))

(loading)

(set! t1551 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1552 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1550 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1551 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1552 pts)))
 (union-points new-pts))))

(loading)

(set! t1549 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1550 pts))
 pts))

(loading)

(set! t1467 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1468 pts))
 (set! pts (t1469 pts))
 (set! pts (t1549 pts))
 pts))

(loading)

(set! t1454 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1455 pts))
 (set! pts (t1456 pts))
 (set! pts (t1460 pts))
 (set! pts (t1461 pts))
 (set! pts (t1467 pts))
 pts))

(loading)

(set! t1553 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1453 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1454 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1553 pts)))
 (union-points new-pts))))

(loading)

(set! t1451 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1452 pts))
 (set! pts (t1453 pts))
 pts))

(loading)

(set! t1447 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1448 pts))
 (set! pts (t1451 pts))
 pts))

(loading)

(set! t1417 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1418 pts))
 (set! pts (t1419 pts))
 (set! pts (t1447 pts))
 pts))

(loading)

(set! t1554 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1416 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1417 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1554 pts)))
 (union-points new-pts))))

(loading)

(set! t1556 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1560 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1561 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1559 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1560 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1561 pts)))
 (union-points new-pts))))

(loading)

(set! t1564 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1565 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1563 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1564 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1565 pts)))
 (union-points new-pts))))

(loading)

(set! t1568 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1569 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1567 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1568 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1569 pts)))
 (union-points new-pts))))

(loading)

(set! t1566 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1567 pts))
 pts))

(loading)

(set! t1570 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1572 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1575 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1576 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1574 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1575 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1576 pts)))
 (union-points new-pts))))

(loading)

(set! t1573 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1574 pts))
 pts))

(loading)

(set! t1577 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1581 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1582 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1580 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1581 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1582 pts)))
 (union-points new-pts))))

(loading)

(set! t1584 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1587 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1591 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1592 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1590 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1591 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1592 pts)))
 (union-points new-pts))))

(loading)

(set! t1594 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1597 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1600 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1603 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1606 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1607 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1605 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1606 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1607 pts)))
 (union-points new-pts))))

(loading)

(set! t1604 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1605 pts))
 pts))

(loading)

(set! t1608 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1611 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1614 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1617 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1618 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1616 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1617 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1618 pts)))
 (union-points new-pts))))

(loading)

(set! t1615 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1616 pts))
 pts))

(loading)

(set! t1620 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1621 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1619 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1620 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1621 pts)))
 (union-points new-pts))))

(loading)

(set! t1623 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1626 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1629 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1630 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1628 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1629 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1630 pts)))
 (union-points new-pts))))

(loading)

(set! t1627 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1628 pts))
 pts))

(loading)

(set! t1631 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1635 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1636 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1634 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1635 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1636 pts)))
 (union-points new-pts))))

(loading)

(set! t1638 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1641 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1645 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1646 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1644 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1645 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1646 pts)))
 (union-points new-pts))))

(loading)

(set! t1643 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1644 pts))
 pts))

(loading)

(set! t1647 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1642 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1643 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1647 pts)))
 (union-points new-pts))))

(loading)

(set! t1649 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1653 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1654 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1652 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1653 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1654 pts)))
 (union-points new-pts))))

(loading)

(set! t1656 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1659 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1662 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1666 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1667 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1665 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1666 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1667 pts)))
 (union-points new-pts))))

(loading)

(set! t1664 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1665 pts))
 pts))

(loading)

(set! t1668 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1663 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1664 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1668 pts)))
 (union-points new-pts))))

(loading)

(set! t1670 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1673 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1677 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1678 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1676 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1677 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1678 pts)))
 (union-points new-pts))))

(loading)

(set! t1680 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1684 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1685 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1683 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1684 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1685 pts)))
 (union-points new-pts))))

(loading)

(set! t1687 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1690 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1691 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1689 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1690 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1691 pts)))
 (union-points new-pts))))

(loading)

(set! t1688 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1689 pts))
 pts))

(loading)

(set! t1693 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1694 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1692 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1693 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1694 pts)))
 (union-points new-pts))))

(loading)

(set! t1696 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1700 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1701 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1699 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1700 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1701 pts)))
 (union-points new-pts))))

(loading)

(set! t1698 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1699 pts))
 pts))

(loading)

(set! t1702 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1697 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1698 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1702 pts)))
 (union-points new-pts))))

(loading)

(set! t1695 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1696 pts))
 (set! pts (t1697 pts))
 pts))

(loading)

(set! t1686 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1687 pts))
 (set! pts (t1688 pts))
 (set! pts (t1692 pts))
 (set! pts (t1695 pts))
 pts))

(loading)

(set! t1682 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1683 pts))
 (set! pts (t1686 pts))
 pts))

(loading)

(set! t1703 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1681 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1682 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1703 pts)))
 (union-points new-pts))))

(loading)

(set! t1679 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1680 pts))
 (set! pts (t1681 pts))
 pts))

(loading)

(set! t1675 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1676 pts))
 (set! pts (t1679 pts))
 pts))

(loading)

(set! t1704 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1674 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1675 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1704 pts)))
 (union-points new-pts))))

(loading)

(set! t1672 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1673 pts))
 (set! pts (t1674 pts))
 pts))

(loading)

(set! t1705 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1671 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1672 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1705 pts)))
 (union-points new-pts))))

(loading)

(set! t1669 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1670 pts))
 (set! pts (t1671 pts))
 pts))

(loading)

(set! t1661 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1662 pts))
 (set! pts (t1663 pts))
 (set! pts (t1669 pts))
 pts))

(loading)

(set! t1706 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1660 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1661 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1706 pts)))
 (union-points new-pts))))

(loading)

(set! t1658 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1659 pts))
 (set! pts (t1660 pts))
 pts))

(loading)

(set! t1707 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1657 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1658 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1707 pts)))
 (union-points new-pts))))

(loading)

(set! t1710 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1711 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1709 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1710 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1711 pts)))
 (union-points new-pts))))

(loading)

(set! t1708 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1709 pts))
 pts))

(loading)

(set! t1712 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1655 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1656 pts))
 (set! pts (t1657 pts))
 (set! pts (t1708 pts))
 (set! pts (t1712 pts))
 pts))

(loading)

(set! t1651 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1652 pts))
 (set! pts (t1655 pts))
 pts))

(loading)

(set! t1713 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1650 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1651 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1713 pts)))
 (union-points new-pts))))

(loading)

(set! t1715 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1718 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1719 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1717 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1718 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1719 pts)))
 (union-points new-pts))))

(loading)

(set! t1716 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1717 pts))
 pts))

(loading)

(set! t1720 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1724 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1725 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1723 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1724 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1725 pts)))
 (union-points new-pts))))

(loading)

(set! t1722 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1723 pts))
 pts))

(loading)

(set! t1726 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1721 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1722 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1726 pts)))
 (union-points new-pts))))

(loading)

(set! t1714 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1715 pts))
 (set! pts (t1716 pts))
 (set! pts (t1720 pts))
 (set! pts (t1721 pts))
 pts))

(loading)

(set! t1648 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1649 pts))
 (set! pts (t1650 pts))
 (set! pts (t1714 pts))
 pts))

(loading)

(set! t1640 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1641 pts))
 (set! pts (t1642 pts))
 (set! pts (t1648 pts))
 pts))

(loading)

(set! t1727 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1639 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1640 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1727 pts)))
 (union-points new-pts))))

(loading)

(set! t1730 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1731 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1729 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1730 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1731 pts)))
 (union-points new-pts))))

(loading)

(set! t1728 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1729 pts))
 pts))

(loading)

(set! t1732 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1734 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1738 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1739 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1737 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1738 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1739 pts)))
 (union-points new-pts))))

(loading)

(set! t1736 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1737 pts))
 pts))

(loading)

(set! t1740 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1735 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1736 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1740 pts)))
 (union-points new-pts))))

(loading)

(set! t1743 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1744 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1742 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1743 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1744 pts)))
 (union-points new-pts))))

(loading)

(set! t1741 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1742 pts))
 pts))

(loading)

(set! t1733 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1734 pts))
 (set! pts (t1735 pts))
 (set! pts (t1741 pts))
 pts))

(loading)

(set! t1637 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1638 pts))
 (set! pts (t1639 pts))
 (set! pts (t1728 pts))
 (set! pts (t1732 pts))
 (set! pts (t1733 pts))
 pts))

(loading)

(set! t1633 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1634 pts))
 (set! pts (t1637 pts))
 pts))

(loading)

(set! t1745 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1632 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1633 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1745 pts)))
 (union-points new-pts))))

(loading)

(set! t1625 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1626 pts))
 (set! pts (t1627 pts))
 (set! pts (t1631 pts))
 (set! pts (t1632 pts))
 pts))

(loading)

(set! t1746 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1624 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1625 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1746 pts)))
 (union-points new-pts))))

(loading)

(set! t1748 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1751 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1755 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1756 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1754 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1755 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1756 pts)))
 (union-points new-pts))))

(loading)

(set! t1759 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1760 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1758 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1759 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1760 pts)))
 (union-points new-pts))))

(loading)

(set! t1757 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1758 pts))
 pts))

(loading)

(set! t1753 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1754 pts))
 (set! pts (t1757 pts))
 pts))

(loading)

(set! t1761 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1752 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1753 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1761 pts)))
 (union-points new-pts))))

(loading)

(set! t1763 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1767 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1768 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1766 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1767 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1768 pts)))
 (union-points new-pts))))

(loading)

(set! t1770 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1774 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1775 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1773 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1774 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1775 pts)))
 (union-points new-pts))))

(loading)

(set! t1778 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1779 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1777 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1778 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1779 pts)))
 (union-points new-pts))))

(loading)

(set! t1782 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1783 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1781 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1782 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1783 pts)))
 (union-points new-pts))))

(loading)

(set! t1780 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1781 pts))
 pts))

(loading)

(set! t1784 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1786 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1789 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1792 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1795 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1799 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1800 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1798 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1799 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1800 pts)))
 (union-points new-pts))))

(loading)

(set! t1802 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1806 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1807 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1805 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1806 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1807 pts)))
 (union-points new-pts))))

(loading)

(set! t1804 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1805 pts))
 pts))

(loading)

(set! t1808 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1803 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1804 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1808 pts)))
 (union-points new-pts))))

(loading)

(set! t1811 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1812 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1810 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1811 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1812 pts)))
 (union-points new-pts))))

(loading)

(set! t1809 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1810 pts))
 pts))

(loading)

(set! t1801 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1802 pts))
 (set! pts (t1803 pts))
 (set! pts (t1809 pts))
 pts))

(loading)

(set! t1797 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1798 pts))
 (set! pts (t1801 pts))
 pts))

(loading)

(set! t1813 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1796 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1797 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1813 pts)))
 (union-points new-pts))))

(loading)

(set! t1815 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1818 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1819 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1817 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1818 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1819 pts)))
 (union-points new-pts))))

(loading)

(set! t1816 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1817 pts))
 pts))

(loading)

(set! t1820 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1824 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1825 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1823 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1824 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1825 pts)))
 (union-points new-pts))))

(loading)

(set! t1828 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1829 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1827 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1828 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1829 pts)))
 (union-points new-pts))))

(loading)

(set! t1832 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1833 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1831 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1832 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1833 pts)))
 (union-points new-pts))))

(loading)

(set! t1836 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1837 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1835 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1836 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1837 pts)))
 (union-points new-pts))))

(loading)

(set! t1834 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1835 pts))
 pts))

(loading)

(set! t1838 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1841 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1842 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1840 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1841 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1842 pts)))
 (union-points new-pts))))

(loading)

(set! t1844 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1848 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1849 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1847 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1848 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1849 pts)))
 (union-points new-pts))))

(loading)

(set! t1846 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1847 pts))
 pts))

(loading)

(set! t1850 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1845 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1846 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1850 pts)))
 (union-points new-pts))))

(loading)

(set! t1852 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1855 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1856 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1854 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1855 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1856 pts)))
 (union-points new-pts))))

(loading)

(set! t1853 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1854 pts))
 pts))

(loading)

(set! t1857 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1860 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1861 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1859 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1860 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1861 pts)))
 (union-points new-pts))))

(loading)

(set! t1858 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1859 pts))
 pts))

(loading)

(set! t1862 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1865 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1869 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1870 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1868 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1869 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1870 pts)))
 (union-points new-pts))))

(loading)

(set! t1872 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1875 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1878 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1881 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1884 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1887 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1891 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1892 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1890 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1891 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1892 pts)))
 (union-points new-pts))))

(loading)

(set! t1889 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1890 pts))
 pts))

(loading)

(set! t1893 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1888 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1889 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1893 pts)))
 (union-points new-pts))))

(loading)

(set! t1895 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1898 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1902 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1903 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1901 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1902 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1903 pts)))
 (union-points new-pts))))

(loading)

(set! t1905 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1908 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1909 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1907 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1908 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1909 pts)))
 (union-points new-pts))))

(loading)

(set! t1906 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1907 pts))
 pts))

(loading)

(set! t1910 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1914 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1915 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1913 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1914 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1915 pts)))
 (union-points new-pts))))

(loading)

(set! t1912 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1913 pts))
 pts))

(loading)

(set! t1916 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1911 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1912 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1916 pts)))
 (union-points new-pts))))

(loading)

(set! t1918 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1922 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1923 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1921 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1922 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1923 pts)))
 (union-points new-pts))))

(loading)

(set! t1920 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1921 pts))
 pts))

(loading)

(set! t1924 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1919 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1920 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1924 pts)))
 (union-points new-pts))))

(loading)

(set! t1927 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1928 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1926 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1927 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1928 pts)))
 (union-points new-pts))))

(loading)

(set! t1930 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1934 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1935 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1933 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1934 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1935 pts)))
 (union-points new-pts))))

(loading)

(set! t1932 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1933 pts))
 pts))

(loading)

(set! t1936 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1931 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1932 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1936 pts)))
 (union-points new-pts))))

(loading)

(set! t1938 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1941 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1944 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1947 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1950 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1954 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1955 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1953 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1954 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1955 pts)))
 (union-points new-pts))))

(loading)

(set! t1958 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1959 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1957 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1958 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1959 pts)))
 (union-points new-pts))))

(loading)

(set! t1962 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1963 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1961 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1962 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1963 pts)))
 (union-points new-pts))))

(loading)

(set! t1965 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1968 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1971 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1974 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1975 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1973 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1974 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1975 pts)))
 (union-points new-pts))))

(loading)

(set! t1972 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1973 pts))
 pts))

(loading)

(set! t1977 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1978 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1976 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1977 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1978 pts)))
 (union-points new-pts))))

(loading)

(set! t1970 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1971 pts))
 (set! pts (t1972 pts))
 (set! pts (t1976 pts))
 pts))

(loading)

(set! t1979 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1969 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1970 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1979 pts)))
 (union-points new-pts))))

(loading)

(set! t1982 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1983 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1981 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1982 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1983 pts)))
 (union-points new-pts))))

(loading)

(set! t1980 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1981 pts))
 pts))

(loading)

(set! t1967 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1968 pts))
 (set! pts (t1969 pts))
 (set! pts (t1980 pts))
 pts))

(loading)

(set! t1984 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1966 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1967 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1984 pts)))
 (union-points new-pts))))

(loading)

(set! t1986 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1989 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1992 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1993 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t1991 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1992 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1993 pts)))
 (union-points new-pts))))

(loading)

(set! t1990 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1991 pts))
 pts))

(loading)

(set! t1994 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1998 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1999 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1997 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1998 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1999 pts)))
 (union-points new-pts))))

(loading)

(set! t2002 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2003 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2001 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2002 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2003 pts)))
 (union-points new-pts))))

(loading)

(set! t2000 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2001 pts))
 pts))

(loading)

(set! t1996 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1997 pts))
 (set! pts (t2000 pts))
 pts))

(loading)

(set! t2004 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1995 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1996 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2004 pts)))
 (union-points new-pts))))

(loading)

(set! t2006 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2010 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2011 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2009 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2010 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2011 pts)))
 (union-points new-pts))))

(loading)

(set! t2008 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2009 pts))
 pts))

(loading)

(set! t2012 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2007 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2008 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2012 pts)))
 (union-points new-pts))))

(loading)

(set! t2005 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2006 pts))
 (set! pts (t2007 pts))
 pts))

(loading)

(set! t1988 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1989 pts))
 (set! pts (t1990 pts))
 (set! pts (t1994 pts))
 (set! pts (t1995 pts))
 (set! pts (t2005 pts))
 pts))

(loading)

(set! t2013 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1987 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1988 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2013 pts)))
 (union-points new-pts))))

(loading)

(set! t2016 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2017 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2015 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2016 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2017 pts)))
 (union-points new-pts))))

(loading)

(set! t2014 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2015 pts))
 pts))

(loading)

(set! t1985 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1986 pts))
 (set! pts (t1987 pts))
 (set! pts (t2014 pts))
 pts))

(loading)

(set! t1964 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1965 pts))
 (set! pts (t1966 pts))
 (set! pts (t1985 pts))
 pts))

(loading)

(set! t1960 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1961 pts))
 (set! pts (t1964 pts))
 pts))

(loading)

(set! t1956 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1957 pts))
 (set! pts (t1960 pts))
 pts))

(loading)

(set! t1952 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1953 pts))
 (set! pts (t1956 pts))
 pts))

(loading)

(set! t2018 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1951 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1952 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2018 pts)))
 (union-points new-pts))))

(loading)

(set! t2021 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2022 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2020 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2021 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2022 pts)))
 (union-points new-pts))))

(loading)

(set! t2019 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2020 pts))
 pts))

(loading)

(set! t2023 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2026 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2027 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2025 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2026 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2027 pts)))
 (union-points new-pts))))

(loading)

(set! t2024 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2025 pts))
 pts))

(loading)

(set! t2028 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2031 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2032 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2030 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2031 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2032 pts)))
 (union-points new-pts))))

(loading)

(set! t2034 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2037 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2040 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2041 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2039 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2040 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2041 pts)))
 (union-points new-pts))))

(loading)

(set! t2038 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2039 pts))
 pts))

(loading)

(set! t2042 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2045 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2048 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2051 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2055 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2056 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2054 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2055 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2056 pts)))
 (union-points new-pts))))

(loading)

(set! t2053 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2054 pts))
 pts))

(loading)

(set! t2057 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2052 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2053 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2057 pts)))
 (union-points new-pts))))

(loading)

(set! t2050 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2051 pts))
 (set! pts (t2052 pts))
 pts))

(loading)

(set! t2058 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2049 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2050 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2058 pts)))
 (union-points new-pts))))

(loading)

(set! t2060 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2064 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2065 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2063 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2064 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2065 pts)))
 (union-points new-pts))))

(loading)

(set! t2067 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2071 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2072 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2070 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2071 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2072 pts)))
 (union-points new-pts))))

(loading)

(set! t2074 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2077 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2080 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2083 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2084 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2082 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2083 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2084 pts)))
 (union-points new-pts))))

(loading)

(set! t2081 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2082 pts))
 pts))

(loading)

(set! t2085 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2089 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2090 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2088 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2089 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2090 pts)))
 (union-points new-pts))))

(loading)

(set! t2087 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2088 pts))
 pts))

(loading)

(set! t2091 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2086 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2087 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2091 pts)))
 (union-points new-pts))))

(loading)

(set! t2094 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2095 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2093 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2094 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2095 pts)))
 (union-points new-pts))))

(loading)

(set! t2092 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2093 pts))
 pts))

(loading)

(set! t2096 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2098 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2101 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2102 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2100 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2101 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2102 pts)))
 (union-points new-pts))))

(loading)

(set! t2099 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2100 pts))
 pts))

(loading)

(set! t2103 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2106 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2107 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2105 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2106 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2107 pts)))
 (union-points new-pts))))

(loading)

(set! t2104 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2105 pts))
 pts))

(loading)

(set! t2109 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2110 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2108 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2109 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2110 pts)))
 (union-points new-pts))))

(loading)

(set! t2097 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2098 pts))
 (set! pts (t2099 pts))
 (set! pts (t2103 pts))
 (set! pts (t2104 pts))
 (set! pts (t2108 pts))
 pts))

(loading)

(set! t2079 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2080 pts))
 (set! pts (t2081 pts))
 (set! pts (t2085 pts))
 (set! pts (t2086 pts))
 (set! pts (t2092 pts))
 (set! pts (t2096 pts))
 (set! pts (t2097 pts))
 pts))

(loading)

(set! t2111 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2078 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2079 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2111 pts)))
 (union-points new-pts))))

(loading)

(set! t2076 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2077 pts))
 (set! pts (t2078 pts))
 pts))

(loading)

(set! t2112 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2075 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2076 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2112 pts)))
 (union-points new-pts))))

(loading)

(set! t2115 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2116 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2114 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2115 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2116 pts)))
 (union-points new-pts))))

(loading)

(set! t2113 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2114 pts))
 pts))

(loading)

(set! t2073 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2074 pts))
 (set! pts (t2075 pts))
 (set! pts (t2113 pts))
 pts))

(loading)

(set! t2069 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2070 pts))
 (set! pts (t2073 pts))
 pts))

(loading)

(set! t2117 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2068 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2069 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2117 pts)))
 (union-points new-pts))))

(loading)

(set! t2119 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2123 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2124 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2122 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2123 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2124 pts)))
 (union-points new-pts))))

(loading)

(set! t2121 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2122 pts))
 pts))

(loading)

(set! t2125 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2120 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2121 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2125 pts)))
 (union-points new-pts))))

(loading)

(set! t2128 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2129 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2127 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2128 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2129 pts)))
 (union-points new-pts))))

(loading)

(set! t2126 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2127 pts))
 pts))

(loading)

(set! t2118 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2119 pts))
 (set! pts (t2120 pts))
 (set! pts (t2126 pts))
 pts))

(loading)

(set! t2066 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2067 pts))
 (set! pts (t2068 pts))
 (set! pts (t2118 pts))
 pts))

(loading)

(set! t2062 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2063 pts))
 (set! pts (t2066 pts))
 pts))

(loading)

(set! t2130 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2061 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2062 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2130 pts)))
 (union-points new-pts))))

(loading)

(set! t2132 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2135 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2136 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2134 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2135 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2136 pts)))
 (union-points new-pts))))

(loading)

(set! t2133 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2134 pts))
 pts))

(loading)

(set! t2138 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2139 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2137 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2138 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2139 pts)))
 (union-points new-pts))))

(loading)

(set! t2141 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2145 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2146 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2144 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2145 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2146 pts)))
 (union-points new-pts))))

(loading)

(set! t2149 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2152 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2155 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2156 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2154 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2155 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2156 pts)))
 (union-points new-pts))))

(loading)

(set! t2153 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2154 pts))
 pts))

(loading)

(set! t2157 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2160 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2161 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2159 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2160 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2161 pts)))
 (union-points new-pts))))

(loading)

(set! t2158 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2159 pts))
 pts))

(loading)

(set! t2162 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2165 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2168 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2169 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2167 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2168 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2169 pts)))
 (union-points new-pts))))

(loading)

(set! t2166 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2167 pts))
 pts))

(loading)

(set! t2170 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2173 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2174 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2172 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2173 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2174 pts)))
 (union-points new-pts))))

(loading)

(set! t2171 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2172 pts))
 pts))

(loading)

(set! t2176 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2177 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2175 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2176 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2177 pts)))
 (union-points new-pts))))

(loading)

(set! t2180 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2181 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2179 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2180 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2181 pts)))
 (union-points new-pts))))

(loading)

(set! t2183 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2187 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2188 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2186 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2187 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2188 pts)))
 (union-points new-pts))))

(loading)

(set! t2190 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2193 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2197 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2198 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2196 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2197 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2198 pts)))
 (union-points new-pts))))

(loading)

(set! t2195 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2196 pts))
 pts))

(loading)

(set! t2199 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2194 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2195 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2199 pts)))
 (union-points new-pts))))

(loading)

(set! t2201 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2204 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2205 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2203 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2204 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2205 pts)))
 (union-points new-pts))))

(loading)

(set! t2202 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2203 pts))
 pts))

(loading)

(set! t2206 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2209 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2212 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2216 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2217 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2215 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2216 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2217 pts)))
 (union-points new-pts))))

(loading)

(set! t2219 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2222 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2226 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2227 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2225 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2226 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2227 pts)))
 (union-points new-pts))))

(loading)

(set! t2230 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2231 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2229 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2230 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2231 pts)))
 (union-points new-pts))))

(loading)

(set! t2228 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2229 pts))
 pts))

(loading)

(set! t2232 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2224 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2225 pts))
 (set! pts (t2228 pts))
 (set! pts (t2232 pts))
 pts))

(loading)

(set! t2233 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2223 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2224 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2233 pts)))
 (union-points new-pts))))

(loading)

(set! t2221 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2222 pts))
 (set! pts (t2223 pts))
 pts))

(loading)

(set! t2234 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2220 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2221 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2234 pts)))
 (union-points new-pts))))

(loading)

(set! t2218 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2219 pts))
 (set! pts (t2220 pts))
 pts))

(loading)

(set! t2214 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2215 pts))
 (set! pts (t2218 pts))
 pts))

(loading)

(set! t2235 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2213 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2214 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2235 pts)))
 (union-points new-pts))))

(loading)

(set! t2238 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2239 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2237 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2238 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2239 pts)))
 (union-points new-pts))))

(loading)

(set! t2241 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2244 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2247 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2250 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2254 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2255 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2253 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2254 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2255 pts)))
 (union-points new-pts))))

(loading)

(set! t2252 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2253 pts))
 pts))

(loading)

(set! t2256 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2251 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2252 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2256 pts)))
 (union-points new-pts))))

(loading)

(set! t2258 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2261 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2264 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2265 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2263 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2264 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2265 pts)))
 (union-points new-pts))))

(loading)

(set! t2262 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2263 pts))
 pts))

(loading)

(set! t2266 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2269 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2270 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2268 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2269 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2270 pts)))
 (union-points new-pts))))

(loading)

(set! t2267 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2268 pts))
 pts))

(loading)

(set! t2271 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2274 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2277 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2280 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2283 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2284 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2282 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2283 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2284 pts)))
 (union-points new-pts))))

(loading)

(set! t2281 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2282 pts))
 pts))

(loading)

(set! t2286 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2287 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2285 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2286 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2287 pts)))
 (union-points new-pts))))

(loading)

(set! t2290 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2291 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2289 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2290 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2291 pts)))
 (union-points new-pts))))

(loading)

(set! t2288 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2289 pts))
 pts))

(loading)

(set! t2292 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2295 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2296 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2294 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2295 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2296 pts)))
 (union-points new-pts))))

(loading)

(set! t2293 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2294 pts))
 pts))

(loading)

(set! t2297 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2299 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2302 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2306 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2307 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2305 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2306 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2307 pts)))
 (union-points new-pts))))

(loading)

(set! t2309 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2312 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2315 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2319 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2320 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2318 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2319 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2320 pts)))
 (union-points new-pts))))

(loading)

(set! t2322 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2326 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2327 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2325 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2326 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2327 pts)))
 (union-points new-pts))))

(loading)

(set! t2330 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2331 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2329 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2330 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2331 pts)))
 (union-points new-pts))))

(loading)

(set! t2328 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2329 pts))
 pts))

(loading)

(set! t2332 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2334 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2337 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2338 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2336 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2337 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2338 pts)))
 (union-points new-pts))))

(loading)

(set! t2335 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2336 pts))
 pts))

(loading)

(set! t2340 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2341 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2339 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2340 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2341 pts)))
 (union-points new-pts))))

(loading)

(set! t2333 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2334 pts))
 (set! pts (t2335 pts))
 (set! pts (t2339 pts))
 pts))

(loading)

(set! t2324 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2325 pts))
 (set! pts (t2328 pts))
 (set! pts (t2332 pts))
 (set! pts (t2333 pts))
 pts))

(loading)

(set! t2342 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2323 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2324 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2342 pts)))
 (union-points new-pts))))

(loading)

(set! t2321 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2322 pts))
 (set! pts (t2323 pts))
 pts))

(loading)

(set! t2317 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2318 pts))
 (set! pts (t2321 pts))
 pts))

(loading)

(set! t2343 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2316 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2317 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2343 pts)))
 (union-points new-pts))))

(loading)

(set! t2345 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2348 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2351 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2352 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2350 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2351 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2352 pts)))
 (union-points new-pts))))

(loading)

(set! t2349 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2350 pts))
 pts))

(loading)

(set! t2354 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2355 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2353 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2354 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2355 pts)))
 (union-points new-pts))))

(loading)

(set! t2358 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2359 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2357 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2358 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2359 pts)))
 (union-points new-pts))))

(loading)

(set! t2356 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2357 pts))
 pts))

(loading)

(set! t2360 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2363 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2364 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2362 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2363 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2364 pts)))
 (union-points new-pts))))

(loading)

(set! t2361 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2362 pts))
 pts))

(loading)

(set! t2365 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2367 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2370 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2371 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2369 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2370 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2371 pts)))
 (union-points new-pts))))

(loading)

(set! t2368 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2369 pts))
 pts))

(loading)

(set! t2373 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2374 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2372 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2373 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2374 pts)))
 (union-points new-pts))))

(loading)

(set! t2376 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2380 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2381 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2379 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2380 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2381 pts)))
 (union-points new-pts))))

(loading)

(set! t2384 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2385 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2383 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2384 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2385 pts)))
 (union-points new-pts))))

(loading)

(set! t2387 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2391 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2392 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2390 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2391 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2392 pts)))
 (union-points new-pts))))

(loading)

(set! t2389 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2390 pts))
 pts))

(loading)

(set! t2393 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2388 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2389 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2393 pts)))
 (union-points new-pts))))

(loading)

(set! t2386 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2387 pts))
 (set! pts (t2388 pts))
 pts))

(loading)

(set! t2382 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2383 pts))
 (set! pts (t2386 pts))
 pts))

(loading)

(set! t2378 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2379 pts))
 (set! pts (t2382 pts))
 pts))

(loading)

(set! t2394 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2377 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2378 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2394 pts)))
 (union-points new-pts))))

(loading)

(set! t2397 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2398 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2396 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2397 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2398 pts)))
 (union-points new-pts))))

(loading)

(set! t2395 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2396 pts))
 pts))

(loading)

(set! t2399 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2375 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2376 pts))
 (set! pts (t2377 pts))
 (set! pts (t2395 pts))
 (set! pts (t2399 pts))
 pts))

(loading)

(set! t2366 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2367 pts))
 (set! pts (t2368 pts))
 (set! pts (t2372 pts))
 (set! pts (t2375 pts))
 pts))

(loading)

(set! t2347 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2348 pts))
 (set! pts (t2349 pts))
 (set! pts (t2353 pts))
 (set! pts (t2356 pts))
 (set! pts (t2360 pts))
 (set! pts (t2361 pts))
 (set! pts (t2365 pts))
 (set! pts (t2366 pts))
 pts))

(loading)

(set! t2400 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2346 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2347 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2400 pts)))
 (union-points new-pts))))

(loading)

(set! t2344 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2345 pts))
 (set! pts (t2346 pts))
 pts))

(loading)

(set! t2314 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2315 pts))
 (set! pts (t2316 pts))
 (set! pts (t2344 pts))
 pts))

(loading)

(set! t2401 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2313 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2314 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2401 pts)))
 (union-points new-pts))))

(loading)

(set! t2311 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2312 pts))
 (set! pts (t2313 pts))
 pts))

(loading)

(set! t2402 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2310 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2311 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2402 pts)))
 (union-points new-pts))))

(loading)

(set! t2308 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2309 pts))
 (set! pts (t2310 pts))
 pts))

(loading)

(set! t2304 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2305 pts))
 (set! pts (t2308 pts))
 pts))

(loading)

(set! t2403 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2303 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2304 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2403 pts)))
 (union-points new-pts))))

(loading)

(set! t2301 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2302 pts))
 (set! pts (t2303 pts))
 pts))

(loading)

(set! t2404 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2300 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2301 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2404 pts)))
 (union-points new-pts))))

(loading)

(set! t2406 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2410 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2411 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2409 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2410 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2411 pts)))
 (union-points new-pts))))

(loading)

(set! t2408 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2409 pts))
 pts))

(loading)

(set! t2412 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2407 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2408 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2412 pts)))
 (union-points new-pts))))

(loading)

(set! t2405 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2406 pts))
 (set! pts (t2407 pts))
 pts))

(loading)

(set! t2298 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2299 pts))
 (set! pts (t2300 pts))
 (set! pts (t2405 pts))
 pts))

(loading)

(set! t2279 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2280 pts))
 (set! pts (t2281 pts))
 (set! pts (t2285 pts))
 (set! pts (t2288 pts))
 (set! pts (t2292 pts))
 (set! pts (t2293 pts))
 (set! pts (t2297 pts))
 (set! pts (t2298 pts))
 pts))

(loading)

(set! t2413 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2278 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2279 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2413 pts)))
 (union-points new-pts))))

(loading)

(set! t2415 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2419 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2420 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2418 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2419 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2420 pts)))
 (union-points new-pts))))

(loading)

(set! t2417 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2418 pts))
 pts))

(loading)

(set! t2421 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2416 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2417 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2421 pts)))
 (union-points new-pts))))

(loading)

(set! t2424 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2425 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2423 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2424 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2425 pts)))
 (union-points new-pts))))

(loading)

(set! t2422 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2423 pts))
 pts))

(loading)

(set! t2426 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2429 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2430 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2428 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2429 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2430 pts)))
 (union-points new-pts))))

(loading)

(set! t2427 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2428 pts))
 pts))

(loading)

(set! t2431 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2414 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2415 pts))
 (set! pts (t2416 pts))
 (set! pts (t2422 pts))
 (set! pts (t2426 pts))
 (set! pts (t2427 pts))
 (set! pts (t2431 pts))
 pts))

(loading)

(set! t2276 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2277 pts))
 (set! pts (t2278 pts))
 (set! pts (t2414 pts))
 pts))

(loading)

(set! t2432 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2275 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2276 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2432 pts)))
 (union-points new-pts))))

(loading)

(set! t2435 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2436 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2434 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2435 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2436 pts)))
 (union-points new-pts))))

(loading)

(set! t2438 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2441 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2444 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2445 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2443 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2444 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2445 pts)))
 (union-points new-pts))))

(loading)

(set! t2442 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2443 pts))
 pts))

(loading)

(set! t2447 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2448 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2446 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2447 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2448 pts)))
 (union-points new-pts))))

(loading)

(set! t2450 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2453 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2456 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2460 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2461 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2459 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2460 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2461 pts)))
 (union-points new-pts))))

(loading)

(set! t2464 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2465 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2463 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2464 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2465 pts)))
 (union-points new-pts))))

(loading)

(set! t2462 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2463 pts))
 pts))

(loading)

(set! t2466 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2469 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2470 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2468 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2469 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2470 pts)))
 (union-points new-pts))))

(loading)

(set! t2473 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2474 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2472 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2473 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2474 pts)))
 (union-points new-pts))))

(loading)

(set! t2477 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2478 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2476 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2477 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2478 pts)))
 (union-points new-pts))))

(loading)

(set! t2480 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2483 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2486 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2489 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2490 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2488 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2489 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2490 pts)))
 (union-points new-pts))))

(loading)

(set! t2487 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2488 pts))
 pts))

(loading)

(set! t2491 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2494 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2498 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2499 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2497 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2498 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2499 pts)))
 (union-points new-pts))))

(loading)

(set! t2496 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2497 pts))
 pts))

(loading)

(set! t2500 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2495 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2496 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2500 pts)))
 (union-points new-pts))))

(loading)

(set! t2502 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2506 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2507 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2505 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2506 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2507 pts)))
 (union-points new-pts))))

(loading)

(set! t2504 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2505 pts))
 pts))

(loading)

(set! t2508 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2503 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2504 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2508 pts)))
 (union-points new-pts))))

(loading)

(set! t2511 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2512 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2510 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2511 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2512 pts)))
 (union-points new-pts))))

(loading)

(set! t2515 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2516 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2514 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2515 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2516 pts)))
 (union-points new-pts))))

(loading)

(set! t2519 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2520 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2518 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2519 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2520 pts)))
 (union-points new-pts))))

(loading)

(set! t2517 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2518 pts))
 pts))

(loading)

(set! t2521 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2524 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2525 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2523 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2524 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2525 pts)))
 (union-points new-pts))))

(loading)

(set! t2528 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2530 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2531 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2529 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2530 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2531 pts)))
 (union-points new-pts))))

(loading)

(set! t2527 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2528 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2529 pts)))
 (union-points new-pts))))

(loading)

(set! t2534 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2535 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2533 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2534 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2535 pts)))
 (union-points new-pts))))

(loading)

(set! t2537 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2541 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2542 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2540 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2541 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2542 pts)))
 (union-points new-pts))))

(loading)

(set! t2545 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2546 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2544 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2545 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2546 pts)))
 (union-points new-pts))))

(loading)

(set! t2549 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2550 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2548 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2549 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2550 pts)))
 (union-points new-pts))))

(loading)

(set! t2547 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2548 pts))
 pts))

(loading)

(set! t2551 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2553 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2557 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2558 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2556 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2557 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2558 pts)))
 (union-points new-pts))))

(loading)

(set! t2560 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2564 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2565 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2563 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2564 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2565 pts)))
 (union-points new-pts))))

(loading)

(set! t2562 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2563 pts))
 pts))

(loading)

(set! t2567 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2568 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2566 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2567 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2568 pts)))
 (union-points new-pts))))

(loading)

(set! t2561 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2562 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2566 pts)))
 (union-points new-pts))))

(loading)

(set! t2559 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2560 pts))
 (set! pts (t2561 pts))
 pts))

(loading)

(set! t2555 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2556 pts))
 (set! pts (t2559 pts))
 pts))

(loading)

(set! t2569 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2554 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2555 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2569 pts)))
 (union-points new-pts))))

(loading)

(set! t2552 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2553 pts))
 (set! pts (t2554 pts))
 pts))

(loading)

(set! t2543 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2544 pts))
 (set! pts (t2547 pts))
 (set! pts (t2551 pts))
 (set! pts (t2552 pts))
 pts))

(loading)

(set! t2539 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2540 pts))
 (set! pts (t2543 pts))
 pts))

(loading)

(set! t2570 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2538 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2539 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2570 pts)))
 (union-points new-pts))))

(loading)

(set! t2572 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2576 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2577 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2575 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2576 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2577 pts)))
 (union-points new-pts))))

(loading)

(set! t2579 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2582 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2585 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2586 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2584 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2585 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2586 pts)))
 (union-points new-pts))))

(loading)

(set! t2583 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2584 pts))
 pts))

(loading)

(set! t2588 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2589 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2587 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2588 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2589 pts)))
 (union-points new-pts))))

(loading)

(set! t2591 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2594 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2598 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2599 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2597 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2598 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2599 pts)))
 (union-points new-pts))))

(loading)

(set! t2596 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2597 pts))
 pts))

(loading)

(set! t2600 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2595 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2596 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2600 pts)))
 (union-points new-pts))))

(loading)

(set! t2602 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2605 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2606 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2604 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2605 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2606 pts)))
 (union-points new-pts))))

(loading)

(set! t2603 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2604 pts))
 pts))

(loading)

(set! t2607 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2610 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2613 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2617 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2618 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2616 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2617 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2618 pts)))
 (union-points new-pts))))

(loading)

(set! t2621 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2622 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2620 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2621 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2622 pts)))
 (union-points new-pts))))

(loading)

(set! t2625 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2626 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2624 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2625 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2626 pts)))
 (union-points new-pts))))

(loading)

(set! t2623 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2624 pts))
 pts))

(loading)

(set! t2627 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2630 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2631 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2629 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2630 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2631 pts)))
 (union-points new-pts))))

(loading)

(set! t2633 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2636 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2640 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2641 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2639 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2640 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2641 pts)))
 (union-points new-pts))))

(loading)

(set! t2643 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2646 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2649 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2650 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2648 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2649 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2650 pts)))
 (union-points new-pts))))

(loading)

(set! t2647 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2648 pts))
 pts))

(loading)

(set! t2651 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2654 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2657 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2661 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2662 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2660 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2661 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2662 pts)))
 (union-points new-pts))))

(loading)

(set! t2665 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2666 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2664 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2665 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2666 pts)))
 (union-points new-pts))))

(loading)

(set! t2669 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2670 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2668 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2669 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2670 pts)))
 (union-points new-pts))))

(loading)

(set! t2667 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2668 pts))
 pts))

(loading)

(set! t2663 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2664 pts))
 (set! pts (t2667 pts))
 pts))

(loading)

(set! t2659 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2660 pts))
 (set! pts (t2663 pts))
 pts))

(loading)

(set! t2671 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2658 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2659 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2671 pts)))
 (union-points new-pts))))

(loading)

(set! t2674 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2675 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2673 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2674 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2675 pts)))
 (union-points new-pts))))

(loading)

(set! t2672 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2673 pts))
 pts))

(loading)

(set! t2656 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2657 pts))
 (set! pts (t2658 pts))
 (set! pts (t2672 pts))
 pts))

(loading)

(set! t2676 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2655 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2656 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2676 pts)))
 (union-points new-pts))))

(loading)

(set! t2653 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2654 pts))
 (set! pts (t2655 pts))
 pts))

(loading)

(set! t2677 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2652 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2653 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2677 pts)))
 (union-points new-pts))))

(loading)

(set! t2645 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2646 pts))
 (set! pts (t2647 pts))
 (set! pts (t2651 pts))
 (set! pts (t2652 pts))
 pts))

(loading)

(set! t2678 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2644 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2645 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2678 pts)))
 (union-points new-pts))))

(loading)

(set! t2642 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2643 pts))
 (set! pts (t2644 pts))
 pts))

(loading)

(set! t2638 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2639 pts))
 (set! pts (t2642 pts))
 pts))

(loading)

(set! t2679 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2637 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2638 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2679 pts)))
 (union-points new-pts))))

(loading)

(set! t2682 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2683 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2681 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2682 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2683 pts)))
 (union-points new-pts))))

(loading)

(set! t2680 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2681 pts))
 pts))

(loading)

(set! t2684 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2635 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2636 pts))
 (set! pts (t2637 pts))
 (set! pts (t2680 pts))
 (set! pts (t2684 pts))
 pts))

(loading)

(set! t2685 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2634 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2635 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2685 pts)))
 (union-points new-pts))))

(loading)

(set! t2688 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2689 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2687 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2688 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2689 pts)))
 (union-points new-pts))))

(loading)

(set! t2686 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2687 pts))
 pts))

(loading)

(set! t2690 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2692 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2696 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2697 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2695 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2696 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2697 pts)))
 (union-points new-pts))))

(loading)

(set! t2700 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2701 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2699 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2700 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2701 pts)))
 (union-points new-pts))))

(loading)

(set! t2698 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2699 pts))
 pts))

(loading)

(set! t2702 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2705 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2706 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2704 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2705 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2706 pts)))
 (union-points new-pts))))

(loading)

(set! t2708 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2711 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2714 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2717 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2718 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2716 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2717 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2718 pts)))
 (union-points new-pts))))

(loading)

(set! t2715 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2716 pts))
 pts))

(loading)

(set! t2719 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2722 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2723 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2721 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2722 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2723 pts)))
 (union-points new-pts))))

(loading)

(set! t2720 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2721 pts))
 pts))

(loading)

(set! t2724 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2728 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2730 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2731 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2729 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2730 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2731 pts)))
 (union-points new-pts))))

(loading)

(set! t2727 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2728 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2729 pts)))
 (union-points new-pts))))

(loading)

(set! t2726 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2727 pts))
 pts))

(loading)

(set! t2732 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2725 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2726 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2732 pts)))
 (union-points new-pts))))

(loading)

(set! t2713 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2714 pts))
 (set! pts (t2715 pts))
 (set! pts (t2719 pts))
 (set! pts (t2720 pts))
 (set! pts (t2724 pts))
 (set! pts (t2725 pts))
 pts))

(loading)

(set! t2733 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2712 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2713 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2733 pts)))
 (union-points new-pts))))

(loading)

(set! t2710 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2711 pts))
 (set! pts (t2712 pts))
 pts))

(loading)

(set! t2734 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2709 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2710 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2734 pts)))
 (union-points new-pts))))

(loading)

(set! t2736 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2739 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2742 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2743 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2741 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2742 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2743 pts)))
 (union-points new-pts))))

(loading)

(set! t2740 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2741 pts))
 pts))

(loading)

(set! t2744 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2748 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2749 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2747 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2748 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2749 pts)))
 (union-points new-pts))))

(loading)

(set! t2751 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2754 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2757 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2760 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2763 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2766 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2767 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2765 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2766 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2767 pts)))
 (union-points new-pts))))

(loading)

(set! t2764 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2765 pts))
 pts))

(loading)

(set! t2768 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2772 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2773 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2771 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2772 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2773 pts)))
 (union-points new-pts))))

(loading)

(set! t2775 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2779 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2780 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2778 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2779 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2780 pts)))
 (union-points new-pts))))

(loading)

(set! t2782 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2785 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2786 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2784 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2785 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2786 pts)))
 (union-points new-pts))))

(loading)

(set! t2783 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2784 pts))
 pts))

(loading)

(set! t2788 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2789 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2787 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2788 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2789 pts)))
 (union-points new-pts))))

(loading)

(set! t2791 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2794 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2797 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2801 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2802 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2800 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2801 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2802 pts)))
 (union-points new-pts))))

(loading)

(set! t2805 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2806 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2804 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2805 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2806 pts)))
 (union-points new-pts))))

(loading)

(set! t2809 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2810 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2808 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2809 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2810 pts)))
 (union-points new-pts))))

(loading)

(set! t2807 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2808 pts))
 pts))

(loading)

(set! t2811 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2813 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2817 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2818 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2816 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2817 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2818 pts)))
 (union-points new-pts))))

(loading)

(set! t2821 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2822 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2820 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2821 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2822 pts)))
 (union-points new-pts))))

(loading)

(set! t2824 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2827 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2828 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2826 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2827 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2828 pts)))
 (union-points new-pts))))

(loading)

(set! t2825 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2826 pts))
 pts))

(loading)

(set! t2829 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2832 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2836 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2837 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2835 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2836 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2837 pts)))
 (union-points new-pts))))

(loading)

(set! t2834 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2835 pts))
 pts))

(loading)

(set! t2838 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2833 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2834 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2838 pts)))
 (union-points new-pts))))

(loading)

(set! t2841 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2842 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2840 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2841 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2842 pts)))
 (union-points new-pts))))

(loading)

(set! t2839 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2840 pts))
 pts))

(loading)

(set! t2843 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2845 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2848 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2851 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2854 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2857 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2858 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2856 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2857 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2858 pts)))
 (union-points new-pts))))

(loading)

(set! t2855 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2856 pts))
 pts))

(loading)

(set! t2859 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2862 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2863 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2861 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2862 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2863 pts)))
 (union-points new-pts))))

(loading)

(set! t2860 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2861 pts))
 pts))

(loading)

(set! t2864 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2867 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2870 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2873 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2874 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2872 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2873 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2874 pts)))
 (union-points new-pts))))

(loading)

(set! t2871 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2872 pts))
 pts))

(loading)

(set! t2875 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2878 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2881 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2884 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2888 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2889 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2887 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2888 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2889 pts)))
 (union-points new-pts))))

(loading)

(set! t2892 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2893 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2891 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2892 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2893 pts)))
 (union-points new-pts))))

(loading)

(set! t2895 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2899 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2900 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2898 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2899 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2900 pts)))
 (union-points new-pts))))

(loading)

(set! t2897 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2898 pts))
 pts))

(loading)

(set! t2901 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2896 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2897 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2901 pts)))
 (union-points new-pts))))

(loading)

(set! t2894 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2895 pts))
 (set! pts (t2896 pts))
 pts))

(loading)

(set! t2890 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2891 pts))
 (set! pts (t2894 pts))
 pts))

(loading)

(set! t2886 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2887 pts))
 (set! pts (t2890 pts))
 pts))

(loading)

(set! t2902 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2885 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2886 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2902 pts)))
 (union-points new-pts))))

(loading)

(set! t2883 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2884 pts))
 (set! pts (t2885 pts))
 pts))

(loading)

(set! t2903 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2882 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2883 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2903 pts)))
 (union-points new-pts))))

(loading)

(set! t2880 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2881 pts))
 (set! pts (t2882 pts))
 pts))

(loading)

(set! t2904 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2879 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2880 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2904 pts)))
 (union-points new-pts))))

(loading)

(set! t2907 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2911 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2912 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2910 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2911 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2912 pts)))
 (union-points new-pts))))

(loading)

(set! t2909 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2910 pts))
 pts))

(loading)

(set! t2913 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2908 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2909 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2913 pts)))
 (union-points new-pts))))

(loading)

(set! t2916 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2917 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2915 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2916 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2917 pts)))
 (union-points new-pts))))

(loading)

(set! t2914 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2915 pts))
 pts))

(loading)

(set! t2918 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2906 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2907 pts))
 (set! pts (t2908 pts))
 (set! pts (t2914 pts))
 (set! pts (t2918 pts))
 pts))

(loading)

(set! t2919 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2905 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2906 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2919 pts)))
 (union-points new-pts))))

(loading)

(set! t2877 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2878 pts))
 (set! pts (t2879 pts))
 (set! pts (t2905 pts))
 pts))

(loading)

(set! t2920 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2876 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2877 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2920 pts)))
 (union-points new-pts))))

(loading)

(set! t2922 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2925 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2928 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2932 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2933 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2931 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2932 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2933 pts)))
 (union-points new-pts))))

(loading)

(set! t2930 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2931 pts))
 pts))

(loading)

(set! t2934 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2929 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2930 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2934 pts)))
 (union-points new-pts))))

(loading)

(set! t2936 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2940 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2941 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2939 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2940 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2941 pts)))
 (union-points new-pts))))

(loading)

(set! t2938 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2939 pts))
 pts))

(loading)

(set! t2942 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2937 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2938 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2942 pts)))
 (union-points new-pts))))

(loading)

(set! t2945 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2946 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2944 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2945 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2946 pts)))
 (union-points new-pts))))

(loading)

(set! t2943 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2944 pts))
 pts))

(loading)

(set! t2935 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2936 pts))
 (set! pts (t2937 pts))
 (set! pts (t2943 pts))
 pts))

(loading)

(set! t2927 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2928 pts))
 (set! pts (t2929 pts))
 (set! pts (t2935 pts))
 pts))

(loading)

(set! t2947 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2926 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2927 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2947 pts)))
 (union-points new-pts))))

(loading)

(set! t2950 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2951 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2949 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2950 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2951 pts)))
 (union-points new-pts))))

(loading)

(set! t2954 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2955 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2953 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2954 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2955 pts)))
 (union-points new-pts))))

(loading)

(set! t2958 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2959 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2957 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2958 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2959 pts)))
 (union-points new-pts))))

(loading)

(set! t2962 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2963 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2961 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2962 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2963 pts)))
 (union-points new-pts))))

(loading)

(set! t2960 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2961 pts))
 pts))

(loading)

(set! t2956 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2957 pts))
 (set! pts (t2960 pts))
 pts))

(loading)

(set! t2952 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2953 pts))
 (set! pts (t2956 pts))
 pts))

(loading)

(set! t2948 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2949 pts))
 (set! pts (t2952 pts))
 pts))

(loading)

(set! t2924 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2925 pts))
 (set! pts (t2926 pts))
 (set! pts (t2948 pts))
 pts))

(loading)

(set! t2964 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2923 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2924 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2964 pts)))
 (union-points new-pts))))

(loading)

(set! t2921 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2922 pts))
 (set! pts (t2923 pts))
 pts))

(loading)

(set! t2869 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2870 pts))
 (set! pts (t2871 pts))
 (set! pts (t2875 pts))
 (set! pts (t2876 pts))
 (set! pts (t2921 pts))
 pts))

(loading)

(set! t2965 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2868 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2869 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2965 pts)))
 (union-points new-pts))))

(loading)

(set! t2968 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2969 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2967 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2968 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2969 pts)))
 (union-points new-pts))))

(loading)

(set! t2966 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2967 pts))
 pts))

(loading)

(set! t2970 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2973 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2974 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2972 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2973 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2974 pts)))
 (union-points new-pts))))

(loading)

(set! t2971 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2972 pts))
 pts))

(loading)

(set! t2975 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2977 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2980 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2983 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2986 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2987 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2985 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2986 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2987 pts)))
 (union-points new-pts))))

(loading)

(set! t2984 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2985 pts))
 pts))

(loading)

(set! t2988 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2991 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2992 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t2990 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2991 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2992 pts)))
 (union-points new-pts))))

(loading)

(set! t2989 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2990 pts))
 pts))

(loading)

(set! t2993 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2997 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2998 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2996 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2997 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2998 pts)))
 (union-points new-pts))))

(loading)

(set! t2995 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2996 pts))
 pts))

(loading)

(set! t2999 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2994 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2995 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2999 pts)))
 (union-points new-pts))))

(loading)

(set! t2982 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2983 pts))
 (set! pts (t2984 pts))
 (set! pts (t2988 pts))
 (set! pts (t2989 pts))
 (set! pts (t2993 pts))
 (set! pts (t2994 pts))
 pts))

(loading)

(set! t3000 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2981 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2982 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3000 pts)))
 (union-points new-pts))))

(loading)

(set! t3003 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3004 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3002 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3003 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3004 pts)))
 (union-points new-pts))))

(loading)

(set! t3001 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3002 pts))
 pts))

(loading)

(set! t3005 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2979 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2980 pts))
 (set! pts (t2981 pts))
 (set! pts (t3001 pts))
 (set! pts (t3005 pts))
 pts))

(loading)

(set! t3006 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2978 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2979 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3006 pts)))
 (union-points new-pts))))

(loading)

(set! t2976 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2977 pts))
 (set! pts (t2978 pts))
 pts))

(loading)

(set! t2866 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2867 pts))
 (set! pts (t2868 pts))
 (set! pts (t2966 pts))
 (set! pts (t2970 pts))
 (set! pts (t2971 pts))
 (set! pts (t2975 pts))
 (set! pts (t2976 pts))
 pts))

(loading)

(set! t3007 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2865 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2866 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3007 pts)))
 (union-points new-pts))))

(loading)

(set! t2853 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2854 pts))
 (set! pts (t2855 pts))
 (set! pts (t2859 pts))
 (set! pts (t2860 pts))
 (set! pts (t2864 pts))
 (set! pts (t2865 pts))
 pts))

(loading)

(set! t3008 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2852 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2853 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3008 pts)))
 (union-points new-pts))))

(loading)

(set! t3010 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3013 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3014 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3012 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3013 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3014 pts)))
 (union-points new-pts))))

(loading)

(set! t3011 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3012 pts))
 pts))

(loading)

(set! t3015 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3018 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3021 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3024 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3025 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3023 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3024 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3025 pts)))
 (union-points new-pts))))

(loading)

(set! t3022 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3023 pts))
 pts))

(loading)

(set! t3026 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3029 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3033 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3034 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3032 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3033 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3034 pts)))
 (union-points new-pts))))

(loading)

(set! t3036 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3039 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3042 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3045 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3046 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3044 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3045 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3046 pts)))
 (union-points new-pts))))

(loading)

(set! t3043 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3044 pts))
 pts))

(loading)

(set! t3048 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3049 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3047 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3048 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3049 pts)))
 (union-points new-pts))))

(loading)

(set! t3052 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3053 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3051 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3052 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3053 pts)))
 (union-points new-pts))))

(loading)

(set! t3055 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3058 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3061 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3062 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3060 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3061 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3062 pts)))
 (union-points new-pts))))

(loading)

(set! t3059 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3060 pts))
 pts))

(loading)

(set! t3064 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3065 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3063 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3064 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3065 pts)))
 (union-points new-pts))))

(loading)

(set! t3068 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3069 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3067 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3068 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3069 pts)))
 (union-points new-pts))))

(loading)

(set! t3066 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3067 pts))
 pts))

(loading)

(set! t3057 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3058 pts))
 (set! pts (t3059 pts))
 (set! pts (t3063 pts))
 (set! pts (t3066 pts))
 pts))

(loading)

(set! t3070 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3056 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3057 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3070 pts)))
 (union-points new-pts))))

(loading)

(set! t3054 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3055 pts))
 (set! pts (t3056 pts))
 pts))

(loading)

(set! t3050 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3051 pts))
 (set! pts (t3054 pts))
 pts))

(loading)

(set! t3041 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3042 pts))
 (set! pts (t3043 pts))
 (set! pts (t3047 pts))
 (set! pts (t3050 pts))
 pts))

(loading)

(set! t3071 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3040 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3041 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3071 pts)))
 (union-points new-pts))))

(loading)

(set! t3038 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3039 pts))
 (set! pts (t3040 pts))
 pts))

(loading)

(set! t3072 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3037 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3038 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3072 pts)))
 (union-points new-pts))))

(loading)

(set! t3035 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3036 pts))
 (set! pts (t3037 pts))
 pts))

(loading)

(set! t3031 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3032 pts))
 (set! pts (t3035 pts))
 pts))

(loading)

(set! t3073 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3030 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3031 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3073 pts)))
 (union-points new-pts))))

(loading)

(set! t3028 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3029 pts))
 (set! pts (t3030 pts))
 pts))

(loading)

(set! t3074 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3027 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3028 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3074 pts)))
 (union-points new-pts))))

(loading)

(set! t3076 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3079 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3080 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3078 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3079 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3080 pts)))
 (union-points new-pts))))

(loading)

(set! t3077 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3078 pts))
 pts))

(loading)

(set! t3082 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3083 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3081 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3082 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3083 pts)))
 (union-points new-pts))))

(loading)

(set! t3086 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3087 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3085 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3086 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3087 pts)))
 (union-points new-pts))))

(loading)

(set! t3084 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3085 pts))
 pts))

(loading)

(set! t3088 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3091 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3092 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3090 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3091 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3092 pts)))
 (union-points new-pts))))

(loading)

(set! t3089 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3090 pts))
 pts))

(loading)

(set! t3093 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3095 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3099 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3100 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3098 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3099 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3100 pts)))
 (union-points new-pts))))

(loading)

(set! t3097 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3098 pts))
 pts))

(loading)

(set! t3101 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3096 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3097 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3101 pts)))
 (union-points new-pts))))

(loading)

(set! t3104 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3105 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3103 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3104 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3105 pts)))
 (union-points new-pts))))

(loading)

(set! t3102 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3103 pts))
 pts))

(loading)

(set! t3106 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3109 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3110 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3108 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3109 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3110 pts)))
 (union-points new-pts))))

(loading)

(set! t3107 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3108 pts))
 pts))

(loading)

(set! t3111 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3113 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3117 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3118 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3116 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3117 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3118 pts)))
 (union-points new-pts))))

(loading)

(set! t3115 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3116 pts))
 pts))

(loading)

(set! t3119 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3114 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3115 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3119 pts)))
 (union-points new-pts))))

(loading)

(set! t3112 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3113 pts))
 (set! pts (t3114 pts))
 pts))

(loading)

(set! t3094 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3095 pts))
 (set! pts (t3096 pts))
 (set! pts (t3102 pts))
 (set! pts (t3106 pts))
 (set! pts (t3107 pts))
 (set! pts (t3111 pts))
 (set! pts (t3112 pts))
 pts))

(loading)

(set! t3075 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3076 pts))
 (set! pts (t3077 pts))
 (set! pts (t3081 pts))
 (set! pts (t3084 pts))
 (set! pts (t3088 pts))
 (set! pts (t3089 pts))
 (set! pts (t3093 pts))
 (set! pts (t3094 pts))
 pts))

(loading)

(set! t3020 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3021 pts))
 (set! pts (t3022 pts))
 (set! pts (t3026 pts))
 (set! pts (t3027 pts))
 (set! pts (t3075 pts))
 pts))

(loading)

(set! t3120 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3019 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3020 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3120 pts)))
 (union-points new-pts))))

(loading)

(set! t3017 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3018 pts))
 (set! pts (t3019 pts))
 pts))

(loading)

(set! t3121 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3016 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3017 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3121 pts)))
 (union-points new-pts))))

(loading)

(set! t3009 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3010 pts))
 (set! pts (t3011 pts))
 (set! pts (t3015 pts))
 (set! pts (t3016 pts))
 pts))

(loading)

(set! t2850 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2851 pts))
 (set! pts (t2852 pts))
 (set! pts (t3009 pts))
 pts))

(loading)

(set! t3122 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2849 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2850 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3122 pts)))
 (union-points new-pts))))

(loading)

(set! t2847 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2848 pts))
 (set! pts (t2849 pts))
 pts))

(loading)

(set! t3123 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2846 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2847 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3123 pts)))
 (union-points new-pts))))

(loading)

(set! t3126 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3127 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3125 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3126 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3127 pts)))
 (union-points new-pts))))

(loading)

(set! t3124 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3125 pts))
 pts))

(loading)

(set! t3128 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3130 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3134 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3135 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3133 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3134 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3135 pts)))
 (union-points new-pts))))

(loading)

(set! t3132 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3133 pts))
 pts))

(loading)

(set! t3136 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3131 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3132 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3136 pts)))
 (union-points new-pts))))

(loading)

(set! t3139 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3140 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3138 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3139 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3140 pts)))
 (union-points new-pts))))

(loading)

(set! t3137 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3138 pts))
 pts))

(loading)

(set! t3141 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3144 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3145 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3143 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3144 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3145 pts)))
 (union-points new-pts))))

(loading)

(set! t3142 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3143 pts))
 pts))

(loading)

(set! t3146 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3129 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3130 pts))
 (set! pts (t3131 pts))
 (set! pts (t3137 pts))
 (set! pts (t3141 pts))
 (set! pts (t3142 pts))
 (set! pts (t3146 pts))
 pts))

(loading)

(set! t2844 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2845 pts))
 (set! pts (t2846 pts))
 (set! pts (t3124 pts))
 (set! pts (t3128 pts))
 (set! pts (t3129 pts))
 pts))

(loading)

(set! t2831 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2832 pts))
 (set! pts (t2833 pts))
 (set! pts (t2839 pts))
 (set! pts (t2843 pts))
 (set! pts (t2844 pts))
 pts))

(loading)

(set! t3147 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2830 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2831 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3147 pts)))
 (union-points new-pts))))

(loading)

(set! t2823 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2824 pts))
 (set! pts (t2825 pts))
 (set! pts (t2829 pts))
 (set! pts (t2830 pts))
 pts))

(loading)

(set! t2819 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2820 pts))
 (set! pts (t2823 pts))
 pts))

(loading)

(set! t2815 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2816 pts))
 (set! pts (t2819 pts))
 pts))

(loading)

(set! t3148 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2814 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2815 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3148 pts)))
 (union-points new-pts))))

(loading)

(set! t3151 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3152 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3150 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3151 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3152 pts)))
 (union-points new-pts))))

(loading)

(set! t3154 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3158 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3159 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3157 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3158 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3159 pts)))
 (union-points new-pts))))

(loading)

(set! t3156 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3157 pts))
 pts))

(loading)

(set! t3160 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3155 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3156 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3160 pts)))
 (union-points new-pts))))

(loading)

(set! t3162 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3166 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3167 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3165 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3166 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3167 pts)))
 (union-points new-pts))))

(loading)

(set! t3164 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3165 pts))
 pts))

(loading)

(set! t3168 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3163 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3164 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3168 pts)))
 (union-points new-pts))))

(loading)

(set! t3171 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3172 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3170 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3171 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3172 pts)))
 (union-points new-pts))))

(loading)

(set! t3175 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3176 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3174 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3175 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3176 pts)))
 (union-points new-pts))))

(loading)

(set! t3178 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3181 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3184 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3187 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3191 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3192 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3190 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3191 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3192 pts)))
 (union-points new-pts))))

(loading)

(set! t3194 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3197 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3200 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3201 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3199 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3200 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3201 pts)))
 (union-points new-pts))))

(loading)

(set! t3198 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3199 pts))
 pts))

(loading)

(set! t3202 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3205 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3206 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3204 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3205 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3206 pts)))
 (union-points new-pts))))

(loading)

(set! t3203 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3204 pts))
 pts))

(loading)

(set! t3207 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3211 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3212 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3210 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3211 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3212 pts)))
 (union-points new-pts))))

(loading)

(set! t3209 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3210 pts))
 pts))

(loading)

(set! t3213 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3208 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3209 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3213 pts)))
 (union-points new-pts))))

(loading)

(set! t3196 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3197 pts))
 (set! pts (t3198 pts))
 (set! pts (t3202 pts))
 (set! pts (t3203 pts))
 (set! pts (t3207 pts))
 (set! pts (t3208 pts))
 pts))

(loading)

(set! t3214 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3195 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3196 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3214 pts)))
 (union-points new-pts))))

(loading)

(set! t3217 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3218 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3216 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3217 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3218 pts)))
 (union-points new-pts))))

(loading)

(set! t3215 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3216 pts))
 pts))

(loading)

(set! t3219 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3222 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3223 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3221 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3222 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3223 pts)))
 (union-points new-pts))))

(loading)

(set! t3220 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3221 pts))
 pts))

(loading)

(set! t3193 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3194 pts))
 (set! pts (t3195 pts))
 (set! pts (t3215 pts))
 (set! pts (t3219 pts))
 (set! pts (t3220 pts))
 pts))

(loading)

(set! t3189 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3190 pts))
 (set! pts (t3193 pts))
 pts))

(loading)

(set! t3224 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3188 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3189 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3224 pts)))
 (union-points new-pts))))

(loading)

(set! t3226 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3229 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3230 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3228 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3229 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3230 pts)))
 (union-points new-pts))))

(loading)

(set! t3227 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3228 pts))
 pts))

(loading)

(set! t3232 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3233 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3231 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3232 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3233 pts)))
 (union-points new-pts))))

(loading)

(set! t3225 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3226 pts))
 (set! pts (t3227 pts))
 (set! pts (t3231 pts))
 pts))

(loading)

(set! t3186 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3187 pts))
 (set! pts (t3188 pts))
 (set! pts (t3225 pts))
 pts))

(loading)

(set! t3234 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3185 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3186 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3234 pts)))
 (union-points new-pts))))

(loading)

(set! t3237 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3238 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3236 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3237 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3238 pts)))
 (union-points new-pts))))

(loading)

(set! t3235 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3236 pts))
 pts))

(loading)

(set! t3183 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3184 pts))
 (set! pts (t3185 pts))
 (set! pts (t3235 pts))
 pts))

(loading)

(set! t3239 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3182 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3183 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3239 pts)))
 (union-points new-pts))))

(loading)

(set! t3242 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3243 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3241 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3242 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3243 pts)))
 (union-points new-pts))))

(loading)

(set! t3246 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3247 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3245 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3246 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3247 pts)))
 (union-points new-pts))))

(loading)

(set! t3244 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3245 pts))
 pts))

(loading)

(set! t3240 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3241 pts))
 (set! pts (t3244 pts))
 pts))

(loading)

(set! t3180 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3181 pts))
 (set! pts (t3182 pts))
 (set! pts (t3240 pts))
 pts))

(loading)

(set! t3248 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3179 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3180 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3248 pts)))
 (union-points new-pts))))

(loading)

(set! t3177 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3178 pts))
 (set! pts (t3179 pts))
 pts))

(loading)

(set! t3173 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3174 pts))
 (set! pts (t3177 pts))
 pts))

(loading)

(set! t3169 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3170 pts))
 (set! pts (t3173 pts))
 pts))

(loading)

(set! t3161 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3162 pts))
 (set! pts (t3163 pts))
 (set! pts (t3169 pts))
 pts))

(loading)

(set! t3153 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3154 pts))
 (set! pts (t3155 pts))
 (set! pts (t3161 pts))
 pts))

(loading)

(set! t3149 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3150 pts))
 (set! pts (t3153 pts))
 pts))

(loading)

(set! t2812 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2813 pts))
 (set! pts (t2814 pts))
 (set! pts (t3149 pts))
 pts))

(loading)

(set! t2803 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2804 pts))
 (set! pts (t2807 pts))
 (set! pts (t2811 pts))
 (set! pts (t2812 pts))
 pts))

(loading)

(set! t2799 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2800 pts))
 (set! pts (t2803 pts))
 pts))

(loading)

(set! t3249 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2798 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2799 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3249 pts)))
 (union-points new-pts))))

(loading)

(set! t3252 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3253 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3251 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3252 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3253 pts)))
 (union-points new-pts))))

(loading)

(set! t3250 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3251 pts))
 pts))

(loading)

(set! t3254 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3257 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3258 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3256 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3257 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3258 pts)))
 (union-points new-pts))))

(loading)

(set! t3255 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3256 pts))
 pts))

(loading)

(set! t2796 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2797 pts))
 (set! pts (t2798 pts))
 (set! pts (t3250 pts))
 (set! pts (t3254 pts))
 (set! pts (t3255 pts))
 pts))

(loading)

(set! t3259 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2795 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2796 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3259 pts)))
 (union-points new-pts))))

(loading)

(set! t2793 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2794 pts))
 (set! pts (t2795 pts))
 pts))

(loading)

(set! t3260 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2792 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2793 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3260 pts)))
 (union-points new-pts))))

(loading)

(set! t2790 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2791 pts))
 (set! pts (t2792 pts))
 pts))

(loading)

(set! t2781 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2782 pts))
 (set! pts (t2783 pts))
 (set! pts (t2787 pts))
 (set! pts (t2790 pts))
 pts))

(loading)

(set! t2777 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2778 pts))
 (set! pts (t2781 pts))
 pts))

(loading)

(set! t3261 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2776 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2777 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3261 pts)))
 (union-points new-pts))))

(loading)

(set! t2774 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2775 pts))
 (set! pts (t2776 pts))
 pts))

(loading)

(set! t2770 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2771 pts))
 (set! pts (t2774 pts))
 pts))

(loading)

(set! t3262 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2769 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2770 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3262 pts)))
 (union-points new-pts))))

(loading)

(set! t3265 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3266 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3264 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3265 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3266 pts)))
 (union-points new-pts))))

(loading)

(set! t3268 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3271 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3274 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3275 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3273 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3274 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3275 pts)))
 (union-points new-pts))))

(loading)

(set! t3272 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3273 pts))
 pts))

(loading)

(set! t3276 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3279 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3280 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3278 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3279 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3280 pts)))
 (union-points new-pts))))

(loading)

(set! t3277 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3278 pts))
 pts))

(loading)

(set! t3281 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3284 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3287 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3290 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3291 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3289 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3290 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3291 pts)))
 (union-points new-pts))))

(loading)

(set! t3288 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3289 pts))
 pts))

(loading)

(set! t3292 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3296 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3297 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3295 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3296 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3297 pts)))
 (union-points new-pts))))

(loading)

(set! t3299 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3302 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3303 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3301 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3302 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3303 pts)))
 (union-points new-pts))))

(loading)

(set! t3300 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3301 pts))
 pts))

(loading)

(set! t3305 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3306 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3304 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3305 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3306 pts)))
 (union-points new-pts))))

(loading)

(set! t3308 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3311 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3312 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3310 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3311 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3312 pts)))
 (union-points new-pts))))

(loading)

(set! t3309 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3310 pts))
 pts))

(loading)

(set! t3313 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3317 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3318 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3316 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3317 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3318 pts)))
 (union-points new-pts))))

(loading)

(set! t3315 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3316 pts))
 pts))

(loading)

(set! t3319 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3314 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3315 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3319 pts)))
 (union-points new-pts))))

(loading)

(set! t3321 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3324 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3327 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3330 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3331 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3329 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3330 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3331 pts)))
 (union-points new-pts))))

(loading)

(set! t3328 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3329 pts))
 pts))

(loading)

(set! t3335 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3336 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3334 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3335 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3336 pts)))
 (union-points new-pts))))

(loading)

(set! t3333 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3334 pts))
 pts))

(loading)

(set! t3337 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3332 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3333 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3337 pts)))
 (union-points new-pts))))

(loading)

(set! t3339 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3343 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3344 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3342 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3343 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3344 pts)))
 (union-points new-pts))))

(loading)

(set! t3347 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3348 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3346 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3347 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3348 pts)))
 (union-points new-pts))))

(loading)

(set! t3351 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3352 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3350 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3351 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3352 pts)))
 (union-points new-pts))))

(loading)

(set! t3349 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3350 pts))
 pts))

(loading)

(set! t3345 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3346 pts))
 (set! pts (t3349 pts))
 pts))

(loading)

(set! t3341 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3342 pts))
 (set! pts (t3345 pts))
 pts))

(loading)

(set! t3353 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3340 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3341 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3353 pts)))
 (union-points new-pts))))

(loading)

(set! t3355 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3358 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3361 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3362 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3360 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3361 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3362 pts)))
 (union-points new-pts))))

(loading)

(set! t3359 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3360 pts))
 pts))

(loading)

(set! t3363 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3366 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3370 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3371 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3369 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3370 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3371 pts)))
 (union-points new-pts))))

(loading)

(set! t3368 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3369 pts))
 pts))

(loading)

(set! t3372 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3367 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3368 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3372 pts)))
 (union-points new-pts))))

(loading)

(set! t3365 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3366 pts))
 (set! pts (t3367 pts))
 pts))

(loading)

(set! t3373 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3364 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3365 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3373 pts)))
 (union-points new-pts))))

(loading)

(set! t3357 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3358 pts))
 (set! pts (t3359 pts))
 (set! pts (t3363 pts))
 (set! pts (t3364 pts))
 pts))

(loading)

(set! t3374 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3356 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3357 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3374 pts)))
 (union-points new-pts))))

(loading)

(set! t3354 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3355 pts))
 (set! pts (t3356 pts))
 pts))

(loading)

(set! t3338 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3339 pts))
 (set! pts (t3340 pts))
 (set! pts (t3354 pts))
 pts))

(loading)

(set! t3326 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3327 pts))
 (set! pts (t3328 pts))
 (set! pts (t3332 pts))
 (set! pts (t3338 pts))
 pts))

(loading)

(set! t3375 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3325 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3326 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3375 pts)))
 (union-points new-pts))))

(loading)

(set! t3377 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3381 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3382 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3380 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3381 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3382 pts)))
 (union-points new-pts))))

(loading)

(set! t3379 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3380 pts))
 pts))

(loading)

(set! t3383 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3378 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3379 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3383 pts)))
 (union-points new-pts))))

(loading)

(set! t3386 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3387 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3385 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3386 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3387 pts)))
 (union-points new-pts))))

(loading)

(set! t3384 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3385 pts))
 pts))

(loading)

(set! t3388 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3390 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3393 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3397 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3398 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3396 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3397 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3398 pts)))
 (union-points new-pts))))

(loading)

(set! t3400 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3403 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3406 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3407 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3405 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3406 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3407 pts)))
 (union-points new-pts))))

(loading)

(set! t3404 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3405 pts))
 pts))

(loading)

(set! t3409 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3410 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3408 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3409 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3410 pts)))
 (union-points new-pts))))

(loading)

(set! t3402 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3403 pts))
 (set! pts (t3404 pts))
 (set! pts (t3408 pts))
 pts))

(loading)

(set! t3411 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3401 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3402 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3411 pts)))
 (union-points new-pts))))

(loading)

(set! t3413 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3416 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3417 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3415 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3416 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3417 pts)))
 (union-points new-pts))))

(loading)

(set! t3414 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3415 pts))
 pts))

(loading)

(set! t3418 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3421 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3424 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3425 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3423 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3424 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3425 pts)))
 (union-points new-pts))))

(loading)

(set! t3422 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3423 pts))
 pts))

(loading)

(set! t3427 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3428 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3426 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3427 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3428 pts)))
 (union-points new-pts))))

(loading)

(set! t3420 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3421 pts))
 (set! pts (t3422 pts))
 (set! pts (t3426 pts))
 pts))

(loading)

(set! t3429 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3419 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3420 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3429 pts)))
 (union-points new-pts))))

(loading)

(set! t3431 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3434 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3437 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3438 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3436 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3437 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3438 pts)))
 (union-points new-pts))))

(loading)

(set! t3435 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3436 pts))
 pts))

(loading)

(set! t3440 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3441 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3439 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3440 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3441 pts)))
 (union-points new-pts))))

(loading)

(set! t3444 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3445 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3443 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3444 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3445 pts)))
 (union-points new-pts))))

(loading)

(set! t3442 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3443 pts))
 pts))

(loading)

(set! t3446 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3449 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3450 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3448 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3449 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3450 pts)))
 (union-points new-pts))))

(loading)

(set! t3447 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3448 pts))
 pts))

(loading)

(set! t3433 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3434 pts))
 (set! pts (t3435 pts))
 (set! pts (t3439 pts))
 (set! pts (t3442 pts))
 (set! pts (t3446 pts))
 (set! pts (t3447 pts))
 pts))

(loading)

(set! t3451 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3432 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3433 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3451 pts)))
 (union-points new-pts))))

(loading)

(set! t3454 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3455 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3453 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3454 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3455 pts)))
 (union-points new-pts))))

(loading)

(set! t3452 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3453 pts))
 pts))

(loading)

(set! t3456 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3430 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3431 pts))
 (set! pts (t3432 pts))
 (set! pts (t3452 pts))
 (set! pts (t3456 pts))
 pts))

(loading)

(set! t3412 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3413 pts))
 (set! pts (t3414 pts))
 (set! pts (t3418 pts))
 (set! pts (t3419 pts))
 (set! pts (t3430 pts))
 pts))

(loading)

(set! t3399 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3400 pts))
 (set! pts (t3401 pts))
 (set! pts (t3412 pts))
 pts))

(loading)

(set! t3395 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3396 pts))
 (set! pts (t3399 pts))
 pts))

(loading)

(set! t3457 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3394 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3395 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3457 pts)))
 (union-points new-pts))))

(loading)

(set! t3459 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3463 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3464 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3462 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3463 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3464 pts)))
 (union-points new-pts))))

(loading)

(set! t3467 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3468 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3466 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3467 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3468 pts)))
 (union-points new-pts))))

(loading)

(set! t3470 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3473 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3474 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3472 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3473 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3474 pts)))
 (union-points new-pts))))

(loading)

(set! t3471 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3472 pts))
 pts))

(loading)

(set! t3475 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3479 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3480 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3478 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3479 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3480 pts)))
 (union-points new-pts))))

(loading)

(set! t3477 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3478 pts))
 pts))

(loading)

(set! t3481 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3476 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3477 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3481 pts)))
 (union-points new-pts))))

(loading)

(set! t3484 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3485 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3483 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3484 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3485 pts)))
 (union-points new-pts))))

(loading)

(set! t3482 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3483 pts))
 pts))

(loading)

(set! t3486 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3489 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3490 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3488 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3489 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3490 pts)))
 (union-points new-pts))))

(loading)

(set! t3487 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3488 pts))
 pts))

(loading)

(set! t3469 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3470 pts))
 (set! pts (t3471 pts))
 (set! pts (t3475 pts))
 (set! pts (t3476 pts))
 (set! pts (t3482 pts))
 (set! pts (t3486 pts))
 (set! pts (t3487 pts))
 pts))

(loading)

(set! t3465 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3466 pts))
 (set! pts (t3469 pts))
 pts))

(loading)

(set! t3461 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3462 pts))
 (set! pts (t3465 pts))
 pts))

(loading)

(set! t3491 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3460 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3461 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3491 pts)))
 (union-points new-pts))))

(loading)

(set! t3494 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3495 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3493 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3494 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3495 pts)))
 (union-points new-pts))))

(loading)

(set! t3492 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3493 pts))
 pts))

(loading)

(set! t3458 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3459 pts))
 (set! pts (t3460 pts))
 (set! pts (t3492 pts))
 pts))

(loading)

(set! t3392 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3393 pts))
 (set! pts (t3394 pts))
 (set! pts (t3458 pts))
 pts))

(loading)

(set! t3496 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3391 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3392 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3496 pts)))
 (union-points new-pts))))

(loading)

(set! t3389 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3390 pts))
 (set! pts (t3391 pts))
 pts))

(loading)

(set! t3376 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3377 pts))
 (set! pts (t3378 pts))
 (set! pts (t3384 pts))
 (set! pts (t3388 pts))
 (set! pts (t3389 pts))
 pts))

(loading)

(set! t3323 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3324 pts))
 (set! pts (t3325 pts))
 (set! pts (t3376 pts))
 pts))

(loading)

(set! t3497 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3322 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3323 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3497 pts)))
 (union-points new-pts))))

(loading)

(set! t3320 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3321 pts))
 (set! pts (t3322 pts))
 pts))

(loading)

(set! t3307 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3308 pts))
 (set! pts (t3309 pts))
 (set! pts (t3313 pts))
 (set! pts (t3314 pts))
 (set! pts (t3320 pts))
 pts))

(loading)

(set! t3298 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3299 pts))
 (set! pts (t3300 pts))
 (set! pts (t3304 pts))
 (set! pts (t3307 pts))
 pts))

(loading)

(set! t3294 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3295 pts))
 (set! pts (t3298 pts))
 pts))

(loading)

(set! t3498 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3293 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3294 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3498 pts)))
 (union-points new-pts))))

(loading)

(set! t3286 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3287 pts))
 (set! pts (t3288 pts))
 (set! pts (t3292 pts))
 (set! pts (t3293 pts))
 pts))

(loading)

(set! t3499 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3285 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3286 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3499 pts)))
 (union-points new-pts))))

(loading)

(set! t3501 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3505 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3506 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3504 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3505 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3506 pts)))
 (union-points new-pts))))

(loading)

(set! t3503 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3504 pts))
 pts))

(loading)

(set! t3507 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3502 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3503 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3507 pts)))
 (union-points new-pts))))

(loading)

(set! t3500 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3501 pts))
 (set! pts (t3502 pts))
 pts))

(loading)

(set! t3283 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3284 pts))
 (set! pts (t3285 pts))
 (set! pts (t3500 pts))
 pts))

(loading)

(set! t3508 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3282 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3283 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3508 pts)))
 (union-points new-pts))))

(loading)

(set! t3270 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3271 pts))
 (set! pts (t3272 pts))
 (set! pts (t3276 pts))
 (set! pts (t3277 pts))
 (set! pts (t3281 pts))
 (set! pts (t3282 pts))
 pts))

(loading)

(set! t3509 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3269 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3270 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3509 pts)))
 (union-points new-pts))))

(loading)

(set! t3512 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3513 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3511 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3512 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3513 pts)))
 (union-points new-pts))))

(loading)

(set! t3510 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3511 pts))
 pts))

(loading)

(set! t3267 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3268 pts))
 (set! pts (t3269 pts))
 (set! pts (t3510 pts))
 pts))

(loading)

(set! t3263 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3264 pts))
 (set! pts (t3267 pts))
 pts))

(loading)

(set! t2762 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2763 pts))
 (set! pts (t2764 pts))
 (set! pts (t2768 pts))
 (set! pts (t2769 pts))
 (set! pts (t3263 pts))
 pts))

(loading)

(set! t3514 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2761 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2762 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3514 pts)))
 (union-points new-pts))))

(loading)

(set! t2759 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2760 pts))
 (set! pts (t2761 pts))
 pts))

(loading)

(set! t3515 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2758 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2759 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3515 pts)))
 (union-points new-pts))))

(loading)

(set! t3518 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3519 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3517 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3518 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3519 pts)))
 (union-points new-pts))))

(loading)

(set! t3516 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3517 pts))
 pts))

(loading)

(set! t2756 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2757 pts))
 (set! pts (t2758 pts))
 (set! pts (t3516 pts))
 pts))

(loading)

(set! t3520 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2755 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2756 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3520 pts)))
 (union-points new-pts))))

(loading)

(set! t2753 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2754 pts))
 (set! pts (t2755 pts))
 pts))

(loading)

(set! t3521 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2752 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2753 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3521 pts)))
 (union-points new-pts))))

(loading)

(set! t2750 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2751 pts))
 (set! pts (t2752 pts))
 pts))

(loading)

(set! t2746 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2747 pts))
 (set! pts (t2750 pts))
 pts))

(loading)

(set! t3522 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2745 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2746 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3522 pts)))
 (union-points new-pts))))

(loading)

(set! t3525 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3526 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3524 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3525 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3526 pts)))
 (union-points new-pts))))

(loading)

(set! t3523 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3524 pts))
 pts))

(loading)

(set! t2738 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2739 pts))
 (set! pts (t2740 pts))
 (set! pts (t2744 pts))
 (set! pts (t2745 pts))
 (set! pts (t3523 pts))
 pts))

(loading)

(set! t3527 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2737 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2738 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3527 pts)))
 (union-points new-pts))))

(loading)

(set! t2735 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2736 pts))
 (set! pts (t2737 pts))
 pts))

(loading)

(set! t2707 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2708 pts))
 (set! pts (t2709 pts))
 (set! pts (t2735 pts))
 pts))

(loading)

(set! t2703 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2704 pts))
 (set! pts (t2707 pts))
 pts))

(loading)

(set! t2694 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2695 pts))
 (set! pts (t2698 pts))
 (set! pts (t2702 pts))
 (set! pts (t2703 pts))
 pts))

(loading)

(set! t3528 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2693 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2694 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3528 pts)))
 (union-points new-pts))))

(loading)

(set! t2691 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2692 pts))
 (set! pts (t2693 pts))
 pts))

(loading)

(set! t2632 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2633 pts))
 (set! pts (t2634 pts))
 (set! pts (t2686 pts))
 (set! pts (t2690 pts))
 (set! pts (t2691 pts))
 pts))

(loading)

(set! t2628 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2629 pts))
 (set! pts (t2632 pts))
 pts))

(loading)

(set! t2619 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2620 pts))
 (set! pts (t2623 pts))
 (set! pts (t2627 pts))
 (set! pts (t2628 pts))
 pts))

(loading)

(set! t2615 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2616 pts))
 (set! pts (t2619 pts))
 pts))

(loading)

(set! t3529 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2614 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2615 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3529 pts)))
 (union-points new-pts))))

(loading)

(set! t2612 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2613 pts))
 (set! pts (t2614 pts))
 pts))

(loading)

(set! t3530 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2611 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2612 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3530 pts)))
 (union-points new-pts))))

(loading)

(set! t3532 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3535 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3538 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3542 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3543 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3541 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3542 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3543 pts)))
 (union-points new-pts))))

(loading)

(set! t3546 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3547 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3545 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3546 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3547 pts)))
 (union-points new-pts))))

(loading)

(set! t3544 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3545 pts))
 pts))

(loading)

(set! t3548 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3550 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3553 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3556 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3557 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3555 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3556 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3557 pts)))
 (union-points new-pts))))

(loading)

(set! t3554 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3555 pts))
 pts))

(loading)

(set! t3559 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3560 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3558 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3559 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3560 pts)))
 (union-points new-pts))))

(loading)

(set! t3552 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3553 pts))
 (set! pts (t3554 pts))
 (set! pts (t3558 pts))
 pts))

(loading)

(set! t3561 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3551 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3552 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3561 pts)))
 (union-points new-pts))))

(loading)

(set! t3549 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3550 pts))
 (set! pts (t3551 pts))
 pts))

(loading)

(set! t3540 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3541 pts))
 (set! pts (t3544 pts))
 (set! pts (t3548 pts))
 (set! pts (t3549 pts))
 pts))

(loading)

(set! t3562 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3539 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3540 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3562 pts)))
 (union-points new-pts))))

(loading)

(set! t3537 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3538 pts))
 (set! pts (t3539 pts))
 pts))

(loading)

(set! t3563 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3536 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3537 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3563 pts)))
 (union-points new-pts))))

(loading)

(set! t3534 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3535 pts))
 (set! pts (t3536 pts))
 pts))

(loading)

(set! t3564 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3533 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3534 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3564 pts)))
 (union-points new-pts))))

(loading)

(set! t3567 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3568 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3566 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3567 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3568 pts)))
 (union-points new-pts))))

(loading)

(set! t3565 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3566 pts))
 pts))

(loading)

(set! t3569 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3531 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3532 pts))
 (set! pts (t3533 pts))
 (set! pts (t3565 pts))
 (set! pts (t3569 pts))
 pts))

(loading)

(set! t2609 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2610 pts))
 (set! pts (t2611 pts))
 (set! pts (t3531 pts))
 pts))

(loading)

(set! t3570 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2608 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2609 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3570 pts)))
 (union-points new-pts))))

(loading)

(set! t2601 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2602 pts))
 (set! pts (t2603 pts))
 (set! pts (t2607 pts))
 (set! pts (t2608 pts))
 pts))

(loading)

(set! t2593 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2594 pts))
 (set! pts (t2595 pts))
 (set! pts (t2601 pts))
 pts))

(loading)

(set! t3571 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2592 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2593 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3571 pts)))
 (union-points new-pts))))

(loading)

(set! t3574 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3575 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3573 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3574 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3575 pts)))
 (union-points new-pts))))

(loading)

(set! t3572 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3573 pts))
 pts))

(loading)

(set! t2590 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2591 pts))
 (set! pts (t2592 pts))
 (set! pts (t3572 pts))
 pts))

(loading)

(set! t2581 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2582 pts))
 (set! pts (t2583 pts))
 (set! pts (t2587 pts))
 (set! pts (t2590 pts))
 pts))

(loading)

(set! t3576 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2580 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2581 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3576 pts)))
 (union-points new-pts))))

(loading)

(set! t2578 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2579 pts))
 (set! pts (t2580 pts))
 pts))

(loading)

(set! t2574 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2575 pts))
 (set! pts (t2578 pts))
 pts))

(loading)

(set! t3577 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2573 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2574 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3577 pts)))
 (union-points new-pts))))

(loading)

(set! t2571 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2572 pts))
 (set! pts (t2573 pts))
 pts))

(loading)

(set! t2536 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2537 pts))
 (set! pts (t2538 pts))
 (set! pts (t2571 pts))
 pts))

(loading)

(set! t2532 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2533 pts))
 (set! pts (t2536 pts))
 pts))

(loading)

(set! t2526 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2527 pts))
 (set! pts (t2532 pts))
 pts))

(loading)

(set! t2522 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2523 pts))
 (set! pts (t2526 pts))
 pts))

(loading)

(set! t2513 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2514 pts))
 (set! pts (t2517 pts))
 (set! pts (t2521 pts))
 (set! pts (t2522 pts))
 pts))

(loading)

(set! t2509 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2510 pts))
 (set! pts (t2513 pts))
 pts))

(loading)

(set! t2501 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2502 pts))
 (set! pts (t2503 pts))
 (set! pts (t2509 pts))
 pts))

(loading)

(set! t2493 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2494 pts))
 (set! pts (t2495 pts))
 (set! pts (t2501 pts))
 pts))

(loading)

(set! t3578 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2492 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2493 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3578 pts)))
 (union-points new-pts))))

(loading)

(set! t2485 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2486 pts))
 (set! pts (t2487 pts))
 (set! pts (t2491 pts))
 (set! pts (t2492 pts))
 pts))

(loading)

(set! t3579 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2484 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2485 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3579 pts)))
 (union-points new-pts))))

(loading)

(set! t2482 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2483 pts))
 (set! pts (t2484 pts))
 pts))

(loading)

(set! t3580 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2481 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2482 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3580 pts)))
 (union-points new-pts))))

(loading)

(set! t3583 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3584 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3582 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3583 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3584 pts)))
 (union-points new-pts))))

(loading)

(set! t3581 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3582 pts))
 pts))

(loading)

(set! t3585 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2479 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2480 pts))
 (set! pts (t2481 pts))
 (set! pts (t3581 pts))
 (set! pts (t3585 pts))
 pts))

(loading)

(set! t2475 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2476 pts))
 (set! pts (t2479 pts))
 pts))

(loading)

(set! t2471 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2472 pts))
 (set! pts (t2475 pts))
 pts))

(loading)

(set! t2467 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2468 pts))
 (set! pts (t2471 pts))
 pts))

(loading)

(set! t2458 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2459 pts))
 (set! pts (t2462 pts))
 (set! pts (t2466 pts))
 (set! pts (t2467 pts))
 pts))

(loading)

(set! t3586 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2457 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2458 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3586 pts)))
 (union-points new-pts))))

(loading)

(set! t2455 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2456 pts))
 (set! pts (t2457 pts))
 pts))

(loading)

(set! t3587 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2454 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2455 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3587 pts)))
 (union-points new-pts))))

(loading)

(set! t2452 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2453 pts))
 (set! pts (t2454 pts))
 pts))

(loading)

(set! t3588 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2451 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2452 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3588 pts)))
 (union-points new-pts))))

(loading)

(set! t2449 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2450 pts))
 (set! pts (t2451 pts))
 pts))

(loading)

(set! t2440 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2441 pts))
 (set! pts (t2442 pts))
 (set! pts (t2446 pts))
 (set! pts (t2449 pts))
 pts))

(loading)

(set! t3589 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2439 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2440 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3589 pts)))
 (union-points new-pts))))

(loading)

(set! t2437 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2438 pts))
 (set! pts (t2439 pts))
 pts))

(loading)

(set! t2433 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2434 pts))
 (set! pts (t2437 pts))
 pts))

(loading)

(set! t2273 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2274 pts))
 (set! pts (t2275 pts))
 (set! pts (t2433 pts))
 pts))

(loading)

(set! t3590 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2272 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2273 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3590 pts)))
 (union-points new-pts))))

(loading)

(set! t3593 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3594 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3592 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3593 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3594 pts)))
 (union-points new-pts))))

(loading)

(set! t3591 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3592 pts))
 pts))

(loading)

(set! t2260 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2261 pts))
 (set! pts (t2262 pts))
 (set! pts (t2266 pts))
 (set! pts (t2267 pts))
 (set! pts (t2271 pts))
 (set! pts (t2272 pts))
 (set! pts (t3591 pts))
 pts))

(loading)

(set! t3595 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2259 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2260 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3595 pts)))
 (union-points new-pts))))

(loading)

(set! t2257 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2258 pts))
 (set! pts (t2259 pts))
 pts))

(loading)

(set! t2249 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2250 pts))
 (set! pts (t2251 pts))
 (set! pts (t2257 pts))
 pts))

(loading)

(set! t3596 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2248 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2249 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3596 pts)))
 (union-points new-pts))))

(loading)

(set! t3599 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3600 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3598 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3599 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3600 pts)))
 (union-points new-pts))))

(loading)

(set! t3597 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3598 pts))
 pts))

(loading)

(set! t2246 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2247 pts))
 (set! pts (t2248 pts))
 (set! pts (t3597 pts))
 pts))

(loading)

(set! t3601 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2245 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2246 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3601 pts)))
 (union-points new-pts))))

(loading)

(set! t2243 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2244 pts))
 (set! pts (t2245 pts))
 pts))

(loading)

(set! t3602 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2242 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2243 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3602 pts)))
 (union-points new-pts))))

(loading)

(set! t2240 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2241 pts))
 (set! pts (t2242 pts))
 pts))

(loading)

(set! t2236 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2237 pts))
 (set! pts (t2240 pts))
 pts))

(loading)

(set! t2211 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2212 pts))
 (set! pts (t2213 pts))
 (set! pts (t2236 pts))
 pts))

(loading)

(set! t3603 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2210 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2211 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3603 pts)))
 (union-points new-pts))))

(loading)

(set! t2208 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2209 pts))
 (set! pts (t2210 pts))
 pts))

(loading)

(set! t3604 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2207 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2208 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3604 pts)))
 (union-points new-pts))))

(loading)

(set! t2200 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2201 pts))
 (set! pts (t2202 pts))
 (set! pts (t2206 pts))
 (set! pts (t2207 pts))
 pts))

(loading)

(set! t2192 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2193 pts))
 (set! pts (t2194 pts))
 (set! pts (t2200 pts))
 pts))

(loading)

(set! t3605 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2191 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2192 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3605 pts)))
 (union-points new-pts))))

(loading)

(set! t3608 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3609 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3607 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3608 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3609 pts)))
 (union-points new-pts))))

(loading)

(set! t3612 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3613 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3611 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3612 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3613 pts)))
 (union-points new-pts))))

(loading)

(set! t3610 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3611 pts))
 pts))

(loading)

(set! t3614 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3617 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3618 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3616 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3617 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3618 pts)))
 (union-points new-pts))))

(loading)

(set! t3615 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3616 pts))
 pts))

(loading)

(set! t3606 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3607 pts))
 (set! pts (t3610 pts))
 (set! pts (t3614 pts))
 (set! pts (t3615 pts))
 pts))

(loading)

(set! t2189 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2190 pts))
 (set! pts (t2191 pts))
 (set! pts (t3606 pts))
 pts))

(loading)

(set! t2185 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2186 pts))
 (set! pts (t2189 pts))
 pts))

(loading)

(set! t3619 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2184 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2185 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3619 pts)))
 (union-points new-pts))))

(loading)

(set! t2182 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2183 pts))
 (set! pts (t2184 pts))
 pts))

(loading)

(set! t2178 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2179 pts))
 (set! pts (t2182 pts))
 pts))

(loading)

(set! t2164 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2165 pts))
 (set! pts (t2166 pts))
 (set! pts (t2170 pts))
 (set! pts (t2171 pts))
 (set! pts (t2175 pts))
 (set! pts (t2178 pts))
 pts))

(loading)

(set! t3620 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2163 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2164 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3620 pts)))
 (union-points new-pts))))

(loading)

(set! t2151 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2152 pts))
 (set! pts (t2153 pts))
 (set! pts (t2157 pts))
 (set! pts (t2158 pts))
 (set! pts (t2162 pts))
 (set! pts (t2163 pts))
 pts))

(loading)

(set! t3621 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2150 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2151 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3621 pts)))
 (union-points new-pts))))

(loading)

(set! t2148 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2149 pts))
 (set! pts (t2150 pts))
 pts))

(loading)

(set! t3622 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2147 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2148 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3622 pts)))
 (union-points new-pts))))

(loading)

(set! t2143 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2144 pts))
 (set! pts (t2147 pts))
 pts))

(loading)

(set! t3623 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t2142 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2143 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3623 pts)))
 (union-points new-pts))))

(loading)

(set! t2140 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2141 pts))
 (set! pts (t2142 pts))
 pts))

(loading)

(set! t2131 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2132 pts))
 (set! pts (t2133 pts))
 (set! pts (t2137 pts))
 (set! pts (t2140 pts))
 pts))

(loading)

(set! t2059 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2060 pts))
 (set! pts (t2061 pts))
 (set! pts (t2131 pts))
 pts))

(loading)

(set! t2047 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2048 pts))
 (set! pts (t2049 pts))
 (set! pts (t2059 pts))
 pts))

(loading)

(set! t3624 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t2046 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2047 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3624 pts)))
 (union-points new-pts))))

(loading)

(set! t2044 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2045 pts))
 (set! pts (t2046 pts))
 pts))

(loading)

(set! t3625 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t2043 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2044 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3625 pts)))
 (union-points new-pts))))

(loading)

(set! t2036 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2037 pts))
 (set! pts (t2038 pts))
 (set! pts (t2042 pts))
 (set! pts (t2043 pts))
 pts))

(loading)

(set! t3626 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t2035 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t2036 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3626 pts)))
 (union-points new-pts))))

(loading)

(set! t2033 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2034 pts))
 (set! pts (t2035 pts))
 pts))

(loading)

(set! t2029 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2030 pts))
 (set! pts (t2033 pts))
 pts))

(loading)

(set! t1949 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1950 pts))
 (set! pts (t1951 pts))
 (set! pts (t2019 pts))
 (set! pts (t2023 pts))
 (set! pts (t2024 pts))
 (set! pts (t2028 pts))
 (set! pts (t2029 pts))
 pts))

(loading)

(set! t3627 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1948 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1949 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3627 pts)))
 (union-points new-pts))))

(loading)

(set! t1946 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1947 pts))
 (set! pts (t1948 pts))
 pts))

(loading)

(set! t3628 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1945 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1946 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3628 pts)))
 (union-points new-pts))))

(loading)

(set! t1943 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1944 pts))
 (set! pts (t1945 pts))
 pts))

(loading)

(set! t3629 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1942 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1943 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3629 pts)))
 (union-points new-pts))))

(loading)

(set! t1940 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1941 pts))
 (set! pts (t1942 pts))
 pts))

(loading)

(set! t3630 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1939 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1940 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3630 pts)))
 (union-points new-pts))))

(loading)

(set! t3633 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3634 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3632 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3633 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3634 pts)))
 (union-points new-pts))))

(loading)

(set! t3631 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3632 pts))
 pts))

(loading)

(set! t1937 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1938 pts))
 (set! pts (t1939 pts))
 (set! pts (t3631 pts))
 pts))

(loading)

(set! t1929 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1930 pts))
 (set! pts (t1931 pts))
 (set! pts (t1937 pts))
 pts))

(loading)

(set! t1925 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1926 pts))
 (set! pts (t1929 pts))
 pts))

(loading)

(set! t1917 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1918 pts))
 (set! pts (t1919 pts))
 (set! pts (t1925 pts))
 pts))

(loading)

(set! t1904 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1905 pts))
 (set! pts (t1906 pts))
 (set! pts (t1910 pts))
 (set! pts (t1911 pts))
 (set! pts (t1917 pts))
 pts))

(loading)

(set! t1900 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1901 pts))
 (set! pts (t1904 pts))
 pts))

(loading)

(set! t3635 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1899 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1900 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3635 pts)))
 (union-points new-pts))))

(loading)

(set! t3637 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3640 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3641 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3639 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3640 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3641 pts)))
 (union-points new-pts))))

(loading)

(set! t3638 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3639 pts))
 pts))

(loading)

(set! t3642 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3645 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3646 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3644 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3645 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3646 pts)))
 (union-points new-pts))))

(loading)

(set! t3643 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3644 pts))
 pts))

(loading)

(set! t3647 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3650 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3653 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3657 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3658 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3656 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3657 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3658 pts)))
 (union-points new-pts))))

(loading)

(set! t3661 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3662 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3660 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3661 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3662 pts)))
 (union-points new-pts))))

(loading)

(set! t3659 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3660 pts))
 pts))

(loading)

(set! t3663 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3666 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3667 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3665 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3666 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3667 pts)))
 (union-points new-pts))))

(loading)

(set! t3664 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3665 pts))
 pts))

(loading)

(set! t3668 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3671 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3672 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3670 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3671 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3672 pts)))
 (union-points new-pts))))

(loading)

(set! t3669 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3670 pts))
 pts))

(loading)

(set! t3655 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3656 pts))
 (set! pts (t3659 pts))
 (set! pts (t3663 pts))
 (set! pts (t3664 pts))
 (set! pts (t3668 pts))
 (set! pts (t3669 pts))
 pts))

(loading)

(set! t3673 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3654 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3655 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3673 pts)))
 (union-points new-pts))))

(loading)

(set! t3652 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3653 pts))
 (set! pts (t3654 pts))
 pts))

(loading)

(set! t3674 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3651 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3652 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3674 pts)))
 (union-points new-pts))))

(loading)

(set! t3649 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3650 pts))
 (set! pts (t3651 pts))
 pts))

(loading)

(set! t3675 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3648 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3649 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3675 pts)))
 (union-points new-pts))))

(loading)

(set! t3636 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3637 pts))
 (set! pts (t3638 pts))
 (set! pts (t3642 pts))
 (set! pts (t3643 pts))
 (set! pts (t3647 pts))
 (set! pts (t3648 pts))
 pts))

(loading)

(set! t1897 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1898 pts))
 (set! pts (t1899 pts))
 (set! pts (t3636 pts))
 pts))

(loading)

(set! t3676 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1896 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1897 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3676 pts)))
 (union-points new-pts))))

(loading)

(set! t1894 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1895 pts))
 (set! pts (t1896 pts))
 pts))

(loading)

(set! t1886 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1887 pts))
 (set! pts (t1888 pts))
 (set! pts (t1894 pts))
 pts))

(loading)

(set! t3677 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1885 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1886 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3677 pts)))
 (union-points new-pts))))

(loading)

(set! t1883 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1884 pts))
 (set! pts (t1885 pts))
 pts))

(loading)

(set! t3678 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1882 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1883 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3678 pts)))
 (union-points new-pts))))

(loading)

(set! t3681 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3682 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3680 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3681 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3682 pts)))
 (union-points new-pts))))

(loading)

(set! t3679 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3680 pts))
 pts))

(loading)

(set! t3683 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1880 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1881 pts))
 (set! pts (t1882 pts))
 (set! pts (t3679 pts))
 (set! pts (t3683 pts))
 pts))

(loading)

(set! t3684 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1879 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1880 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3684 pts)))
 (union-points new-pts))))

(loading)

(set! t1877 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1878 pts))
 (set! pts (t1879 pts))
 pts))

(loading)

(set! t3685 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1876 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1877 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3685 pts)))
 (union-points new-pts))))

(loading)

(set! t3688 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3689 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3687 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3688 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3689 pts)))
 (union-points new-pts))))

(loading)

(set! t3686 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3687 pts))
 pts))

(loading)

(set! t1874 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1875 pts))
 (set! pts (t1876 pts))
 (set! pts (t3686 pts))
 pts))

(loading)

(set! t3690 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1873 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1874 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3690 pts)))
 (union-points new-pts))))

(loading)

(set! t3693 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3694 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3692 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3693 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3694 pts)))
 (union-points new-pts))))

(loading)

(set! t3691 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3692 pts))
 pts))

(loading)

(set! t1871 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1872 pts))
 (set! pts (t1873 pts))
 (set! pts (t3691 pts))
 pts))

(loading)

(set! t1867 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1868 pts))
 (set! pts (t1871 pts))
 pts))

(loading)

(set! t3695 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1866 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1867 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3695 pts)))
 (union-points new-pts))))

(loading)

(set! t1864 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1865 pts))
 (set! pts (t1866 pts))
 pts))

(loading)

(set! t3696 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1863 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1864 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3696 pts)))
 (union-points new-pts))))

(loading)

(set! t3698 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3701 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3705 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3706 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3704 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3705 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3706 pts)))
 (union-points new-pts))))

(loading)

(set! t3709 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3710 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3708 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3709 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3710 pts)))
 (union-points new-pts))))

(loading)

(set! t3707 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3708 pts))
 pts))

(loading)

(set! t3711 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3713 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3716 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3719 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3722 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3725 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3728 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3729 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3727 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3728 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3729 pts)))
 (union-points new-pts))))

(loading)

(set! t3726 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3727 pts))
 pts))

(loading)

(set! t3730 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3733 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3734 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3732 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3733 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3734 pts)))
 (union-points new-pts))))

(loading)

(set! t3731 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3732 pts))
 pts))

(loading)

(set! t3736 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3737 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3735 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3736 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3737 pts)))
 (union-points new-pts))))

(loading)

(set! t3740 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3741 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3739 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3740 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3741 pts)))
 (union-points new-pts))))

(loading)

(set! t3738 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3739 pts))
 pts))

(loading)

(set! t3742 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3744 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3748 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3749 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3747 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3748 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3749 pts)))
 (union-points new-pts))))

(loading)

(set! t3752 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3753 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3751 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3752 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3753 pts)))
 (union-points new-pts))))

(loading)

(set! t3756 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3757 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3755 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3756 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3757 pts)))
 (union-points new-pts))))

(loading)

(set! t3754 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3755 pts))
 pts))

(loading)

(set! t3758 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3750 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3751 pts))
 (set! pts (t3754 pts))
 (set! pts (t3758 pts))
 pts))

(loading)

(set! t3746 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3747 pts))
 (set! pts (t3750 pts))
 pts))

(loading)

(set! t3759 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3745 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3746 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3759 pts)))
 (union-points new-pts))))

(loading)

(set! t3743 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3744 pts))
 (set! pts (t3745 pts))
 pts))

(loading)

(set! t3724 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3725 pts))
 (set! pts (t3726 pts))
 (set! pts (t3730 pts))
 (set! pts (t3731 pts))
 (set! pts (t3735 pts))
 (set! pts (t3738 pts))
 (set! pts (t3742 pts))
 (set! pts (t3743 pts))
 pts))

(loading)

(set! t3760 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3723 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3724 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3760 pts)))
 (union-points new-pts))))

(loading)

(set! t3721 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3722 pts))
 (set! pts (t3723 pts))
 pts))

(loading)

(set! t3761 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3720 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3721 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3761 pts)))
 (union-points new-pts))))

(loading)

(set! t3764 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3765 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3763 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3764 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3765 pts)))
 (union-points new-pts))))

(loading)

(set! t3767 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3770 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3771 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3769 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3770 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3771 pts)))
 (union-points new-pts))))

(loading)

(set! t3768 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3769 pts))
 pts))

(loading)

(set! t3773 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3774 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3772 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3773 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3774 pts)))
 (union-points new-pts))))

(loading)

(set! t3766 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3767 pts))
 (set! pts (t3768 pts))
 (set! pts (t3772 pts))
 pts))

(loading)

(set! t3762 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3763 pts))
 (set! pts (t3766 pts))
 pts))

(loading)

(set! t3718 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3719 pts))
 (set! pts (t3720 pts))
 (set! pts (t3762 pts))
 pts))

(loading)

(set! t3775 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3717 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3718 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3775 pts)))
 (union-points new-pts))))

(loading)

(set! t3715 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3716 pts))
 (set! pts (t3717 pts))
 pts))

(loading)

(set! t3776 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3714 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3715 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3776 pts)))
 (union-points new-pts))))

(loading)

(set! t3779 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3780 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3778 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3779 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3780 pts)))
 (union-points new-pts))))

(loading)

(set! t3777 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3778 pts))
 pts))

(loading)

(set! t3781 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3712 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3713 pts))
 (set! pts (t3714 pts))
 (set! pts (t3777 pts))
 (set! pts (t3781 pts))
 pts))

(loading)

(set! t3703 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3704 pts))
 (set! pts (t3707 pts))
 (set! pts (t3711 pts))
 (set! pts (t3712 pts))
 pts))

(loading)

(set! t3782 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3702 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3703 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3782 pts)))
 (union-points new-pts))))

(loading)

(set! t3700 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3701 pts))
 (set! pts (t3702 pts))
 pts))

(loading)

(set! t3783 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3699 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3700 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3783 pts)))
 (union-points new-pts))))

(loading)

(set! t3697 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3698 pts))
 (set! pts (t3699 pts))
 pts))

(loading)

(set! t1851 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1852 pts))
 (set! pts (t1853 pts))
 (set! pts (t1857 pts))
 (set! pts (t1858 pts))
 (set! pts (t1862 pts))
 (set! pts (t1863 pts))
 (set! pts (t3697 pts))
 pts))

(loading)

(set! t1843 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1844 pts))
 (set! pts (t1845 pts))
 (set! pts (t1851 pts))
 pts))

(loading)

(set! t1839 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1840 pts))
 (set! pts (t1843 pts))
 pts))

(loading)

(set! t1830 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1831 pts))
 (set! pts (t1834 pts))
 (set! pts (t1838 pts))
 (set! pts (t1839 pts))
 pts))

(loading)

(set! t1826 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1827 pts))
 (set! pts (t1830 pts))
 pts))

(loading)

(set! t1822 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1823 pts))
 (set! pts (t1826 pts))
 pts))

(loading)

(set! t3784 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1821 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1822 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3784 pts)))
 (union-points new-pts))))

(loading)

(set! t3787 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3788 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3786 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3787 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3788 pts)))
 (union-points new-pts))))

(loading)

(set! t3785 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3786 pts))
 pts))

(loading)

(set! t3789 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1814 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1815 pts))
 (set! pts (t1816 pts))
 (set! pts (t1820 pts))
 (set! pts (t1821 pts))
 (set! pts (t3785 pts))
 (set! pts (t3789 pts))
 pts))

(loading)

(set! t1794 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1795 pts))
 (set! pts (t1796 pts))
 (set! pts (t1814 pts))
 pts))

(loading)

(set! t3790 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1793 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1794 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3790 pts)))
 (union-points new-pts))))

(loading)

(set! t1791 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1792 pts))
 (set! pts (t1793 pts))
 pts))

(loading)

(set! t3791 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1790 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1791 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3791 pts)))
 (union-points new-pts))))

(loading)

(set! t1788 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1789 pts))
 (set! pts (t1790 pts))
 pts))

(loading)

(set! t3792 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1787 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1788 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3792 pts)))
 (union-points new-pts))))

(loading)

(set! t3795 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3796 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3794 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3795 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3796 pts)))
 (union-points new-pts))))

(loading)

(set! t3793 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3794 pts))
 pts))

(loading)

(set! t1785 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1786 pts))
 (set! pts (t1787 pts))
 (set! pts (t3793 pts))
 pts))

(loading)

(set! t1776 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1777 pts))
 (set! pts (t1780 pts))
 (set! pts (t1784 pts))
 (set! pts (t1785 pts))
 pts))

(loading)

(set! t1772 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1773 pts))
 (set! pts (t1776 pts))
 pts))

(loading)

(set! t3797 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1771 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1772 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3797 pts)))
 (union-points new-pts))))

(loading)

(set! t1769 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1770 pts))
 (set! pts (t1771 pts))
 pts))

(loading)

(set! t1765 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1766 pts))
 (set! pts (t1769 pts))
 pts))

(loading)

(set! t3798 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1764 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1765 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3798 pts)))
 (union-points new-pts))))

(loading)

(set! t3801 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3802 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3800 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3801 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3802 pts)))
 (union-points new-pts))))

(loading)

(set! t3799 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3800 pts))
 pts))

(loading)

(set! t3803 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3805 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3809 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3810 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3808 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3809 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3810 pts)))
 (union-points new-pts))))

(loading)

(set! t3807 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3808 pts))
 pts))

(loading)

(set! t3811 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3806 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3807 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3811 pts)))
 (union-points new-pts))))

(loading)

(set! t3813 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3816 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3819 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3820 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3818 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3819 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3820 pts)))
 (union-points new-pts))))

(loading)

(set! t3817 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3818 pts))
 pts))

(loading)

(set! t3824 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3825 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3823 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3824 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3825 pts)))
 (union-points new-pts))))

(loading)

(set! t3828 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3829 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3827 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3828 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3829 pts)))
 (union-points new-pts))))

(loading)

(set! t3832 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3833 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3831 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3832 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3833 pts)))
 (union-points new-pts))))

(loading)

(set! t3830 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3831 pts))
 pts))

(loading)

(set! t3826 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3827 pts))
 (set! pts (t3830 pts))
 pts))

(loading)

(set! t3822 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3823 pts))
 (set! pts (t3826 pts))
 pts))

(loading)

(set! t3834 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3821 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3822 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3834 pts)))
 (union-points new-pts))))

(loading)

(set! t3815 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3816 pts))
 (set! pts (t3817 pts))
 (set! pts (t3821 pts))
 pts))

(loading)

(set! t3835 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3814 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3815 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3835 pts)))
 (union-points new-pts))))

(loading)

(set! t3838 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3839 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3837 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3838 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3839 pts)))
 (union-points new-pts))))

(loading)

(set! t3836 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3837 pts))
 pts))

(loading)

(set! t3812 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3813 pts))
 (set! pts (t3814 pts))
 (set! pts (t3836 pts))
 pts))

(loading)

(set! t3804 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3805 pts))
 (set! pts (t3806 pts))
 (set! pts (t3812 pts))
 pts))

(loading)

(set! t1762 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1763 pts))
 (set! pts (t1764 pts))
 (set! pts (t3799 pts))
 (set! pts (t3803 pts))
 (set! pts (t3804 pts))
 pts))

(loading)

(set! t1750 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1751 pts))
 (set! pts (t1752 pts))
 (set! pts (t1762 pts))
 pts))

(loading)

(set! t3840 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1749 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1750 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3840 pts)))
 (union-points new-pts))))

(loading)

(set! t3842 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3846 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3847 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3845 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3846 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3847 pts)))
 (union-points new-pts))))

(loading)

(set! t3844 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3845 pts))
 pts))

(loading)

(set! t3848 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3843 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3844 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3848 pts)))
 (union-points new-pts))))

(loading)

(set! t3851 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3852 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3850 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3851 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3852 pts)))
 (union-points new-pts))))

(loading)

(set! t3849 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3850 pts))
 pts))

(loading)

(set! t3841 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3842 pts))
 (set! pts (t3843 pts))
 (set! pts (t3849 pts))
 pts))

(loading)

(set! t1747 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1748 pts))
 (set! pts (t1749 pts))
 (set! pts (t3841 pts))
 pts))

(loading)

(set! t1622 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1623 pts))
 (set! pts (t1624 pts))
 (set! pts (t1747 pts))
 pts))

(loading)

(set! t1613 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1614 pts))
 (set! pts (t1615 pts))
 (set! pts (t1619 pts))
 (set! pts (t1622 pts))
 pts))

(loading)

(set! t3853 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1612 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1613 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3853 pts)))
 (union-points new-pts))))

(loading)

(set! t1610 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1611 pts))
 (set! pts (t1612 pts))
 pts))

(loading)

(set! t3854 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1609 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1610 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3854 pts)))
 (union-points new-pts))))

(loading)

(set! t1602 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1603 pts))
 (set! pts (t1604 pts))
 (set! pts (t1608 pts))
 (set! pts (t1609 pts))
 pts))

(loading)

(set! t3855 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1601 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1602 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3855 pts)))
 (union-points new-pts))))

(loading)

(set! t3858 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3859 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3857 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3858 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3859 pts)))
 (union-points new-pts))))

(loading)

(set! t3856 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3857 pts))
 pts))

(loading)

(set! t1599 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1600 pts))
 (set! pts (t1601 pts))
 (set! pts (t3856 pts))
 pts))

(loading)

(set! t3860 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1598 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1599 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3860 pts)))
 (union-points new-pts))))

(loading)

(set! t3862 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3865 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3869 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3870 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3868 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3869 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3870 pts)))
 (union-points new-pts))))

(loading)

(set! t3867 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3868 pts))
 pts))

(loading)

(set! t3871 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3866 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3867 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3871 pts)))
 (union-points new-pts))))

(loading)

(set! t3874 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3875 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3873 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3874 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3875 pts)))
 (union-points new-pts))))

(loading)

(set! t3872 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3873 pts))
 pts))

(loading)

(set! t3876 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3864 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3865 pts))
 (set! pts (t3866 pts))
 (set! pts (t3872 pts))
 (set! pts (t3876 pts))
 pts))

(loading)

(set! t3877 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3863 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3864 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3877 pts)))
 (union-points new-pts))))

(loading)

(set! t3861 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3862 pts))
 (set! pts (t3863 pts))
 pts))

(loading)

(set! t1596 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1597 pts))
 (set! pts (t1598 pts))
 (set! pts (t3861 pts))
 pts))

(loading)

(set! t3878 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t1595 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1596 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3878 pts)))
 (union-points new-pts))))

(loading)

(set! t3881 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3883 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3884 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3882 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3883 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3884 pts)))
 (union-points new-pts))))

(loading)

(set! t3880 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3881 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3882 pts)))
 (union-points new-pts))))

(loading)

(set! t3879 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3880 pts))
 pts))

(loading)

(set! t1593 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1594 pts))
 (set! pts (t1595 pts))
 (set! pts (t3879 pts))
 pts))

(loading)

(set! t1589 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1590 pts))
 (set! pts (t1593 pts))
 pts))

(loading)

(set! t3885 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1588 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1589 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3885 pts)))
 (union-points new-pts))))

(loading)

(set! t1586 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1587 pts))
 (set! pts (t1588 pts))
 pts))

(loading)

(set! t3886 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1585 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1586 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3886 pts)))
 (union-points new-pts))))

(loading)

(set! t3889 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3890 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3888 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3889 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3890 pts)))
 (union-points new-pts))))

(loading)

(set! t3887 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3888 pts))
 pts))

(loading)

(set! t1583 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1584 pts))
 (set! pts (t1585 pts))
 (set! pts (t3887 pts))
 pts))

(loading)

(set! t1579 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1580 pts))
 (set! pts (t1583 pts))
 pts))

(loading)

(set! t3891 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1578 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1579 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3891 pts)))
 (union-points new-pts))))

(loading)

(set! t3894 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3895 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3893 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3894 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3895 pts)))
 (union-points new-pts))))

(loading)

(set! t3892 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3893 pts))
 pts))

(loading)

(set! t3896 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3899 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3900 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3898 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3899 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3900 pts)))
 (union-points new-pts))))

(loading)

(set! t3897 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3898 pts))
 pts))

(loading)

(set! t1571 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1572 pts))
 (set! pts (t1573 pts))
 (set! pts (t1577 pts))
 (set! pts (t1578 pts))
 (set! pts (t3892 pts))
 (set! pts (t3896 pts))
 (set! pts (t3897 pts))
 pts))

(loading)

(set! t1562 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1563 pts))
 (set! pts (t1566 pts))
 (set! pts (t1570 pts))
 (set! pts (t1571 pts))
 pts))

(loading)

(set! t1558 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1559 pts))
 (set! pts (t1562 pts))
 pts))

(loading)

(set! t3901 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1557 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1558 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3901 pts)))
 (union-points new-pts))))

(loading)

(set! t3903 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3906 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3907 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3905 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3906 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3907 pts)))
 (union-points new-pts))))

(loading)

(set! t3904 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3905 pts))
 pts))

(loading)

(set! t3909 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3910 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3908 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3909 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3910 pts)))
 (union-points new-pts))))

(loading)

(set! t3902 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3903 pts))
 (set! pts (t3904 pts))
 (set! pts (t3908 pts))
 pts))

(loading)

(set! t1555 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1556 pts))
 (set! pts (t1557 pts))
 (set! pts (t3902 pts))
 pts))

(loading)

(set! t1414 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1415 pts))
 (set! pts (t1416 pts))
 (set! pts (t1555 pts))
 pts))

(loading)

(set! t3911 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1413 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1414 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3911 pts)))
 (union-points new-pts))))

(loading)

(set! t3913 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3916 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3917 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3915 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3916 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3917 pts)))
 (union-points new-pts))))

(loading)

(set! t3914 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3915 pts))
 pts))

(loading)

(set! t3919 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3920 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3918 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3919 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3920 pts)))
 (union-points new-pts))))

(loading)

(set! t3923 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3924 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3922 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3923 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3924 pts)))
 (union-points new-pts))))

(loading)

(set! t3921 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3922 pts))
 pts))

(loading)

(set! t3912 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3913 pts))
 (set! pts (t3914 pts))
 (set! pts (t3918 pts))
 (set! pts (t3921 pts))
 pts))

(loading)

(set! t1406 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1407 pts))
 (set! pts (t1408 pts))
 (set! pts (t1412 pts))
 (set! pts (t1413 pts))
 (set! pts (t3912 pts))
 pts))

(loading)

(set! t1402 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1403 pts))
 (set! pts (t1406 pts))
 pts))

(loading)

(set! t1398 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1399 pts))
 (set! pts (t1402 pts))
 pts))

(loading)

(set! t1385 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1386 pts))
 (set! pts (t1387 pts))
 (set! pts (t1393 pts))
 (set! pts (t1397 pts))
 (set! pts (t1398 pts))
 pts))

(loading)

(set! t3925 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1384 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1385 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3925 pts)))
 (union-points new-pts))))

(loading)

(set! t1382 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1383 pts))
 (set! pts (t1384 pts))
 pts))

(loading)

(set! t3926 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1381 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1382 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3926 pts)))
 (union-points new-pts))))

(loading)

(set! t1379 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1380 pts))
 (set! pts (t1381 pts))
 pts))

(loading)

(set! t1370 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1371 pts))
 (set! pts (t1372 pts))
 (set! pts (t1376 pts))
 (set! pts (t1379 pts))
 pts))

(loading)

(set! t3927 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1369 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1370 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3927 pts)))
 (union-points new-pts))))

(loading)

(set! t3930 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3931 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3929 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3930 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3931 pts)))
 (union-points new-pts))))

(loading)

(set! t3928 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3929 pts))
 pts))

(loading)

(set! t1367 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1368 pts))
 (set! pts (t1369 pts))
 (set! pts (t3928 pts))
 pts))

(loading)

(set! t3932 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1366 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1367 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3932 pts)))
 (union-points new-pts))))

(loading)

(set! t1364 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1365 pts))
 (set! pts (t1366 pts))
 pts))

(loading)

(set! t3933 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t1363 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1364 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3933 pts)))
 (union-points new-pts))))

(loading)

(set! t1361 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1362 pts))
 (set! pts (t1363 pts))
 pts))

(loading)

(set! t3934 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t1360 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1361 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3934 pts)))
 (union-points new-pts))))

(loading)

(set! t1358 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1359 pts))
 (set! pts (t1360 pts))
 pts))

(loading)

(set! t3935 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t1357 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t1358 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3935 pts)))
 (union-points new-pts))))

(loading)

(set! t3938 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3939 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3937 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3938 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3939 pts)))
 (union-points new-pts))))

(loading)

(set! t3936 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3937 pts))
 pts))

(loading)

(set! t3940 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3943 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3944 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3942 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3943 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3944 pts)))
 (union-points new-pts))))

(loading)

(set! t3947 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3948 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3946 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3947 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3948 pts)))
 (union-points new-pts))))

(loading)

(set! t3951 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3952 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3950 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3951 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3952 pts)))
 (union-points new-pts))))

(loading)

(set! t3949 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3950 pts))
 pts))

(loading)

(set! t3945 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3946 pts))
 (set! pts (t3949 pts))
 pts))

(loading)

(set! t3941 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3942 pts))
 (set! pts (t3945 pts))
 pts))

(loading)

(set! t1355 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t1356 pts))
 (set! pts (t1357 pts))
 (set! pts (t3936 pts))
 (set! pts (t3940 pts))
 (set! pts (t3941 pts))
 pts))

(loading)

(set! t741 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t742 pts))
 (set! pts (t743 pts))
 (set! pts (t1355 pts))
 pts))

(loading)

(set! t705 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t706 pts))
 (set! pts (t707 pts))
 (set! pts (t711 pts))
 (set! pts (t712 pts))
 (set! pts (t741 pts))
 pts))

(loading)

(set! t3953 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t704 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t705 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3953 pts)))
 (union-points new-pts))))

(loading)

(set! t702 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t703 pts))
 (set! pts (t704 pts))
 pts))

(loading)

(set! t694 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t695 pts))
 (set! pts (t696 pts))
 (set! pts (t702 pts))
 pts))

(loading)

(set! t3954 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t693 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t694 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3954 pts)))
 (union-points new-pts))))

(loading)

(set! t691 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t692 pts))
 (set! pts (t693 pts))
 pts))

(loading)

(set! t683 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t684 pts))
 (set! pts (t685 pts))
 (set! pts (t691 pts))
 pts))

(loading)

(set! t670 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t671 pts))
 (set! pts (t672 pts))
 (set! pts (t683 pts))
 pts))

(loading)

(set! t649 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t650 pts))
 (set! pts (t651 pts))
 (set! pts (t670 pts))
 pts))

(loading)

(set! t3955 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t648 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t649 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3955 pts)))
 (union-points new-pts))))

(loading)

(set! t646 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t647 pts))
 (set! pts (t648 pts))
 pts))

(loading)

(set! t625 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t626 pts))
 (set! pts (t627 pts))
 (set! pts (t631 pts))
 (set! pts (t632 pts))
 (set! pts (t642 pts))
 (set! pts (t646 pts))
 pts))

(loading)

(set! t3956 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t624 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t625 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3956 pts)))
 (union-points new-pts))))

(loading)

(set! t622 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t623 pts))
 (set! pts (t624 pts))
 pts))

(loading)

(set! t3957 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t621 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t622 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3957 pts)))
 (union-points new-pts))))

(loading)

(set! t619 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t620 pts))
 (set! pts (t621 pts))
 pts))

(loading)

(set! t3958 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t618 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t619 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3958 pts)))
 (union-points new-pts))))

(loading)

(set! t616 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t617 pts))
 (set! pts (t618 pts))
 pts))

(loading)

(set! t3959 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t615 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t616 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3959 pts)))
 (union-points new-pts))))

(loading)

(set! t3962 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3963 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3961 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3962 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3963 pts)))
 (union-points new-pts))))

(loading)

(set! t3960 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3961 pts))
 pts))

(loading)

(set! t613 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t614 pts))
 (set! pts (t615 pts))
 (set! pts (t3960 pts))
 pts))

(loading)

(set! t3964 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t612 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t613 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3964 pts)))
 (union-points new-pts))))

(loading)

(set! t610 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t611 pts))
 (set! pts (t612 pts))
 pts))

(loading)

(set! t3965 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t609 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t610 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3965 pts)))
 (union-points new-pts))))

(loading)

(set! t3968 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3969 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3967 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3968 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3969 pts)))
 (union-points new-pts))))

(loading)

(set! t3966 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3967 pts))
 pts))

(loading)

(set! t3970 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t607 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t608 pts))
 (set! pts (t609 pts))
 (set! pts (t3966 pts))
 (set! pts (t3970 pts))
 pts))

(loading)

(set! t3971 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t606 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t607 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3971 pts)))
 (union-points new-pts))))

(loading)

(set! t3974 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3975 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3973 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3974 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3975 pts)))
 (union-points new-pts))))

(loading)

(set! t3978 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3979 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3977 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3978 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3979 pts)))
 (union-points new-pts))))

(loading)

(set! t3976 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3977 pts))
 pts))

(loading)

(set! t3972 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3973 pts))
 (set! pts (t3976 pts))
 pts))

(loading)

(set! t604 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t605 pts))
 (set! pts (t606 pts))
 (set! pts (t3972 pts))
 pts))

(loading)

(set! t3980 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t603 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t604 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3980 pts)))
 (union-points new-pts))))

(loading)

(set! t596 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t597 pts))
 (set! pts (t598 pts))
 (set! pts (t602 pts))
 (set! pts (t603 pts))
 pts))

(loading)

(set! t3981 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t595 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t596 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3981 pts)))
 (union-points new-pts))))

(loading)

(set! t3984 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3985 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3983 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3984 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3985 pts)))
 (union-points new-pts))))

(loading)

(set! t3988 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3989 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3987 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3988 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3989 pts)))
 (union-points new-pts))))

(loading)

(set! t3991 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t3994 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t3997 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t3998 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t3996 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3997 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3998 pts)))
 (union-points new-pts))))

(loading)

(set! t3995 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3996 pts))
 pts))

(loading)

(set! t3999 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4002 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4003 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t4001 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4002 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4003 pts)))
 (union-points new-pts))))

(loading)

(set! t4000 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4001 pts))
 pts))

(loading)

(set! t4005 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4006 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4004 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4005 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4006 pts)))
 (union-points new-pts))))

(loading)

(set! t3993 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3994 pts))
 (set! pts (t3995 pts))
 (set! pts (t3999 pts))
 (set! pts (t4000 pts))
 (set! pts (t4004 pts))
 pts))

(loading)

(set! t4007 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t3992 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t3993 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4007 pts)))
 (union-points new-pts))))

(loading)

(set! t3990 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3991 pts))
 (set! pts (t3992 pts))
 pts))

(loading)

(set! t3986 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3987 pts))
 (set! pts (t3990 pts))
 pts))

(loading)

(set! t3982 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t3983 pts))
 (set! pts (t3986 pts))
 pts))

(loading)

(set! t593 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t594 pts))
 (set! pts (t595 pts))
 (set! pts (t3982 pts))
 pts))

(loading)

(set! t589 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t590 pts))
 (set! pts (t593 pts))
 pts))

(loading)

(set! t4008 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t588 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t589 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4008 pts)))
 (union-points new-pts))))

(loading)

(set! t4011 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4012 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t4010 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4011 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4012 pts)))
 (union-points new-pts))))

(loading)

(set! t4009 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4010 pts))
 pts))

(loading)

(set! t4013 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4015 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4018 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4021 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4024 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4025 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t4023 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4024 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4025 pts)))
 (union-points new-pts))))

(loading)

(set! t4022 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4023 pts))
 pts))

(loading)

(set! t4026 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4029 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4033 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4034 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4032 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4033 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4034 pts)))
 (union-points new-pts))))

(loading)

(set! t4031 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4032 pts))
 pts))

(loading)

(set! t4035 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4030 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4031 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4035 pts)))
 (union-points new-pts))))

(loading)

(set! t4028 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4029 pts))
 (set! pts (t4030 pts))
 pts))

(loading)

(set! t4036 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4027 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4028 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4036 pts)))
 (union-points new-pts))))

(loading)

(set! t4020 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4021 pts))
 (set! pts (t4022 pts))
 (set! pts (t4026 pts))
 (set! pts (t4027 pts))
 pts))

(loading)

(set! t4037 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4019 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4020 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4037 pts)))
 (union-points new-pts))))

(loading)

(set! t4040 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4041 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t4039 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4040 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4041 pts)))
 (union-points new-pts))))

(loading)

(set! t4038 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4039 pts))
 pts))

(loading)

(set! t4042 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4017 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4018 pts))
 (set! pts (t4019 pts))
 (set! pts (t4038 pts))
 (set! pts (t4042 pts))
 pts))

(loading)

(set! t4043 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4016 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4017 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4043 pts)))
 (union-points new-pts))))

(loading)

(set! t4014 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4015 pts))
 (set! pts (t4016 pts))
 pts))

(loading)

(set! t586 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t587 pts))
 (set! pts (t588 pts))
 (set! pts (t4009 pts))
 (set! pts (t4013 pts))
 (set! pts (t4014 pts))
 pts))

(loading)

(set! t4044 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t585 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t586 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4044 pts)))
 (union-points new-pts))))

(loading)

(set! t583 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t584 pts))
 (set! pts (t585 pts))
 pts))

(loading)

(set! t4045 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t582 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t583 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4045 pts)))
 (union-points new-pts))))

(loading)

(set! t4048 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4049 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4047 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4048 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4049 pts)))
 (union-points new-pts))))

(loading)

(set! t4046 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4047 pts))
 pts))

(loading)

(set! t580 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t581 pts))
 (set! pts (t582 pts))
 (set! pts (t4046 pts))
 pts))

(loading)

(set! t4050 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t579 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t580 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4050 pts)))
 (union-points new-pts))))

(loading)

(set! t4053 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4054 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4052 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4053 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4054 pts)))
 (union-points new-pts))))

(loading)

(set! t4051 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4052 pts))
 pts))

(loading)

(set! t572 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t573 pts))
 (set! pts (t574 pts))
 (set! pts (t578 pts))
 (set! pts (t579 pts))
 (set! pts (t4051 pts))
 pts))

(loading)

(set! t564 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t565 pts))
 (set! pts (t566 pts))
 (set! pts (t572 pts))
 pts))

(loading)

(set! t4055 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t563 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t564 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4055 pts)))
 (union-points new-pts))))

(loading)

(set! t561 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t562 pts))
 (set! pts (t563 pts))
 pts))

(loading)

(set! t531 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t532 pts))
 (set! pts (t533 pts))
 (set! pts (t561 pts))
 pts))

(loading)

(set! t527 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t528 pts))
 (set! pts (t531 pts))
 pts))

(loading)

(set! t523 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t524 pts))
 (set! pts (t527 pts))
 pts))

(loading)

(set! t4056 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t522 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t523 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4056 pts)))
 (union-points new-pts))))

(loading)

(set! t515 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t516 pts))
 (set! pts (t517 pts))
 (set! pts (t521 pts))
 (set! pts (t522 pts))
 pts))

(loading)

(set! t4057 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t514 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t515 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4057 pts)))
 (union-points new-pts))))

(loading)

(set! t502 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t503 pts))
 (set! pts (t504 pts))
 (set! pts (t508 pts))
 (set! pts (t509 pts))
 (set! pts (t513 pts))
 (set! pts (t514 pts))
 pts))

(loading)

(set! t4058 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t501 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t502 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4058 pts)))
 (union-points new-pts))))

(loading)

(set! t499 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t500 pts))
 (set! pts (t501 pts))
 pts))

(loading)

(set! t486 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t487 pts))
 (set! pts (t488 pts))
 (set! pts (t499 pts))
 pts))

(loading)

(set! t482 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t483 pts))
 (set! pts (t486 pts))
 pts))

(loading)

(set! t4059 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t481 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t482 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4059 pts)))
 (union-points new-pts))))

(loading)

(set! t479 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t480 pts))
 (set! pts (t481 pts))
 pts))

(loading)

(set! t4060 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t478 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t479 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4060 pts)))
 (union-points new-pts))))

(loading)

(set! t466 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t467 pts))
 (set! pts (t468 pts))
 (set! pts (t472 pts))
 (set! pts (t473 pts))
 (set! pts (t477 pts))
 (set! pts (t478 pts))
 pts))

(loading)

(set! t462 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t463 pts))
 (set! pts (t466 pts))
 pts))

(loading)

(set! t458 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t459 pts))
 (set! pts (t462 pts))
 pts))

(loading)

(set! t4061 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t457 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t458 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4061 pts)))
 (union-points new-pts))))

(loading)

(set! t4064 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4065 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4063 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4064 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4065 pts)))
 (union-points new-pts))))

(loading)

(set! t4068 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4069 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4067 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4068 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4069 pts)))
 (union-points new-pts))))

(loading)

(set! t4066 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4067 pts))
 pts))

(loading)

(set! t4062 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4063 pts))
 (set! pts (t4066 pts))
 pts))

(loading)

(set! t455 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t456 pts))
 (set! pts (t457 pts))
 (set! pts (t4062 pts))
 pts))

(loading)

(set! t439 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t440 pts))
 (set! pts (t441 pts))
 (set! pts (t455 pts))
 pts))

(loading)

(set! t4070 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t438 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t439 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4070 pts)))
 (union-points new-pts))))

(loading)

(set! t4073 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4074 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t4072 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4073 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4074 pts)))
 (union-points new-pts))))

(loading)

(set! t4071 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4072 pts))
 pts))

(loading)

(set! t4075 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4077 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4080 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4081 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t4079 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4080 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4081 pts)))
 (union-points new-pts))))

(loading)

(set! t4078 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4079 pts))
 pts))

(loading)

(set! t4082 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4086 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4087 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4085 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4086 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4087 pts)))
 (union-points new-pts))))

(loading)

(set! t4090 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4091 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t4089 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4090 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4091 pts)))
 (union-points new-pts))))

(loading)

(set! t4088 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4089 pts))
 pts))

(loading)

(set! t4092 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4084 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4085 pts))
 (set! pts (t4088 pts))
 (set! pts (t4092 pts))
 pts))

(loading)

(set! t4093 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4083 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4084 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4093 pts)))
 (union-points new-pts))))

(loading)

(set! t4076 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4077 pts))
 (set! pts (t4078 pts))
 (set! pts (t4082 pts))
 (set! pts (t4083 pts))
 pts))

(loading)

(set! t436 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t437 pts))
 (set! pts (t438 pts))
 (set! pts (t4071 pts))
 (set! pts (t4075 pts))
 (set! pts (t4076 pts))
 pts))

(loading)

(set! t4094 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t435 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t436 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4094 pts)))
 (union-points new-pts))))

(loading)

(set! t433 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t434 pts))
 (set! pts (t435 pts))
 pts))

(loading)

(set! t402 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t403 pts))
 (set! pts (t404 pts))
 (set! pts (t428 pts))
 (set! pts (t432 pts))
 (set! pts (t433 pts))
 pts))

(loading)

(set! t398 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t399 pts))
 (set! pts (t402 pts))
 pts))

(loading)

(set! t394 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t395 pts))
 (set! pts (t398 pts))
 pts))

(loading)

(set! t390 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t391 pts))
 (set! pts (t394 pts))
 pts))

(loading)

(set! t4095 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t389 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t390 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4095 pts)))
 (union-points new-pts))))

(loading)

(set! t387 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t388 pts))
 (set! pts (t389 pts))
 pts))

(loading)

(set! t383 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t384 pts))
 (set! pts (t387 pts))
 pts))

(loading)

(set! t4096 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t382 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t383 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4096 pts)))
 (union-points new-pts))))

(loading)

(set! t380 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t381 pts))
 (set! pts (t382 pts))
 pts))

(loading)

(set! t4097 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t379 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t380 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4097 pts)))
 (union-points new-pts))))

(loading)

(set! t377 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t378 pts))
 (set! pts (t379 pts))
 pts))

(loading)

(set! t373 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t374 pts))
 (set! pts (t377 pts))
 pts))

(loading)

(set! t369 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t370 pts))
 (set! pts (t373 pts))
 pts))

(loading)

(set! t361 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t362 pts))
 (set! pts (t363 pts))
 (set! pts (t369 pts))
 pts))

(loading)

(set! t4098 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t360 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t361 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4098 pts)))
 (union-points new-pts))))

(loading)

(set! t4100 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4103 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4106 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4107 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t4105 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4106 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4107 pts)))
 (union-points new-pts))))

(loading)

(set! t4104 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4105 pts))
 pts))

(loading)

(set! t4109 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4110 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4108 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4109 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4110 pts)))
 (union-points new-pts))))

(loading)

(set! t4113 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4114 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t4112 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4113 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4114 pts)))
 (union-points new-pts))))

(loading)

(set! t4111 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4112 pts))
 pts))

(loading)

(set! t4115 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4102 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4103 pts))
 (set! pts (t4104 pts))
 (set! pts (t4108 pts))
 (set! pts (t4111 pts))
 (set! pts (t4115 pts))
 pts))

(loading)

(set! t4116 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4101 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4102 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4116 pts)))
 (union-points new-pts))))

(loading)

(set! t4119 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4120 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4118 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4119 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4120 pts)))
 (union-points new-pts))))

(loading)

(set! t4123 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4124 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4122 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4123 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4124 pts)))
 (union-points new-pts))))

(loading)

(set! t4126 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4130 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4131 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4129 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4130 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4131 pts)))
 (union-points new-pts))))

(loading)

(set! t4134 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4135 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t4133 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4134 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4135 pts)))
 (union-points new-pts))))

(loading)

(set! t4132 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4133 pts))
 pts))

(loading)

(set! t4136 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4128 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4129 pts))
 (set! pts (t4132 pts))
 (set! pts (t4136 pts))
 pts))

(loading)

(set! t4137 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4127 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4128 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4137 pts)))
 (union-points new-pts))))

(loading)

(set! t4125 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4126 pts))
 (set! pts (t4127 pts))
 pts))

(loading)

(set! t4121 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4122 pts))
 (set! pts (t4125 pts))
 pts))

(loading)

(set! t4117 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4118 pts))
 (set! pts (t4121 pts))
 pts))

(loading)

(set! t4099 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4100 pts))
 (set! pts (t4101 pts))
 (set! pts (t4117 pts))
 pts))

(loading)

(set! t358 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t359 pts))
 (set! pts (t360 pts))
 (set! pts (t4099 pts))
 pts))

(loading)

(set! t354 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t355 pts))
 (set! pts (t358 pts))
 pts))

(loading)

(set! t329 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t330 pts))
 (set! pts (t331 pts))
 (set! pts (t354 pts))
 pts))

(loading)

(set! t4138 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t328 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t329 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4138 pts)))
 (union-points new-pts))))

(loading)

(set! t326 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t327 pts))
 (set! pts (t328 pts))
 pts))

(loading)

(set! t322 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t323 pts))
 (set! pts (t326 pts))
 pts))

(loading)

(set! t4139 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t321 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t322 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4139 pts)))
 (union-points new-pts))))

(loading)

(set! t319 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t320 pts))
 (set! pts (t321 pts))
 pts))

(loading)

(set! t311 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t312 pts))
 (set! pts (t313 pts))
 (set! pts (t319 pts))
 pts))

(loading)

(set! t4140 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t310 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t311 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4140 pts)))
 (union-points new-pts))))

(loading)

(set! t4143 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4144 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t4142 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4143 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4144 pts)))
 (union-points new-pts))))

(loading)

(set! t4141 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4142 pts))
 pts))

(loading)

(set! t4145 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4148 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4149 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4147 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4148 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4149 pts)))
 (union-points new-pts))))

(loading)

(set! t4152 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4153 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4151 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4152 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4153 pts)))
 (union-points new-pts))))

(loading)

(set! t4155 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4158 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4162 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4163 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4161 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4162 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4163 pts)))
 (union-points new-pts))))

(loading)

(set! t4160 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4161 pts))
 pts))

(loading)

(set! t4164 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4159 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4160 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4164 pts)))
 (union-points new-pts))))

(loading)

(set! t4157 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4158 pts))
 (set! pts (t4159 pts))
 pts))

(loading)

(set! t4165 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4156 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4157 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4165 pts)))
 (union-points new-pts))))

(loading)

(set! t4154 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4155 pts))
 (set! pts (t4156 pts))
 pts))

(loading)

(set! t4150 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4151 pts))
 (set! pts (t4154 pts))
 pts))

(loading)

(set! t4146 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4147 pts))
 (set! pts (t4150 pts))
 pts))

(loading)

(set! t308 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t309 pts))
 (set! pts (t310 pts))
 (set! pts (t4141 pts))
 (set! pts (t4145 pts))
 (set! pts (t4146 pts))
 pts))

(loading)

(set! t4166 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t307 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t308 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4166 pts)))
 (union-points new-pts))))

(loading)

(set! t305 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t306 pts))
 (set! pts (t307 pts))
 pts))

(loading)

(set! t301 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t302 pts))
 (set! pts (t305 pts))
 pts))

(loading)

(set! t4167 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t300 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t301 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4167 pts)))
 (union-points new-pts))))

(loading)

(set! t4169 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4173 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4174 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t4172 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4173 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4174 pts)))
 (union-points new-pts))))

(loading)

(set! t4171 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4172 pts))
 pts))

(loading)

(set! t4175 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4170 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4171 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4175 pts)))
 (union-points new-pts))))

(loading)

(set! t4178 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4179 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4177 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4178 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4179 pts)))
 (union-points new-pts))))

(loading)

(set! t4176 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4177 pts))
 pts))

(loading)

(set! t4168 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4169 pts))
 (set! pts (t4170 pts))
 (set! pts (t4176 pts))
 pts))

(loading)

(set! t288 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t289 pts))
 (set! pts (t290 pts))
 (set! pts (t294 pts))
 (set! pts (t295 pts))
 (set! pts (t299 pts))
 (set! pts (t300 pts))
 (set! pts (t4168 pts))
 pts))

(loading)

(set! t284 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t285 pts))
 (set! pts (t288 pts))
 pts))

(loading)

(set! t4180 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t283 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t284 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4180 pts)))
 (union-points new-pts))))

(loading)

(set! t4183 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4184 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4182 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4183 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4184 pts)))
 (union-points new-pts))))

(loading)

(set! t4181 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4182 pts))
 pts))

(loading)

(set! t281 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t282 pts))
 (set! pts (t283 pts))
 (set! pts (t4181 pts))
 pts))

(loading)

(set! t4185 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t280 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t281 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4185 pts)))
 (union-points new-pts))))

(loading)

(set! t4188 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4189 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t4187 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4188 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4189 pts)))
 (union-points new-pts))))

(loading)

(set! t4186 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4187 pts))
 pts))

(loading)

(set! t4190 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4193 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4194 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t4192 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4193 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4194 pts)))
 (union-points new-pts))))

(loading)

(set! t4191 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4192 pts))
 pts))

(loading)

(set! t4195 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4197 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4201 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4202 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4200 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4201 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4202 pts)))
 (union-points new-pts))))

(loading)

(set! t4205 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4206 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t4204 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4205 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4206 pts)))
 (union-points new-pts))))

(loading)

(set! t4203 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4204 pts))
 pts))

(loading)

(set! t4207 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4199 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4200 pts))
 (set! pts (t4203 pts))
 (set! pts (t4207 pts))
 pts))

(loading)

(set! t4208 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4198 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4199 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4208 pts)))
 (union-points new-pts))))

(loading)

(set! t4196 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4197 pts))
 (set! pts (t4198 pts))
 pts))

(loading)

(set! t278 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t279 pts))
 (set! pts (t280 pts))
 (set! pts (t4186 pts))
 (set! pts (t4190 pts))
 (set! pts (t4191 pts))
 (set! pts (t4195 pts))
 (set! pts (t4196 pts))
 pts))

(loading)

(set! t4209 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t277 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t278 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4209 pts)))
 (union-points new-pts))))

(loading)

(set! t275 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t276 pts))
 (set! pts (t277 pts))
 pts))

(loading)

(set! t4210 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t274 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t275 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4210 pts)))
 (union-points new-pts))))

(loading)

(set! t272 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t273 pts))
 (set! pts (t274 pts))
 pts))

(loading)

(set! t4211 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t271 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t272 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4211 pts)))
 (union-points new-pts))))

(loading)

(set! t4214 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4215 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4213 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4214 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4215 pts)))
 (union-points new-pts))))

(loading)

(set! t4217 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4220 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4223 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4227 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4228 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4226 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4227 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4228 pts)))
 (union-points new-pts))))

(loading)

(set! t4225 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4226 pts))
 pts))

(loading)

(set! t4229 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4224 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4225 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4229 pts)))
 (union-points new-pts))))

(loading)

(set! t4232 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4233 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t4231 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4232 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4233 pts)))
 (union-points new-pts))))

(loading)

(set! t4230 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4231 pts))
 pts))

(loading)

(set! t4234 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4237 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4238 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t4236 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4237 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4238 pts)))
 (union-points new-pts))))

(loading)

(set! t4235 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4236 pts))
 pts))

(loading)

(set! t4239 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4222 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4223 pts))
 (set! pts (t4224 pts))
 (set! pts (t4230 pts))
 (set! pts (t4234 pts))
 (set! pts (t4235 pts))
 (set! pts (t4239 pts))
 pts))

(loading)

(set! t4240 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4221 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4222 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4240 pts)))
 (union-points new-pts))))

(loading)

(set! t4243 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4244 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4242 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4243 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4244 pts)))
 (union-points new-pts))))

(loading)

(set! t4247 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4248 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t4246 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4247 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4248 pts)))
 (union-points new-pts))))

(loading)

(set! t4245 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4246 pts))
 pts))

(loading)

(set! t4249 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4241 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4242 pts))
 (set! pts (t4245 pts))
 (set! pts (t4249 pts))
 pts))

(loading)

(set! t4219 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4220 pts))
 (set! pts (t4221 pts))
 (set! pts (t4241 pts))
 pts))

(loading)

(set! t4250 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4218 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4219 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4250 pts)))
 (union-points new-pts))))

(loading)

(set! t4252 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4255 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4256 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t4254 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4255 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4256 pts)))
 (union-points new-pts))))

(loading)

(set! t4253 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4254 pts))
 pts))

(loading)

(set! t4257 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4260 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4264 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4265 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4263 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4264 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4265 pts)))
 (union-points new-pts))))

(loading)

(set! t4262 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4263 pts))
 pts))

(loading)

(set! t4266 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4261 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4262 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4266 pts)))
 (union-points new-pts))))

(loading)

(set! t4259 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4260 pts))
 (set! pts (t4261 pts))
 pts))

(loading)

(set! t4267 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4258 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4259 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4267 pts)))
 (union-points new-pts))))

(loading)

(set! t4251 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4252 pts))
 (set! pts (t4253 pts))
 (set! pts (t4257 pts))
 (set! pts (t4258 pts))
 pts))

(loading)

(set! t4216 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4217 pts))
 (set! pts (t4218 pts))
 (set! pts (t4251 pts))
 pts))

(loading)

(set! t4212 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4213 pts))
 (set! pts (t4216 pts))
 pts))

(loading)

(set! t264 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t265 pts))
 (set! pts (t266 pts))
 (set! pts (t270 pts))
 (set! pts (t271 pts))
 (set! pts (t4212 pts))
 pts))

(loading)

(set! t4268 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t263 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t264 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4268 pts)))
 (union-points new-pts))))

(loading)

(set! t261 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t262 pts))
 (set! pts (t263 pts))
 pts))

(loading)

(set! t257 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t258 pts))
 (set! pts (t261 pts))
 pts))

(loading)

(set! t249 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t250 pts))
 (set! pts (t251 pts))
 (set! pts (t257 pts))
 pts))

(loading)

(set! t4269 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t248 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t249 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4269 pts)))
 (union-points new-pts))))

(loading)

(set! t246 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t247 pts))
 (set! pts (t248 pts))
 pts))

(loading)

(set! t238 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t239 pts))
 (set! pts (t240 pts))
 (set! pts (t246 pts))
 pts))

(loading)

(set! t4270 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t237 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t238 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4270 pts)))
 (union-points new-pts))))

(loading)

(set! t235 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t236 pts))
 (set! pts (t237 pts))
 pts))

(loading)

(set! t4271 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t234 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t235 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4271 pts)))
 (union-points new-pts))))

(loading)

(set! t4274 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4275 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4273 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4274 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4275 pts)))
 (union-points new-pts))))

(loading)

(set! t4278 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4279 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4277 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4278 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4279 pts)))
 (union-points new-pts))))

(loading)

(set! t4276 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4277 pts))
 pts))

(loading)

(set! t4272 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4273 pts))
 (set! pts (t4276 pts))
 pts))

(loading)

(set! t232 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t233 pts))
 (set! pts (t234 pts))
 (set! pts (t4272 pts))
 pts))

(loading)

(set! t223 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t224 pts))
 (set! pts (t227 pts))
 (set! pts (t231 pts))
 (set! pts (t232 pts))
 pts))

(loading)

(set! t4280 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t222 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t223 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4280 pts)))
 (union-points new-pts))))

(loading)

(set! t220 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t221 pts))
 (set! pts (t222 pts))
 pts))

(loading)

(set! t216 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t217 pts))
 (set! pts (t220 pts))
 pts))

(loading)

(set! t212 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t213 pts))
 (set! pts (t216 pts))
 pts))

(loading)

(set! t204 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t205 pts))
 (set! pts (t206 pts))
 (set! pts (t212 pts))
 pts))

(loading)

(set! t4281 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t203 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t204 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4281 pts)))
 (union-points new-pts))))

(loading)

(set! t201 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t202 pts))
 (set! pts (t203 pts))
 pts))

(loading)

(set! t4282 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t200 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t201 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4282 pts)))
 (union-points new-pts))))

(loading)

(set! t4285 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4286 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4284 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4285 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4286 pts)))
 (union-points new-pts))))

(loading)

(set! t4283 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4284 pts))
 pts))

(loading)

(set! t198 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t199 pts))
 (set! pts (t200 pts))
 (set! pts (t4283 pts))
 pts))

(loading)

(set! t190 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t191 pts))
 (set! pts (t192 pts))
 (set! pts (t198 pts))
 pts))

(loading)

(set! t4287 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t189 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t190 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4287 pts)))
 (union-points new-pts))))

(loading)

(set! t187 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t188 pts))
 (set! pts (t189 pts))
 pts))

(loading)

(set! t4288 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t186 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t187 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4288 pts)))
 (union-points new-pts))))

(loading)

(set! t184 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t185 pts))
 (set! pts (t186 pts))
 pts))

(loading)

(set! t4289 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t183 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t184 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4289 pts)))
 (union-points new-pts))))

(loading)

(set! t4291 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4295 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4296 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4294 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4295 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4296 pts)))
 (union-points new-pts))))

(loading)

(set! t4293 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4294 pts))
 pts))

(loading)

(set! t4297 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4292 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4293 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4297 pts)))
 (union-points new-pts))))

(loading)

(set! t4300 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4301 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4299 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4300 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4301 pts)))
 (union-points new-pts))))

(loading)

(set! t4298 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4299 pts))
 pts))

(loading)

(set! t4290 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4291 pts))
 (set! pts (t4292 pts))
 (set! pts (t4298 pts))
 pts))

(loading)

(set! t176 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t177 pts))
 (set! pts (t178 pts))
 (set! pts (t182 pts))
 (set! pts (t183 pts))
 (set! pts (t4290 pts))
 pts))

(loading)

(set! t4302 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t175 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t176 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4302 pts)))
 (union-points new-pts))))

(loading)

(set! t173 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t174 pts))
 (set! pts (t175 pts))
 pts))

(loading)

(set! t165 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t166 pts))
 (set! pts (t167 pts))
 (set! pts (t173 pts))
 pts))

(loading)

(set! t151 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t152 pts))
 (set! pts (t153 pts))
 (set! pts (t157 pts))
 (set! pts (t160 pts))
 (set! pts (t164 pts))
 (set! pts (t165 pts))
 pts))

(loading)

(set! t4303 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t150 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t151 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4303 pts)))
 (union-points new-pts))))

(loading)

(set! t148 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t149 pts))
 (set! pts (t150 pts))
 pts))

(loading)

(set! t4304 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t147 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t148 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4304 pts)))
 (union-points new-pts))))

(loading)

(set! t145 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t146 pts))
 (set! pts (t147 pts))
 pts))

(loading)

(set! t141 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t142 pts))
 (set! pts (t145 pts))
 pts))

(loading)

(set! t4305 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t140 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t141 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4305 pts)))
 (union-points new-pts))))

(loading)

(set! t138 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t139 pts))
 (set! pts (t140 pts))
 pts))

(loading)

(set! t134 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t135 pts))
 (set! pts (t138 pts))
 pts))

(loading)

(set! t125 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t126 pts))
 (set! pts (t129 pts))
 (set! pts (t133 pts))
 (set! pts (t134 pts))
 pts))

(loading)

(set! t4306 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t124 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t125 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4306 pts)))
 (union-points new-pts))))

(loading)

(set! t4308 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4311 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4312 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
;; ? : nop 
  (make-point x y))) pts)))

(loading)

(set! t4310 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4311 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4312 pts)))
 (union-points new-pts))))

(loading)

(set! t4309 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4310 pts))
 pts))

(loading)

(set! t4314 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4315 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4313 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4314 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4315 pts)))
 (union-points new-pts))))

(loading)

(set! t4318 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4319 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4317 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4318 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4319 pts)))
 (union-points new-pts))))

(loading)

(set! t4316 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4317 pts))
 pts))

(loading)

(set! t4307 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4308 pts))
 (set! pts (t4309 pts))
 (set! pts (t4313 pts))
 (set! pts (t4316 pts))
 pts))

(loading)

(set! t122 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t123 pts))
 (set! pts (t124 pts))
 (set! pts (t4307 pts))
 pts))

(loading)

(set! t118 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t119 pts))
 (set! pts (t122 pts))
 pts))

(loading)

(set! t109 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t110 pts))
 (set! pts (t113 pts))
 (set! pts (t117 pts))
 (set! pts (t118 pts))
 pts))

(loading)

(set! t91 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t92 pts))
 (set! pts (t93 pts))
 (set! pts (t99 pts))
 (set! pts (t103 pts))
 (set! pts (t104 pts))
 (set! pts (t108 pts))
 (set! pts (t109 pts))
 pts))

(loading)

(set! t72 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t73 pts))
 (set! pts (t74 pts))
 (set! pts (t78 pts))
 (set! pts (t79 pts))
 (set! pts (t83 pts))
 (set! pts (t86 pts))
 (set! pts (t90 pts))
 (set! pts (t91 pts))
 pts))

(loading)

(set! t4320 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t71 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t72 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4320 pts)))
 (union-points new-pts))))

(loading)

(set! t69 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t70 pts))
 (set! pts (t71 pts))
 pts))

(loading)

(set! t65 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t66 pts))
 (set! pts (t69 pts))
 pts))

(loading)

(set! t61 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t62 pts))
 (set! pts (t65 pts))
 pts))

(loading)

(set! t4321 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t60 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t61 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4321 pts)))
 (union-points new-pts))))

(loading)

(set! t4323 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4327 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4328 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4326 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4327 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4328 pts)))
 (union-points new-pts))))

(loading)

(set! t4325 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4326 pts))
 pts))

(loading)

(set! t4329 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4324 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4325 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4329 pts)))
 (union-points new-pts))))

(loading)

(set! t4332 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
  (make-point x y))) pts)))

(loading)

(set! t4333 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4331 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4332 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4333 pts)))
 (union-points new-pts))))

(loading)

(set! t4330 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4331 pts))
 pts))

(loading)

(set! t4322 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4323 pts))
 (set! pts (t4324 pts))
 (set! pts (t4330 pts))
 pts))

(loading)

(set! t58 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t59 pts))
 (set! pts (t60 pts))
 (set! pts (t4322 pts))
 pts))

(loading)

(set! t54 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t55 pts))
 (set! pts (t58 pts))
 pts))

(loading)

(set! t4334 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t53 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t54 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4334 pts)))
 (union-points new-pts))))

(loading)

(set! t4337 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4338 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t4336 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4337 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4338 pts)))
 (union-points new-pts))))

(loading)

(set! t4341 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4342 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4340 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4341 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4342 pts)))
 (union-points new-pts))))

(loading)

(set! t4344 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (- x 1)) (open-side-door! x y) (set! x (- x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; west 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4348 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4349 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (+ y 1)) (open-trap-door! x y) (set! y (+ y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; north 
  (make-point x y))) pts)))

(loading)

(set! t4347 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4348 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4349 pts)))
 (union-points new-pts))))

(loading)

(set! t4346 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4347 pts))
 pts))

(loading)

(set! t4350 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! x (+ x 1)) (open-side-door! x y) (set! x (+ x 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; east 
  (make-point x y))) pts)))

(loading)

(set! t4345 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4346 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4350 pts)))
 (union-points new-pts))))

(loading)

(set! t4343 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4344 pts))
 (set! pts (t4345 pts))
 pts))

(loading)

(set! t4339 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4340 pts))
 (set! pts (t4343 pts))
 pts))

(loading)

(set! t4335 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4336 pts))
 (set! pts (t4339 pts))
 pts))

(loading)

(set! t46 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t47 pts))
 (set! pts (t48 pts))
 (set! pts (t52 pts))
 (set! pts (t53 pts))
 (set! pts (t4335 pts))
 pts))

(loading)

(set! t4351 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t45 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t46 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4351 pts)))
 (union-points new-pts))))

(loading)

(set! t43 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t44 pts))
 (set! pts (t45 pts))
 pts))

(loading)

(set! t39 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t40 pts))
 (set! pts (t43 pts))
 pts))

(loading)

(set! t25 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t26 pts))
 (set! pts (t29 pts))
 (set! pts (t33 pts))
 (set! pts (t34 pts))
 (set! pts (t38 pts))
 (set! pts (t39 pts))
 pts))

(loading)

(set! t4352 (lambda (pts) 
(report)
 (map (lambda (pt) 
 (let ((x (point-x pt))(y (point-y pt))) 
   (set! y (- y 1)) (open-trap-door! x y) (set! y (- y 1)) (set! *step-count* (+ 1 *step-count*)) (mark-square! x y *step-count*)    ;; south 
  (make-point x y))) pts)))

(loading)

(set! t24 (lambda (pts) 
 ;; alt node - union of generated points  
 ;; we need to record global *step-count* and reset it to original value every alternate leg we explore 
(report)
(let ((new-pts (make-union (make-hash-table))) 
      (original-step-count *step-count*))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t25 pts)))
 (set! *step-count* original-step-count)
 (set! new-pts (union-add new-pts (t4352 pts)))
 (union-points new-pts))))

(loading)

(set! t22 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t23 pts))
 (set! pts (t24 pts))
 pts))

(loading)

(set! t3 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t4 pts))
 (set! pts (t5 pts))
 (set! pts (t22 pts))
 pts))

(loading)

(set! t1 (lambda (pts) 
 ;; seq node - iterative until sequence complete  
 ;; simply leave *step-count* to increment at its own volition  
(report)
 (set! pts (t2 pts))
 (set! pts (t3 pts))
 pts))

;; just run it - get idea of run time
(run)

;; report all open doors
(call-with-output-file "../output/side-doors.scm"
  (lambda (port)
    (format port "(define *side-doors* '(")
    (hash-table-for-each *side-doors* (lambda (k v)
				   (format port "(~a ~a)~%" (point-x k) (point-y k))))
    (format port "))~%")))
(format #t "recorded *side-doors* in ../output/side-doors.scm~%")


(call-with-output-file "../output/trap-doors.scm"
  (lambda (port)
    (format port "(define *trap-doors* '(")
    (hash-table-for-each *trap-doors* (lambda (k v)
				   (format port "(~a ~a)~%" (point-x k) (point-y k))))
    (format port "))~%")))
(format #t "recorded *trap-doors* in ../output/trap-doors.scm~%")


(call-with-output-file "../output/step-array.scm"
  (lambda (port)
    (format port "(define *step-array* '(")
    (do ((y 0 (+ y 1)))
	((>= y 2399) #f)
      (do ((x 0 (+ x 1)))
	  ((>= x 2399) #f)
	(let ((tx (translate-out-x x))
	      (ty (translate-out-y y)))
	  (format port "(~a ~a ~a)~%" x y (array-ref2 *step-array* tx ty)))))
    (format port "))~%")))
(format #t "recorded *step-array* in ../output/step-array.scm~%")

 
(call-with-output-file "../output/end-points.scm"
  (lambda (port)
    (format port "(define *endpoints* '(")
    (let loop ((pts *endpoints*))
      (cond
       ((null? pts) #f)
       (#t (let ((pt (car pts)))
	     (format port "(~a ~a)~%" (point-x pt) (point-y pt))
	     (loop (cdr pts))))))
    (format port "))~%")))
(format #t "recorded *endpoints* in ../output/end-points.scm~%")

    
